import { defineComponent, computed, createVNode, mergeProps, effectScope, getCurrentScope, onScopeDispose, unref, watch, provide, toRefs, getCurrentInstance, inject, ref, Fragment, Comment, createTextVNode, isVNode, createApp, onMounted, cloneVNode, TransitionGroup, Transition, isRef, openBlock, createElementBlock, normalizeClass, createElementVNode, renderSlot, toDisplayString, createCommentVNode, renderList, createBlock, reactive, nextTick, h, Teleport, onBeforeUnmount, onActivated, onUnmounted, withDirectives, vShow, normalizeStyle, resolveComponent, withKeys, withModifiers, shallowRef, createSlots, withCtx, render as render$w, onBeforeMount, onDeactivated, readonly, toRef, watchEffect, triggerRef } from 'vue';

const version = '0.7.25';
var version$1 = version;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;

/** Detect free variable `self`. */

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal$1 || freeSelf || Function('return this')();
var root$1 = root;

/** Built-in value references. */

var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;

/** Used for built-in method references. */

var objectProto$g = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$d = objectProto$g.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString$1 = objectProto$g.toString;
/** Built-in value references. */

var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty$d.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }

  return result;
}

/** Used for built-in method references. */
var objectProto$f = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto$f.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */

var symbolTag$3 = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
var isArray$1 = isArray;

/** Used as references for various `Number` constants. */

var INFINITY$1 = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto$2 = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray$1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
}

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

/** Used to match leading whitespace. */

var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity$1(value) {
  return value;
}

/** `Object#toString` result references. */

var asyncTag = '[object AsyncFunction]',
    funcTag$2 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */

var coreJsData = root$1['__core-js_shared__'];
var coreJsData$1 = coreJsData;

/** Used to detect methods masquerading as native. */

var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$2 = funcProto$2.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto$1 = Function.prototype,
    objectProto$e = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString$1 = funcProto$1.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$c = objectProto$e.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$c).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */

function getNative(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */

var WeakMap$1 = getNative(root$1, 'WeakMap');
var WeakMap$2 = WeakMap$1;

/** Built-in value references. */

var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

var baseCreate$1 = baseCreate;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

var defineProperty$1 = defineProperty;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var baseSetToString = !defineProperty$1 ? identity$1 : function (func, string) {
  return defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
var baseSetToString$1 = baseSetToString;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */

var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty$1) {
    defineProperty$1(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/** Used for built-in method references. */

var objectProto$d = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$b = objectProto$d.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty$b.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */

function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax$1 = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */

function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity$1), func + '');
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */

function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */

function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }

  var type = typeof index;

  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }

  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */

function createAssigner(assigner) {
  return baseRest(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

/** Used for built-in method references. */
var objectProto$c = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$c;
  return value === proto;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

/** `Object#toString` result references. */

var argsTag$3 = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$3;
}

/** Used for built-in method references. */

var objectProto$b = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$a = objectProto$b.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty$a.call(value, 'callee') && !propertyIsEnumerable$1.call(value, 'callee');
};
var isArguments$1 = isArguments;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */

var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
/** Built-in value references. */

var Buffer$1 = moduleExports$2 ? root$1.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;

/** `Object#toString` result references. */

var argsTag$2 = '[object Arguments]',
    arrayTag$2 = '[object Array]',
    boolTag$4 = '[object Boolean]',
    dateTag$3 = '[object Date]',
    errorTag$2 = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag$6 = '[object Map]',
    numberTag$4 = '[object Number]',
    objectTag$4 = '[object Object]',
    regexpTag$3 = '[object RegExp]',
    setTag$6 = '[object Set]',
    stringTag$4 = '[object String]',
    weakMapTag$2 = '[object WeakMap]';
var arrayBufferTag$3 = '[object ArrayBuffer]',
    dataViewTag$4 = '[object DataView]',
    float32Tag$2 = '[object Float32Array]',
    float64Tag$2 = '[object Float64Array]',
    int8Tag$2 = '[object Int8Array]',
    int16Tag$2 = '[object Int16Array]',
    int32Tag$2 = '[object Int32Array]',
    uint8Tag$2 = '[object Uint8Array]',
    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
    uint16Tag$2 = '[object Uint16Array]',
    uint32Tag$2 = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */

var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports$1 && freeGlobal$1.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

var nodeUtil$1 = nodeUtil;

/* Node.js helper references. */

var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;

/** Used for built-in method references. */

var objectProto$a = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$9.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;

/** Used for built-in method references. */

var objectProto$9 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */

function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

/** Used for built-in method references. */

var objectProto$8 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$7.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */

function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/** Used to match property names within property paths. */

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }

  var type = typeof value;

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/* Built-in method references that are verified to be native. */

var nativeCreate = getNative(Object, 'create');
var nativeCreate$1 = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */

function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto$7 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }

  return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */

var objectProto$6 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$5.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */

var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === undefined ? HASH_UNDEFINED$1 : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

/** Used for built-in method references. */

var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */

function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */

var Map$1 = getNative(root$1, 'Map');
var Map$2 = Map$1;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */

function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map$2 || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */

function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */

function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */

var FUNC_ERROR_TEXT$2 = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }

  var memoized = function () {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;

/** Used as the maximum memoize cache size. */

var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

/** Used to match property names within property paths. */

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
    result.push('');
  }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
var stringToPath$1 = stringToPath;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */

function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */

function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}

/** Used as references for various `Number` constants. */

var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */

function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */

function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

/** Built-in value references. */

var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;

/** `Object#toString` result references. */

var objectTag$3 = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto$5 = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
    return false;
  }

  var proto = getPrototype$1(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty$4.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }

  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }

  return accumulator;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map Latin Unicode letters to basic Latin letters. */

var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',
  '\xc1': 'A',
  '\xc2': 'A',
  '\xc3': 'A',
  '\xc4': 'A',
  '\xc5': 'A',
  '\xe0': 'a',
  '\xe1': 'a',
  '\xe2': 'a',
  '\xe3': 'a',
  '\xe4': 'a',
  '\xe5': 'a',
  '\xc7': 'C',
  '\xe7': 'c',
  '\xd0': 'D',
  '\xf0': 'd',
  '\xc8': 'E',
  '\xc9': 'E',
  '\xca': 'E',
  '\xcb': 'E',
  '\xe8': 'e',
  '\xe9': 'e',
  '\xea': 'e',
  '\xeb': 'e',
  '\xcc': 'I',
  '\xcd': 'I',
  '\xce': 'I',
  '\xcf': 'I',
  '\xec': 'i',
  '\xed': 'i',
  '\xee': 'i',
  '\xef': 'i',
  '\xd1': 'N',
  '\xf1': 'n',
  '\xd2': 'O',
  '\xd3': 'O',
  '\xd4': 'O',
  '\xd5': 'O',
  '\xd6': 'O',
  '\xd8': 'O',
  '\xf2': 'o',
  '\xf3': 'o',
  '\xf4': 'o',
  '\xf5': 'o',
  '\xf6': 'o',
  '\xf8': 'o',
  '\xd9': 'U',
  '\xda': 'U',
  '\xdb': 'U',
  '\xdc': 'U',
  '\xf9': 'u',
  '\xfa': 'u',
  '\xfb': 'u',
  '\xfc': 'u',
  '\xdd': 'Y',
  '\xfd': 'y',
  '\xff': 'y',
  '\xc6': 'Ae',
  '\xe6': 'ae',
  '\xde': 'Th',
  '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',
  '\u0102': 'A',
  '\u0104': 'A',
  '\u0101': 'a',
  '\u0103': 'a',
  '\u0105': 'a',
  '\u0106': 'C',
  '\u0108': 'C',
  '\u010a': 'C',
  '\u010c': 'C',
  '\u0107': 'c',
  '\u0109': 'c',
  '\u010b': 'c',
  '\u010d': 'c',
  '\u010e': 'D',
  '\u0110': 'D',
  '\u010f': 'd',
  '\u0111': 'd',
  '\u0112': 'E',
  '\u0114': 'E',
  '\u0116': 'E',
  '\u0118': 'E',
  '\u011a': 'E',
  '\u0113': 'e',
  '\u0115': 'e',
  '\u0117': 'e',
  '\u0119': 'e',
  '\u011b': 'e',
  '\u011c': 'G',
  '\u011e': 'G',
  '\u0120': 'G',
  '\u0122': 'G',
  '\u011d': 'g',
  '\u011f': 'g',
  '\u0121': 'g',
  '\u0123': 'g',
  '\u0124': 'H',
  '\u0126': 'H',
  '\u0125': 'h',
  '\u0127': 'h',
  '\u0128': 'I',
  '\u012a': 'I',
  '\u012c': 'I',
  '\u012e': 'I',
  '\u0130': 'I',
  '\u0129': 'i',
  '\u012b': 'i',
  '\u012d': 'i',
  '\u012f': 'i',
  '\u0131': 'i',
  '\u0134': 'J',
  '\u0135': 'j',
  '\u0136': 'K',
  '\u0137': 'k',
  '\u0138': 'k',
  '\u0139': 'L',
  '\u013b': 'L',
  '\u013d': 'L',
  '\u013f': 'L',
  '\u0141': 'L',
  '\u013a': 'l',
  '\u013c': 'l',
  '\u013e': 'l',
  '\u0140': 'l',
  '\u0142': 'l',
  '\u0143': 'N',
  '\u0145': 'N',
  '\u0147': 'N',
  '\u014a': 'N',
  '\u0144': 'n',
  '\u0146': 'n',
  '\u0148': 'n',
  '\u014b': 'n',
  '\u014c': 'O',
  '\u014e': 'O',
  '\u0150': 'O',
  '\u014d': 'o',
  '\u014f': 'o',
  '\u0151': 'o',
  '\u0154': 'R',
  '\u0156': 'R',
  '\u0158': 'R',
  '\u0155': 'r',
  '\u0157': 'r',
  '\u0159': 'r',
  '\u015a': 'S',
  '\u015c': 'S',
  '\u015e': 'S',
  '\u0160': 'S',
  '\u015b': 's',
  '\u015d': 's',
  '\u015f': 's',
  '\u0161': 's',
  '\u0162': 'T',
  '\u0164': 'T',
  '\u0166': 'T',
  '\u0163': 't',
  '\u0165': 't',
  '\u0167': 't',
  '\u0168': 'U',
  '\u016a': 'U',
  '\u016c': 'U',
  '\u016e': 'U',
  '\u0170': 'U',
  '\u0172': 'U',
  '\u0169': 'u',
  '\u016b': 'u',
  '\u016d': 'u',
  '\u016f': 'u',
  '\u0171': 'u',
  '\u0173': 'u',
  '\u0174': 'W',
  '\u0175': 'w',
  '\u0176': 'Y',
  '\u0177': 'y',
  '\u0178': 'Y',
  '\u0179': 'Z',
  '\u017b': 'Z',
  '\u017d': 'Z',
  '\u017a': 'z',
  '\u017c': 'z',
  '\u017e': 'z',
  '\u0132': 'IJ',
  '\u0133': 'ij',
  '\u0152': 'Oe',
  '\u0153': 'oe',
  '\u0149': "'n",
  '\u017f': 's'
};
/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */

var deburrLetter = basePropertyOf(deburredLetters);
var deburrLetter$1 = deburrLetter;

/** Used to match Latin Unicode letters (excluding mathematical operators). */

var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
/** Used to compose unicode character classes. */

var rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
/** Used to compose unicode capture groups. */

var rsCombo$1 = '[' + rsComboRange$1 + ']';
/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */

var reComboMark = RegExp(rsCombo$1, 'g');
/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('dj vu');
 * // => 'deja vu'
 */

function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, '');
}

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */

function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */

function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
/** Used to compose unicode capture groups. */

var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';
/** Used to compose unicode regexes. */

var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;
/** Used to match complex or compound words. */

var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');
/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */

function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */

function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }

  return string.match(pattern) || [];
}

/** Used to compose unicode capture groups. */

var rsApos = "['\u2019]";
/** Used to match apostrophes. */

var reApos = RegExp(rsApos, 'g');
/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */

function createCompounder(callback) {
  return function (string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */

function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */

var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */

function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */

function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */

function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

/** Detect free variable `exports`. */

var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root$1.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/** Used for built-in method references. */

var objectProto$4 = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto$4.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols$1 ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */

function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }

  return result;
};
var getSymbolsIn$1 = getSymbolsIn;

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */

function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */

function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */

function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}

/* Built-in method references that are verified to be native. */

var DataView = getNative(root$1, 'DataView');
var DataView$1 = DataView;

/* Built-in method references that are verified to be native. */

var Promise$1 = getNative(root$1, 'Promise');
var Promise$2 = Promise$1;

/* Built-in method references that are verified to be native. */

var Set$1 = getNative(root$1, 'Set');
var Set$2 = Set$1;

/** `Object#toString` result references. */

var mapTag$5 = '[object Map]',
    objectTag$2 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$5 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';
var dataViewTag$3 = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView$1),
    mapCtorString = toSource(Map$2),
    promiseCtorString = toSource(Promise$2),
    setCtorString = toSource(Set$2),
    weakMapCtorString = toSource(WeakMap$2);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$5 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$5 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
  getTag = function (value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$3;

        case mapCtorString:
          return mapTag$5;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag$5;

        case weakMapCtorString:
          return weakMapTag$1;
      }
    }

    return result;
  };
}

var getTag$1 = getTag;

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty$3.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

/** Built-in value references. */

var Uint8Array = root$1.Uint8Array;
var Uint8Array$1 = Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */

function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */

function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/** Used to convert symbols to primitives and strings. */

var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */

function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/** `Object#toString` result references. */

var boolTag$3 = '[object Boolean]',
    dateTag$2 = '[object Date]',
    mapTag$4 = '[object Map]',
    numberTag$3 = '[object Number]',
    regexpTag$2 = '[object RegExp]',
    setTag$4 = '[object Set]',
    stringTag$3 = '[object String]',
    symbolTag$2 = '[object Symbol]';
var arrayBufferTag$2 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]',
    float32Tag$1 = '[object Float32Array]',
    float64Tag$1 = '[object Float64Array]',
    int8Tag$1 = '[object Int8Array]',
    int16Tag$1 = '[object Int16Array]',
    int32Tag$1 = '[object Int32Array]',
    uint8Tag$1 = '[object Uint8Array]',
    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
    uint16Tag$1 = '[object Uint16Array]',
    uint32Tag$1 = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object);

    case boolTag$3:
    case dateTag$2:
      return new Ctor(+object);

    case dataViewTag$2:
      return cloneDataView(object, isDeep);

    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);

    case mapTag$4:
      return new Ctor();

    case numberTag$3:
    case stringTag$3:
      return new Ctor(object);

    case regexpTag$2:
      return cloneRegExp(object);

    case setTag$4:
      return new Ctor();

    case symbolTag$2:
      return cloneSymbol(object);
  }
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}

/** `Object#toString` result references. */

var mapTag$3 = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$3;
}

/* Node.js helper references. */

var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;

/** `Object#toString` result references. */

var setTag$3 = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$3;
}

/* Node.js helper references. */

var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;

/** Used to compose bitmasks for cloning. */

var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$1 = 4;
/** `Object#toString` result references. */

var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag$2 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag$2 = '[object Map]',
    numberTag$2 = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$2 = '[object String]',
    symbolTag$1 = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$2] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$2] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray$1(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet$1(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/** Used to compose bitmasks for cloning. */

var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */

function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */

function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag$1 = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }

      return true;

    case boolTag$1:
    case dateTag:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag$1:
      var convert = mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1;
/** Used for built-in method references. */

var objectProto$2 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object),
      othIsArr = isArray$1(other),
      objTag = objIsArr ? arrayTag : getTag$1(object),
      othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$1.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */

var baseFor = createBaseFor();
var baseFor$1 = baseFor;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now$1 = function () {
  return root$1.Date.now();
};

var now$2 = now$1;

/** Error message constants. */

var FUNC_ERROR_TEXT$1 = 'Expected a function';
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */

function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now$2();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now$2());
  }

  function debounced() {
    var time = now$2(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignMergeValue(object, key, value) {
  if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */

function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */

function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }

  var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray$1(srcValue),
        isBuff = !isArr && isBuffer$1(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;

    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;

      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }

  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }

  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */

function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }

  baseFor$1(source, function (srcValue, key) {
    stack || (stack = new Stack());

    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }

      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method is like `_.merge` except that it accepts `customizer` which
 * is invoked to produce the merged values of the destination and source
 * properties. If `customizer` returns `undefined`, merging is handled by the
 * method instead. The `customizer` is invoked with six arguments:
 * (objValue, srcValue, key, object, source, stack).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   if (_.isArray(objValue)) {
 *     return objValue.concat(srcValue);
 *   }
 * }
 *
 * var object = { 'a': [1], 'b': [2] };
 * var other = { 'a': [3], 'b': [4] };
 *
 * _.mergeWith(object, other, customizer);
 * // => { 'a': [1, 3], 'b': [2, 4] }
 */

var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
  baseMerge(object, source, srcIndex, customizer);
});
var mergeWith$1 = mergeWith;

/** `Object#toString` result references. */

var stringTag = '[object String]';
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */

function isString$1(value) {
  return typeof value == 'string' || !isArray$1(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}

/** `Object#toString` result references. */

var boolTag = '[object Boolean]';
/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */

function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
}

/** `Object#toString` result references. */

var mapTag = '[object Map]',
    setTag = '[object Set]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */

function isEmpty(value) {
  if (value == null) {
    return true;
  }

  if (isArrayLike(value) && (isArray$1(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer$1(value) || isTypedArray$1(value) || isArguments$1(value))) {
    return !value.length;
  }

  var tag = getTag$1(value);

  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }

  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }

  return true;
}

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */

function isEqual(value, other) {
  return baseIsEqual(value, other);
}

/** `Object#toString` result references. */

var numberTag = '[object Number]';
/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */

function isNumber(value) {
  return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
}

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

/**
 * Checks if `value` is `null`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
 * @example
 *
 * _.isNull(null);
 * // => true
 *
 * _.isNull(void 0);
 * // => false
 */
function isNull(value) {
  return value === null;
}

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */

var kebabCase = createCompounder(function (result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});
var kebabCase$1 = kebabCase;

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */

function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }

  path = castPath(path, object);
  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;

      if (newValue === undefined) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
      }
    }

    assignValue(nested, key, newValue);
    nested = nested[key];
  }

  return object;
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */

function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */

function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

const noop$1 = () => {};
const noopInNoop = () => noop$1;
const defaultContainer = () => document.body;
const hasOwn = (val, key) => Object.hasOwnProperty.call(val, key);
const addUnit = val => {
  if (isNumber(val)) {
    return `${val}px`;
  }

  if (isString$1(val)) return val;
  return null;
};
const requestAnimationFrame$1 = (() => {
  const hackRAF = function (func) {
    return setTimeout(() => {
      func && func();
    }, 10);
  };

  if (typeof window !== 'undefined') {
    return window.requestAnimationFrame || hackRAF;
  }

  return hackRAF;
})();
const extractPropsDefaultValue = props => {
  const defaultValue = {};
  Object.keys(props).forEach(key => {
    if (props[key].default) {
      defaultValue[key] = props[key].default;
    }
  });
  return defaultValue;
}; // 10px => 10

const depx = value => {
  if (isString$1(value)) {
    if (value.endsWith('px')) {
      return Number(value.slice(0, value.length - 2));
    }

    return Number(value);
  }

  return value;
}; // 10 => 10px

const pxfy = value => {
  if (isUndefined(value) || isNull(value)) return undefined;
  if (isNumber(value)) return `${value}px`;
  if (value.endsWith('px')) return value;
  return `${value}px`;
};
function getParentNode$1(node) {
  // document type
  if (node.nodeType === 9) {
    return null;
  }

  return node.parentNode;
}
function getScrollParent(node) {
  if (node == null) return null;
  const parentNode = getParentNode$1(node);

  if (parentNode === null) {
    return null;
  } // Document


  if (parentNode.nodeType === 9) {
    return document;
  } // Element


  if (parentNode.nodeType === 1) {
    // Firefox want us to check `-x` and `-y` variations as well
    const {
      overflow,
      overflowX,
      overflowY
    } = getComputedStyle(parentNode);

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return parentNode;
    }
  }

  return getScrollParent(parentNode);
} // Array.concat

function concat(arr, arr2) {
  const arrLength = arr.length;
  const arr2Length = arr2.length;
  arr.length = arrLength + arr2Length;

  for (let i = 0; i < arr2Length; i++) {
    arr[arrLength + i] = arr2[i];
  }

  return arr;
}

function withInstall(main, extra, directives) {
  const _main = main;

  _main.install = app => {
    for (const comp of [main, ...Object.values(extra !== null && extra !== void 0 ? extra : {})]) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      app.component(comp.name, comp);
    }

    if (directives) {
      for (const directive of directives) {
        app.directive(directive.name, directive);
      }
    }
  };

  if (extra) {
    for (const [key, comp] of Object.entries(extra)) {
      _main[key] = comp;
    }
  }

  return _main;
}
function withNoopInstall(component) {
  const _main = component;
  _main.install = noop$1;
  return _main;
}

const prefixCls$18 = 'fes';
function getPrefixCls(suffixCls) {
  return suffixCls ? `${prefixCls$18}-${suffixCls}` : prefixCls$18;
}

const prefixCls$17 = 'fes-design-icon';
const iconProps = {
  spin: Boolean,
  rotate: String,
  tabIndex: Number
};
var IconWrapper = defineComponent({
  name: 'FIconWrapper',
  props: iconProps,

  setup(props, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const iconTabIndex = computed(() => {
      let tabIndex = props.tabIndex;

      if (tabIndex == null && attrs.onClick) {
        tabIndex = -1;
      }

      return tabIndex;
    });
    const svgStyle = computed(() => props.rotate ? {
      transform: `rotate(${props.rotate}deg)`
    } : null);
    const svgClasses = computed(() => ({
      [prefixCls$17]: true,
      [`${prefixCls$17}--spin`]: !!props.spin
    }));
    return () => createVNode("span", {
      "tabindex": iconTabIndex.value,
      "role": "img",
      "class": svgClasses.value,
      "style": svgStyle.value,
      "onClick": attrs.onClick || noop$1
    }, [slots.default && slots.default()]);
  }

});

function styleInject(css, ref) {
  if (ref === void 0) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') {
    return;
  }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".fes-design-icon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  outline: none;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.fes-design-icon > * {\n  line-height: 1;\n}\n.fes-design-icon svg {\n  display: inline-block;\n  width: 1em;\n  height: 1em;\n  fill: currentColor;\n}\n.fes-design-icon[tabindex] {\n  cursor: pointer;\n}\n.fes-design-icon--spin {\n  display: inline-block;\n  animation: loadingCircle 1.6s infinite linear;\n}\n@keyframes loadingCircle {\n  100% {\n    transform: rotate(360deg);\n  }\n}\n";
styleInject(css_248z);

var CloseCircleOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 42.667C771.2 42.667 981.333 252.8 981.333 512S771.2 981.333 512 981.333 42.667 771.2 42.667 512 252.8 42.667 512 42.667zm0 64a405.333 405.333 0 1 0 0 810.666 405.333 405.333 0 0 0 0-810.666zm140.288 243.925 21.12 21.12a17.067 17.067 0 0 1 0 24.15L557.269 512l116.139 116.139a17.067 17.067 0 0 1 0 24.149l-21.12 21.12a17.067 17.067 0 0 1-24.15 0L512 557.269 395.861 673.408a17.067 17.067 0 0 1-24.149 0l-21.12-21.12a17.067 17.067 0 0 1 0-24.15L466.731 512 350.592 395.861a17.067 17.067 0 0 1 0-24.149l21.12-21.12a17.067 17.067 0 0 1 24.15 0L512 466.731l116.139-116.139a17.067 17.067 0 0 1 24.149 0z"
  }, null)])]
}));

const UPDATE_MODEL_EVENT$1 = 'update:modelValue';
const CHANGE_EVENT$1 = 'change';
const CLOSE_EVENT = 'close';
const OK_EVENT$2 = 'ok';
const CANCEL_EVENT$2 = 'cancel';
const ERROR_EVENT = 'error';
const LOAD_EVENT = 'load';
const TABS_INJECTION_KEY = Symbol('tabs');
const FORM_ITEM_INJECTION_KEY = Symbol('FFormItemKey');
const TO_TOP_EVENT = 'toTop';
const TO_BOTTOM_EVENT = 'toBottom';
const RESIZED_EVENT = 'resized';

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var CaretDownOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M738.816 413.141A17.067 17.067 0 0 0 726.741 384H297.173a17.067 17.067 0 0 0-12.074 29.141l214.528 214.784a17.067 17.067 0 0 0 21.461 2.219l2.688-2.219 215.04-214.784z"
  }, null)])]
}));

var CheckCircleFilled = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 42.667C771.2 42.667 981.333 252.8 981.333 512S771.2 981.333 512 981.333 42.667 771.2 42.667 512 252.8 42.667 512 42.667zm180.821 265.472a21.333 21.333 0 0 0-26.709 5.845l-220.16 283.733-88.064-113.493a21.333 21.333 0 0 0-29.91-3.755l-16.853 13.056a21.333 21.333 0 0 0-3.84 29.952l121.771 156.928a21.333 21.333 0 0 0 33.707 0l253.909-327.168a21.333 21.333 0 0 0-3.755-29.952l-16.853-13.056z"
  }, null)])]
}));

var CheckOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "m685.312 445.568-253.91 327.168a21.333 21.333 0 0 1-33.706 0L275.968 615.808a21.333 21.333 0 0 1 3.797-29.91L296.62 572.8a21.333 21.333 0 0 1 29.909 3.797l88.064 113.494 220.16-283.734a21.333 21.333 0 0 1 29.952-3.797l16.853 13.099a21.333 21.333 0 0 1 3.755 29.909zm158.72-204.757L431.445 772.65a21.333 21.333 0 0 1-33.706-.128L152.02 452.437a21.333 21.333 0 0 1 3.84-29.866l16.854-13.014a21.333 21.333 0 0 1 30.037 3.84l211.84 276.651L793.472 201.6a21.333 21.333 0 0 1 29.952-3.797l16.853 13.098a21.333 21.333 0 0 1 3.755 29.91z"
  }, null)])]
}));

var ClockCircleOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 42.667C771.2 42.667 981.333 252.8 981.333 512S771.2 981.333 512 981.333 42.667 771.2 42.667 512 252.8 42.667 512 42.667zm0 64a405.333 405.333 0 1 0 0 810.666 405.333 405.333 0 0 0 0-810.666zM490.667 256.17A21.333 21.333 0 0 1 512 277.504l-.043 234.453 170.795.043a21.333 21.333 0 0 1 21.333 21.333v21.334A21.333 21.333 0 0 1 682.752 576H469.333A21.333 21.333 0 0 1 448 554.667V277.504a21.333 21.333 0 0 1 21.333-21.333h21.334z"
  }, null)])]
}));

var CloseCircleFilled = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 42.667C771.2 42.667 981.333 252.8 981.333 512S771.2 981.333 512 981.333 42.667 771.2 42.667 512 252.8 42.667 512 42.667zm140.288 307.925a17.067 17.067 0 0 0-24.15 0L512 466.731 395.861 350.592a17.067 17.067 0 0 0-24.149 0l-21.12 21.12a17.067 17.067 0 0 0 0 24.15L466.731 512 350.592 628.139a17.067 17.067 0 0 0 0 24.149l21.12 21.12a17.067 17.067 0 0 0 24.15 0L512 557.227l116.139 116.181a17.067 17.067 0 0 0 24.149 0l21.12-21.12a17.067 17.067 0 0 0 0-24.15L557.227 512l116.181-116.139a17.067 17.067 0 0 0 0-24.149z"
  }, null)])]
}));

var CloseOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M217.856 172.587 512 466.73l294.144-294.144a21.333 21.333 0 0 1 30.165 0l15.104 15.104a21.333 21.333 0 0 1 0 30.165L557.27 512l294.144 294.144a21.333 21.333 0 0 1 0 30.165l-15.104 15.104a21.333 21.333 0 0 1-30.165 0L512 557.27 217.856 851.413a21.333 21.333 0 0 1-30.165 0l-15.104-15.104a21.333 21.333 0 0 1 0-30.165L466.73 512 172.587 217.856a21.333 21.333 0 0 1 0-30.165l15.104-15.104a21.333 21.333 0 0 1 30.165 0z"
  }, null)])]
}));

var DateOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M349.44 96a21.333 21.333 0 0 1 21.333 21.333l-.085 54.358h282.539v-54.358A21.333 21.333 0 0 1 674.56 96h21.333a21.333 21.333 0 0 1 21.334 21.333v54.315h189.397a21.333 21.333 0 0 1 21.333 21.333v713.6a21.333 21.333 0 0 1-21.333 21.334h-789.29A21.333 21.333 0 0 1 96 906.58V193.024a21.333 21.333 0 0 1 21.333-21.333h189.312l.128-54.358A21.333 21.333 0 0 1 328.107 96h21.333zm514.432 330.667h-703.83v437.29h703.873V426.624zM349.44 682.453a21.333 21.333 0 0 1 21.333 21.334v21.333a21.333 21.333 0 0 1-21.333 21.333h-85.333a21.333 21.333 0 0 1-21.334-21.333v-21.333a21.333 21.333 0 0 1 21.334-21.334h85.333zm205.227 0A21.333 21.333 0 0 1 576 703.787v21.333a21.333 21.333 0 0 1-21.333 21.333h-85.334A21.333 21.333 0 0 1 448 725.12v-21.333a21.333 21.333 0 0 1 21.333-21.334h85.334zm205.226 0a21.333 21.333 0 0 1 21.334 21.334v21.333a21.333 21.333 0 0 1-21.334 21.333H674.56a21.333 21.333 0 0 1-21.333-21.333v-21.333a21.333 21.333 0 0 1 21.333-21.334h85.333zm-410.453-137.6a21.333 21.333 0 0 1 21.333 21.334v21.333a21.333 21.333 0 0 1-21.333 21.333h-85.333a21.333 21.333 0 0 1-21.334-21.333v-21.333a21.333 21.333 0 0 1 21.334-21.334h85.333zm205.27 0a21.333 21.333 0 0 1 21.333 21.334v21.333a21.333 21.333 0 0 1-21.334 21.333h-85.333a21.333 21.333 0 0 1-21.333-21.333v-21.333a21.333 21.333 0 0 1 21.333-21.334h85.333zm205.226 0a21.333 21.333 0 0 1 21.333 21.334v21.333a21.333 21.333 0 0 1-21.333 21.333h-85.333a21.333 21.333 0 0 1-21.334-21.333v-21.333a21.333 21.333 0 0 1 21.334-21.334h85.333zm104.021-309.12H160.043v126.934h703.872V235.69z"
  }, null)])]
}));

var DoubleLeftOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M542.25 209.493 239.745 512l302.507 302.507a21.333 21.333 0 0 1 0 30.208l-15.104 15.061a21.333 21.333 0 0 1-30.166 0L164.267 527.104a21.333 21.333 0 0 1 0-30.208L496.98 164.224a21.333 21.333 0 0 1 30.166 0l15.104 15.061a21.333 21.333 0 0 1 0 30.166zm317.44 0L557.228 512l302.506 302.507a21.333 21.333 0 0 1 0 30.208l-15.061 15.061a21.333 21.333 0 0 1-30.165 0L481.792 527.104a21.333 21.333 0 0 1 0-30.208l332.715-332.63a21.333 21.333 0 0 1 30.165 0l15.104 15.062a21.333 21.333 0 0 1 0 30.165z"
  }, null)])]
}));

var DoubleRightOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M496.853 164.224a21.333 21.333 0 0 1 27.222-2.475l2.944 2.475 332.714 332.672a21.333 21.333 0 0 1 2.432 27.221l-2.432 2.987L527.02 859.776a21.333 21.333 0 0 1-27.222 2.475l-2.986-2.475-15.062-15.061a21.333 21.333 0 0 1-2.474-27.222l2.474-2.986L784.256 512 481.749 209.493a21.333 21.333 0 0 1-2.474-27.221l2.474-2.987 15.104-15.061zm-317.482 0a21.333 21.333 0 0 1 27.221-2.475l2.944 2.475 332.715 332.672a21.333 21.333 0 0 1 2.474 27.221l-2.474 2.987-332.758 332.63a21.333 21.333 0 0 1-27.221 2.474l-2.987-2.475-15.061-15.061a21.333 21.333 0 0 1-2.432-27.221l2.432-2.987L466.774 512 164.266 209.493a21.333 21.333 0 0 1-2.432-27.221l2.432-2.987 15.104-15.061z"
  }, null)])]
}));

var DownOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "m158.464 314.581 336.64 434.048a21.333 21.333 0 0 0 33.75 0l336.682-434.048a21.333 21.333 0 0 0-3.755-29.952l-16.896-13.056a21.333 21.333 0 0 0-27.306.939l-2.603 2.859L512 665.984 209.067 275.371a21.333 21.333 0 0 0-26.71-5.888l-3.242 2.09-16.896 13.056a21.333 21.333 0 0 0-3.755 29.952z"
  }, null)])]
}));

var DownloadOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "m527.104 731.307 233.813-233.814a21.333 21.333 0 0 0 0-30.208l-15.104-15.061a21.333 21.333 0 0 0-27.221-2.475l-2.944 2.475L544 623.914V117.12a21.333 21.333 0 0 0-21.333-21.333h-21.334A21.333 21.333 0 0 0 480 117.12v506.795L308.352 452.224a21.333 21.333 0 0 0-30.165 0l-15.104 15.061a21.333 21.333 0 0 0 0 30.166l233.813 233.813a21.333 21.333 0 0 0 30.208 0zm379.435 196.906a21.333 21.333 0 0 0 20.992-17.493l.341-3.84V645.12a21.333 21.333 0 0 0-17.493-20.992l-3.84-.341h-21.334a21.333 21.333 0 0 0-20.992 17.493l-.341 3.84v219.093H161.28V645.12a21.333 21.333 0 0 0-17.493-20.992l-3.84-.341H117.76a21.333 21.333 0 0 0-20.992 17.493l-.341 3.84v261.76a21.333 21.333 0 0 0 17.493 20.992l3.84.341h788.779z"
  }, null)])]
}));

var ExclamationCircleFilled = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 42.667C771.2 42.667 981.333 252.8 981.333 512S771.2 981.333 512 981.333 42.667 771.2 42.667 512 252.8 42.667 512 42.667zm0 626.474a42.667 42.667 0 1 0 0 85.334 42.667 42.667 0 0 0 0-85.334zm10.667-417.365h-21.334A21.333 21.333 0 0 0 480 273.109v311.979a21.333 21.333 0 0 0 21.333 21.333h21.334A21.333 21.333 0 0 0 544 585.088V273.067a21.333 21.333 0 0 0-21.333-21.334z"
  }, null)])]
}));

var EyeInvisibleOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 149.461c86.613 0 166.528 25.771 239.915 77.312l52.053-52.053a21.333 21.333 0 0 1 30.208 0l15.061 15.104a21.333 21.333 0 0 1 0 30.165l-47.104 47.104c45.398 41.088 88.022 92.928 127.915 155.52l12.715 20.566 7.765 13.269 19.541 34.901 5.718 10.496a21.333 21.333 0 0 1 0 20.395l-16.214 29.44-13.226 23.04-7.168 11.947C821.419 778.155 678.997 873.899 512 873.899c-86.443 0-166.315-25.643-239.616-76.971l-52.395 52.352a21.333 21.333 0 0 1-30.165 0l-15.061-15.061a21.333 21.333 0 0 1 0-30.166l47.36-47.36C173.653 712.96 128.299 656.981 86.1 588.8l-10.154-17.067-17.408-30.72L48.17 522.24a21.333 21.333 0 0 1 0-20.48l19.2-34.645 11.52-20.139 6.4-10.581C202.965 245.077 345.216 149.46 511.957 149.46zm244.907 162.902L318.464 750.805c57.003 37.547 117.76 56.875 182.357 58.88l11.136.171c148.992 0 277.632-91.008 387.67-281.899l9.002-16-.426-.768c-46.934-84.65-97.366-150.698-151.382-198.826zM512 213.46c-148.992 0-277.59 91.179-387.627 282.454l-9.088 16.042.427.726c47.019 84.65 97.536 150.613 151.637 198.698l103.467-103.466a170.667 170.667 0 0 1 237.099-237.099l97.962-97.92c-57.13-37.76-117.973-57.259-182.741-59.307L512 213.504zM672.853 454.87a170.667 170.667 0 0 1-218.026 218.027l54.272-54.272 2.901.043A106.667 106.667 0 0 0 618.667 512l-.086-2.901 54.272-54.23zM512 405.333a106.667 106.667 0 0 0-94.592 155.99l143.915-143.915A106.24 106.24 0 0 0 512 405.333z"
  }, null)])]
}));

var EyeOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 149.461c162.688 0 302.08 91.051 418.048 273.11l12.715 20.565 12.16 20.95 15.146 27.22 5.718 10.497a21.333 21.333 0 0 1 0 20.394l-16.214 29.44-13.226 23.04-7.168 11.947C821.419 778.112 678.997 873.856 512 873.856c-166.4 0-308.31-95.019-425.813-285.056l-10.24-17.067-17.366-30.72-10.368-18.773a21.333 21.333 0 0 1 0-20.48l19.2-34.645 11.52-20.139 6.4-10.581C203.008 245.077 345.26 149.46 512 149.46zm0 64c-148.992 0-277.59 91.179-387.627 282.454l-9.088 16.042.427.726c109.184 196.394 236.97 292.437 385.152 297.002l11.136.171c148.992 0 277.632-91.008 387.67-281.899l9.002-16-.427-.768c-109.184-196.778-236.97-292.992-385.109-297.557l-11.136-.17zm0 127.872a170.667 170.667 0 1 1 0 341.334 170.667 170.667 0 0 1 0-341.334zm0 64a106.667 106.667 0 1 0 0 213.334 106.667 106.667 0 0 0 0-213.334z"
  }, null)])]
}));

var FileOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg",
    "width": "200",
    "height": "200"
  }, [createVNode("path", {
    "d": "M853.248 981.333A21.333 21.333 0 0 0 874.581 960V64a21.333 21.333 0 0 0-21.333-21.333H170.752A21.333 21.333 0 0 0 149.419 64v896a21.333 21.333 0 0 0 21.333 21.333h682.496zm-42.71-63.957h-597.12v-810.71h597.12v810.71zM682.668 405.333A21.333 21.333 0 0 0 704 384v-21.333a21.333 21.333 0 0 0-21.333-21.334H341.333A21.333 21.333 0 0 0 320 362.667V384a21.333 21.333 0 0 0 21.333 21.333h341.334zm0 138.667A21.333 21.333 0 0 0 704 522.667v-21.334A21.333 21.333 0 0 0 682.667 480H341.333A21.333 21.333 0 0 0 320 501.333v21.334A21.333 21.333 0 0 0 341.333 544h341.334zM512 682.667a21.333 21.333 0 0 0 21.333-21.334V640A21.333 21.333 0 0 0 512 618.667H341.333A21.333 21.333 0 0 0 320 640v21.333a21.333 21.333 0 0 0 21.333 21.334H512z"
  }, null)])]
}));

var InfoCircleFilled = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 981.333C252.8 981.333 42.667 771.2 42.667 512S252.8 42.667 512 42.667 981.333 252.8 981.333 512 771.2 981.333 512 981.333zm0-626.474a42.667 42.667 0 1 0 0-85.334 42.667 42.667 0 0 0 0 85.334zm-10.667 417.365h21.334a21.333 21.333 0 0 0 20.992-17.493l.341-3.84V438.912a21.333 21.333 0 0 0-17.493-20.992l-3.84-.341h-21.334a21.333 21.333 0 0 0-20.992 17.493l-.341 3.84v312.021a21.333 21.333 0 0 0 17.493 20.992l3.84.342z"
  }, null)])]
}));

var LeftOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M709.419 865.536 275.37 528.896a21.333 21.333 0 0 1 0-33.75l434.048-336.682a21.333 21.333 0 0 1 29.952 3.755l13.056 16.896a21.333 21.333 0 0 1-.939 27.306l-2.859 2.603L358.016 512l390.613 302.933a21.333 21.333 0 0 1 5.888 26.71l-2.09 3.242-13.056 16.896a21.333 21.333 0 0 1-29.952 3.755z"
  }, null)])]
}));

var LoadingOutlined = (props => createVNode(IconWrapper, mergeProps(props, {
  "spin": true
}), {
  default: () => [createVNode("svg", {
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg",
    "width": "200",
    "height": "200"
  }, [createVNode("path", {
    "d": "M512 42.453q42.667 0 42.667 42.667v128q0 42.667-42.667 42.667t-42.667-42.667v-128q0-42.667 42.667-42.667Z",
    "fill-opacity": ".7"
  }, null), createVNode("path", {
    "d": "M512 768.213q42.667 0 42.667 42.667v128q0 42.667-42.667 42.667t-42.667-42.667v-128q0-42.667 42.667-42.667Z",
    "fill-opacity": ".2"
  }, null), createVNode("path", {
    "d": "M42.667 511.787q0-42.667 42.666-42.667h128q42.667 0 42.667 42.667 0 42.666-42.667 42.666h-128q-42.666 0-42.666-42.666Z",
    "fill-opacity": ".4"
  }, null), createVNode("path", {
    "d": "M768 511.787q0-42.667 42.667-42.667h128q42.666 0 42.666 42.667 0 42.666-42.666 42.666h-128q-42.667 0-42.667-42.666Z"
  }, null), createVNode("path", {
    "d": "M179.978 179.978q30.17-30.17 60.34 0l90.51 90.51q30.17 30.17 0 60.34t-60.34 0l-90.51-90.51q-30.17-30.17 0-60.34Z",
    "fill-opacity": ".55"
  }, null), createVNode("path", {
    "d": "M693.173 693.172q30.17-30.17 60.34 0l90.51 90.51q30.169 30.17 0 60.34-30.17 30.17-60.34 0l-90.51-90.51q-30.17-30.17 0-60.34Z",
    "fill-opacity": ".1"
  }, null), createVNode("path", {
    "d": "M179.978 843.723q-30.17-30.17 0-60.34l90.51-90.51q30.17-30.169 60.34 0 30.17 30.17 0 60.34l-90.51 90.51q-30.17 30.17-60.34 0Z",
    "fill-opacity": ".3"
  }, null), createVNode("path", {
    "d": "M692.874 330.827q-30.17-30.17 0-60.34l90.51-90.51q30.17-30.169 60.34 0 30.17 30.17 0 60.34l-90.51 90.51q-30.17 30.17-60.34 0Z",
    "fill-opacity": ".85"
  }, null)])]
}));

var MoreOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M756.224 512a55.979 55.979 0 1 1 112 0 55.979 55.979 0 0 1-112 0zm-300.245 0a56.021 56.021 0 1 1 112.042 0 56.021 56.021 0 0 1-112.042 0zm-300.203 0a56.021 56.021 0 1 1 112 0 56.021 56.021 0 0 1-112 0z"
  }, null)])]
}));

var PictureFailOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "m496.64 88.619 465.365 52.309a21.333 21.333 0 0 1 18.859 23.04L915.797 907.52a21.333 21.333 0 0 1-23.125 19.413l-470.4-41.173a21.333 21.333 0 0 1-19.285-18.56l-20.139-158.165.17-.427 21.163-233.941-165.12-182.528a21.333 21.333 0 0 1-4.266-21.547l38.784-107.605-162.091 19.968 45.739 522.922 163.072-25.472a21.333 21.333 0 0 1 23.466 14.038l1.024 4.565 2.432 21.163a21.333 21.333 0 0 1-17.92 23.552l-166.485 26.026 8.107 92.8 175.232-30.634a21.333 21.333 0 0 1 23.722 13.653l1.152 4.779 2.56 20.864a21.333 21.333 0 0 1-17.749 23.68L135.68 930.56a21.333 21.333 0 0 1-24.49-17.621L44.202 147.584a21.333 21.333 0 0 1 18.602-23.04l278.187-34.261a21.333 21.333 0 0 1 22.57 28.757l-51.37 135.253L472.362 435.2a21.333 21.333 0 0 1 5.206 16.683l-12.587 105.301 87.382-161.493-140.374-146.603a21.333 21.333 0 0 1-3.37-24.875l66.816-124.458a21.333 21.333 0 0 1 21.162-11.094zM453.035 751.7l7.594 73.174 395.094 34.56 5.717-65.408L453.035 751.7zm65.578-597.248-37.632 70.4L629.973 379.52a21.333 21.333 0 0 1 3.2 25.301L472.62 689.451l394.41 40.874 46.294-528.938-394.667-46.976zM767.66 264.96a55.979 55.979 0 1 1 0 112 55.979 55.979 0 0 1 0-112z"
  }, null)])]
}));

var PictureOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M960 149.419a21.333 21.333 0 0 1 21.333 21.333v682.496A21.333 21.333 0 0 1 960 874.581H64a21.333 21.333 0 0 1-21.333-21.333V170.752A21.333 21.333 0 0 1 64 149.419h896zM670.464 475.86 438.869 748.245a21.333 21.333 0 0 1-32.682-.17l-140.075-168.96-159.488 187.861v43.563h810.71v-43.52L670.463 475.86zm246.87-262.4H106.666v454.571l143.616-169.088a21.333 21.333 0 0 1 32.682.213l139.99 168.918L654.25 396.16a21.333 21.333 0 0 1 32.512 0l230.57 271.83V213.418zM416 277.333a96 96 0 1 1 0 192 96 96 0 0 1 0-192zm0 64a32 32 0 1 0 0 64 32 32 0 0 0 0-64z"
  }, null)])]
}));

var PlusOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M544 117.333v362.624l362.667.043A21.333 21.333 0 0 1 928 501.333v21.334A21.333 21.333 0 0 1 906.667 544H544v362.667A21.333 21.333 0 0 1 522.667 928h-21.334A21.333 21.333 0 0 1 480 906.667V544H117.333A21.333 21.333 0 0 1 96 522.667v-21.334A21.333 21.333 0 0 1 117.333 480L480 479.957V117.333A21.333 21.333 0 0 1 501.333 96h21.334A21.333 21.333 0 0 1 544 117.333z"
  }, null)])]
}));

var ReloadOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 95.915a414.848 414.848 0 0 1 297.472 125.141V117.461a21.333 21.333 0 0 1 21.333-21.333h21.334a21.333 21.333 0 0 1 21.333 21.333v214.614a21.333 21.333 0 0 1-21.333 21.333H637.525a21.333 21.333 0 0 1-21.333-21.333V310.74a21.333 21.333 0 0 1 21.333-21.333h147.286A352.085 352.085 0 1 0 864.128 512l-.47-14.464-.34-5.845a21.333 21.333 0 0 1 16.085-22.102l4.48-.597h22.101a21.333 21.333 0 0 1 21.333 20.053l.726 18.176.042 4.779c0 229.803-186.282 416.085-416.085 416.085-229.803 0-416.085-186.282-416.085-416.085C95.915 282.197 282.197 95.915 512 95.915z"
  }, null)])]
}));

var RightOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "m314.581 865.536 434.048-336.64a21.333 21.333 0 0 0 0-33.75L314.581 158.465a21.333 21.333 0 0 0-29.952 3.755l-13.056 16.896a21.333 21.333 0 0 0 .939 27.306l2.859 2.603L665.984 512 275.371 814.933a21.333 21.333 0 0 0-5.888 26.71l2.09 3.242 13.056 16.896a21.333 21.333 0 0 0 29.952 3.755z"
  }, null)])]
}));

var RotateLeftOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M512 95.915a414.848 414.848 0 0 0-297.472 125.098V117.461a21.333 21.333 0 0 0-21.333-21.333H171.86a21.333 21.333 0 0 0-21.333 21.333v214.614a21.333 21.333 0 0 0 21.333 21.333h214.614a21.333 21.333 0 0 0 21.333-21.333V310.74a21.333 21.333 0 0 0-21.333-21.333H239.189A352.085 352.085 0 1 1 159.872 512l.47-14.464.34-5.845a21.333 21.333 0 0 0-16.085-22.102l-4.48-.597h-22.101a21.333 21.333 0 0 0-21.333 20.053l-.726 18.176-.042 4.779c0 229.803 186.282 416.085 416.085 416.085 229.803 0 416.085-186.282 416.085-416.085 0-229.803-186.282-416.085-416.085-416.085z"
  }, null)])]
}));

var SearchMinusOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M480.384 100.95a379.819 379.819 0 0 1 290.219 624.895L915.84 871.083a21.333 21.333 0 0 1 0 30.165l-15.104 15.061a21.333 21.333 0 0 1-30.165 0L725.333 771.072a379.819 379.819 0 1 1-244.992-670.123zm0 64a315.819 315.819 0 1 0 0 631.68 315.819 315.819 0 0 0 0-631.68zm128 283.818a21.333 21.333 0 0 1 21.333 21.333v21.334a21.333 21.333 0 0 1-21.333 21.333h-256a21.333 21.333 0 0 1-21.333-21.333V470.1a21.333 21.333 0 0 1 21.333-21.333h256z"
  }, null)])]
}));

var SearchPlusOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M480.384 100.95a379.819 379.819 0 0 1 290.219 624.895L915.84 871.083a21.333 21.333 0 0 1 0 30.165l-15.104 15.061a21.333 21.333 0 0 1-30.165 0L725.333 771.072a379.819 379.819 0 1 1-244.992-670.123zm0 64a315.819 315.819 0 1 0 0 631.68 315.819 315.819 0 0 0 0-631.68zm10.667 166.485a21.333 21.333 0 0 1 21.333 21.333v96h96a21.333 21.333 0 0 1 21.333 21.333v21.334a21.333 21.333 0 0 1-21.333 21.333h-96v96a21.333 21.333 0 0 1-21.333 21.333h-21.334a21.333 21.333 0 0 1-21.333-21.333v-96h-96a21.333 21.333 0 0 1-21.333-21.333V470.1a21.333 21.333 0 0 1 21.333-21.333h96v-96a21.333 21.333 0 0 1 21.333-21.333h21.334z"
  }, null)])]
}));

var SwapRightOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg",
    "width": "200",
    "height": "200"
  }, [createVNode("path", {
    "d": "m704.384 401.493 16.853-13.013a21.333 21.333 0 0 1 29.952 3.797l162.219 209.28a21.333 21.333 0 0 1-16.853 34.39H106.667a21.333 21.333 0 0 1-21.334-21.334V593.28a21.333 21.333 0 0 1 21.334-21.333H809.6L700.587 431.445a21.333 21.333 0 0 1 .938-27.306l2.859-2.603z"
  }, null)])]
}));

var UpOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "m158.464 709.419 336.64-434.048a21.333 21.333 0 0 1 33.75 0l336.682 434.048a21.333 21.333 0 0 1-3.755 29.952l-16.896 13.056a21.333 21.333 0 0 1-27.306-.939l-2.603-2.859L512 358.016 209.067 748.629a21.333 21.333 0 0 1-26.71 5.888l-3.242-2.09-16.896-13.056a21.333 21.333 0 0 1-3.755-29.952z"
  }, null)])]
}));

var UploadOutlined = (props => createVNode(IconWrapper, props, {
  default: () => [createVNode("svg", {
    "width": "200",
    "height": "200",
    "viewBox": "0 0 1024 1024",
    "xmlns": "http://www.w3.org/2000/svg"
  }, [createVNode("path", {
    "d": "M139.947 623.957a21.333 21.333 0 0 1 21.333 21.334v219.136h702.592V645.29a21.333 21.333 0 0 1 21.333-21.334h21.334a21.333 21.333 0 0 1 21.333 21.334v261.802a21.333 21.333 0 0 1-21.333 21.334H117.76a21.333 21.333 0 0 1-21.333-21.334V645.291a21.333 21.333 0 0 1 21.333-21.334h22.187zm387.157-512.853 233.813 233.813a21.333 21.333 0 0 1 0 30.166l-15.104 15.061a21.333 21.333 0 0 1-27.221 2.475l-2.944-2.475L544 218.454v506.794a21.333 21.333 0 0 1-21.333 21.333h-21.334A21.333 21.333 0 0 1 480 725.248V218.453L308.352 390.144a21.333 21.333 0 0 1-30.165 0l-15.104-15.061a21.333 21.333 0 0 1 0-30.166l233.813-233.813a21.333 21.333 0 0 1 30.208 0z"
  }, null)])]
}));

var _a;
const isClient = typeof window !== "undefined";
const isString = (val) => typeof val === "string";
const noop = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);

function resolveUnref(r) {
  return typeof r === "function" ? r() : unref(r);
}

function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
function throttleFilter(ms, trailing = true, leading = true) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
    }
  };
  const filter = (invoke) => {
    const duration = resolveUnref(ms);
    const elapsed = Date.now() - lastExec;
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke();
    } else if (trailing) {
      timer = setTimeout(() => {
        lastExec = Date.now();
        isLeading = true;
        clear();
        invoke();
      }, duration - elapsed);
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
  };
  return filter;
}
function identity(arg) {
  return arg;
}

function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}

function createSharedComposable(composable) {
  let subscribers = 0;
  let state;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!state) {
      scope = effectScope(true);
      state = scope.run(() => composable(...args));
    }
    tryOnScopeDispose(dispose);
    return state;
  };
}

function useThrottleFn(fn, ms = 200, trailing = false, leading = true) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);
}

function unrefElement(elRef) {
  var _a;
  const plain = resolveUnref(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}

const defaultWindow = isClient ? window : void 0;
isClient ? window.document : void 0;
isClient ? window.navigator : void 0;
isClient ? window.location : void 0;

function useEventListener(...args) {
  let target;
  let events;
  let listeners;
  let options;
  if (isString(args[0]) || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target = defaultWindow;
  } else {
    [target, events, listeners, options] = args;
  }
  if (!target)
    return noop;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    cleanups.push(...events.flatMap((event) => {
      return listeners.map((listener) => register(el, event, listener));
    }));
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}

const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
_global[globalKey];

var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
__spreadValues({
  linear: identity
}, _TransitionPresets);

const configProviderProps = {
  locale: Object,
  getContainer: {
    type: Function,
    default: defaultContainer
  },
  theme: String,
  themeOverrides: Object
};
const CONFIG_PROVIDER_INJECTION_KEY = Symbol('ConfigProvider');

function useConfig() {
  // vue
  const vm = getCurrentInstance();

  if (!vm) {
    return {};
  }

  const providerConfig = inject(CONFIG_PROVIDER_INJECTION_KEY, {
    getContainer: ref(defaultContainer)
  });
  return providerConfig;
}
var ConfigProvider = defineComponent({
  name: 'FConfigProvider',
  props: configProviderProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    // 
    provide(CONFIG_PROVIDER_INJECTION_KEY, toRefs(props));
    return () => {
      var _slots$default;

      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }

});

const FConfigProvider = withInstall(ConfigProvider);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function clamp$1(v, max) {
  return Math.min(Math.max(v, 0), max);
}

function toHex(v) {
  return `#${v.map(c => {
    c = clamp$1(Math.round(c), 255);
    return (c < 16 ? '0' : '') + c.toString(16);
  }).join('')}`;
}

class Color {
  constructor(rgb, a, originalForm) {
    _defineProperty(this, "alpha", 0);

    _defineProperty(this, "value", '');

    if (Array.isArray(rgb)) {
      this.rgb = rgb;
    } else if (rgb.length >= 6) {
      this.rgb = []; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

      rgb.match(/.{2}/g).forEach((c, i) => {
        if (i < 3) {
          this.rgb.push(parseInt(c, 16));
        } else {
          this.alpha = parseInt(c, 16) / 255;
        }
      });
    } else {
      this.rgb = [];
      rgb.split('').forEach((c, i) => {
        if (i < 3) {
          this.rgb.push(parseInt(c + c, 16));
        } else {
          this.alpha = parseInt(c + c, 16) / 255;
        }
      });
    }

    this.alpha = this.alpha || (typeof a === 'number' ? a : 1);

    if (typeof originalForm !== 'undefined') {
      this.value = originalForm;
    }
  }

  toRGB() {
    return toHex(this.rgb);
  }

  toCSS(compress) {
    let color;
    let colorFunction = '';
    let args = []; // `value` is set if this color was originally
    // converted from a named color string so we need
    // to respect this and try to output named color too.

    const alpha = this.alpha;

    if (this.value) {
      if (this.value.indexOf('rgb') === 0) {
        if (alpha < 1) {
          colorFunction = 'rgba';
        }
      } else if (this.value.indexOf('hsl') === 0) {
        if (alpha < 1) {
          colorFunction = 'hsla';
        } else {
          colorFunction = 'hsl';
        }
      } else {
        return this.value;
      }
    } else {
      if (alpha < 1) {
        colorFunction = 'rgba';
      }
    } // eslint-disable-next-line default-case


    switch (colorFunction) {
      case 'rgba':
        args = this.rgb.map(c => clamp$1(Math.round(c), 255)).concat(clamp$1(alpha, 1));
        break;

      case 'hsla':
        args.push(clamp$1(alpha, 1));
    }

    if (colorFunction) {
      // Values are capped between `0` and `255`, rounded and zero-padded.
      return `${colorFunction}(${args.join(`,${compress ? '' : ' '}`)})`;
    }

    color = this.toRGB();

    if (compress) {
      const splitcolor = color.split(''); // Convert color to short format

      if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {
        color = `#${splitcolor[1]}${splitcolor[3]}${splitcolor[5]}`;
      }
    }

    return color;
  }

  toHex() {
    return toHex(this.rgb);
  }

  toHSL() {
    const r = this.rgb[0] / 255,
          g = this.rgb[1] / 255,
          b = this.rgb[2] / 255,
          a = this.alpha;
    const max = Math.max(r, g, b),
          min = Math.min(r, g, b);
    let h = 0;
    let s;
    const l = (max + min) / 2;
    const d = max - min;

    if (max === min) {
      h = s = 0;
    } else {
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min); // eslint-disable-next-line default-case

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h * 360,
      s,
      l,
      a
    };
  }

}

var Color$1 = Color;

function clamp(val) {
  return Math.min(1, Math.max(0, val));
}

function hsla(h, s, l, a) {
  // eslint-disable-next-line prefer-const
  let m1; // eslint-disable-next-line prefer-const

  let m2; // eslint-disable-next-line no-inner-declarations

  function hue(h) {
    h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;

    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }

    if (h * 2 < 1) {
      return m2;
    }

    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }

    return m1;
  }

  h = h % 360 / 360;
  s = clamp(s);
  l = clamp(l);
  a = clamp(a);
  m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  m1 = l * 2 - m2;
  const _rgb = [hue(h + 1 / 3) * 255, hue(h) * 255, hue(h - 1 / 3) * 255];
  return new Color$1(_rgb, a, 'hsla');
}

function _hsla(origColor, hsl) {
  const color = hsla(hsl.h, hsl.s, hsl.l, hsl.a);

  if (origColor.value && /^(rgb|hsl)/.test(origColor.value)) {
    color.value = origColor.value;
  } else {
    color.value = 'rgb';
  }

  return color;
}

function rgba(r, g, b, a) {
  if (r instanceof Color$1) {
    if (g) {
      a = g;
    } else {
      a = r.alpha;
    }

    return new Color$1(r.rgb, a, 'rgba');
  }

  const _rgb = [r, g, b];
  return new Color$1(_rgb, a, 'rgba');
}
function rgb(r, g, b) {
  const a = 1;
  const color = rgba(r, g, b, a);
  color.value = 'rgb';
  return color;
}

function toHSL(color) {
  if (color.toHSL) {
    return color.toHSL();
  }

  throw new Error('Argument cannot be evaluated to a color');
}

function mix(color1, color2, weight) {
  const p = weight;
  const w = p * 2 - 1;
  const a = toHSL(color1).a - toHSL(color2).a;
  const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
  const w2 = 1 - w1;
  const _rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2, color1.rgb[1] * w1 + color2.rgb[1] * w2, color1.rgb[2] * w1 + color2.rgb[2] * w2];
  const alpha = color1.alpha * p + color2.alpha * (1 - p);
  return new Color$1(_rgb, alpha).toHex();
}

function parseColor(color) {
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const _rgb = color.match(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/);

  return new Color$1(_rgb[1], undefined, color);
}

function fade(color, alpha) {
  const colorInstance = parseColor(color);
  const hsl = toHSL(colorInstance);
  hsl.a = alpha;
  hsl.a = clamp(hsl.a);
  return _hsla(colorInstance, hsl).toCSS();
}
function tint(color, amount) {
  const colorInstance = parseColor(color);
  return mix(rgb(255, 255, 255), colorInstance, amount);
}
function shade(color, amount) {
  const colorInstance = parseColor(color);
  return mix(rgb(0, 0, 0), colorInstance, amount);
}

function ownKeys$Q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$Q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$Q(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$Q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const fontColorBase = '#0f1222';
const themeCommon = {
  primaryColor: '#5384ff',
  successColor: '#00cb91',
  dangerColor: '#ff4d4f',
  warningColor: '#f29360',
  tipColor: '#5384ff',
  white: '#fff',
  black: '#000',
  bodyBgColor: '#fff',
  fontColorBase,
  fontSizeBase: '14px',
  borderRadiusBase: '4px',
  borderRadiusSm: '2px',
  borderWidthBase: '1px',
  borderStyleBase: 'solid',
  borderColorBase: tint(fontColorBase, 0.8),
  shadowColor: fade(fontColorBase, 0.1),
  shadowColorSm: fade(fontColorBase, 0.2),
  shadowRadius: '12px',
  shadowRadiusSm: '4px',
  maskColor: fade(fontColorBase, 0.45),
  maskDarkColor: fade(fontColorBase, 0.9),
  paddingLarge: '24px',
  paddingMiddle: '16px',
  paddingSmall: '12px',
  paddingXsmall: '8px'
};
const baseTheme = function () {
  let themeOverrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const base = Object.assign(themeCommon, themeOverrides.common);
  return _objectSpread$Q(_objectSpread$Q({}, base), {}, {
    linkColor: base.primaryColor,
    componentBgColor: tint(base.fontColorBase, 0.97),
    hoverColorBase: tint(base.primaryColor, 0.2),
    hoverColorLight: tint(base.primaryColor, 0.94),
    hoverSuccessColor: tint(base.successColor, 0.94),
    activeSuccessColor: shade(base.successColor, 0.06),
    hoverWarningColor: tint(base.warningColor, 0.94),
    activeWarningColor: shade(base.warningColor, 0.06),
    hoverDangerColor: tint(base.dangerColor, 0.94),
    activeDangerColor: shade(base.dangerColor, 0.06),
    activeColor: shade(base.primaryColor, 0.06),
    focusColor: base.primaryColor,
    focusShadowColor: tint(base.primaryColor, 0.8),
    focusDangerShadowColor: tint(base.dangerColor, 0.8),
    processingColor: tint(base.primaryColor, 0.4),
    disabledColorBase: tint(base.fontColorBase, 0.8),
    disabledColorLight: tint(base.fontColorBase, 0.97),
    headColor: base.fontColorBase,
    subHeadColor: tint(base.fontColorBase, 0.35),
    textColor: base.fontColorBase,
    textColorSecondary: tint(base.fontColorBase, 0.55),
    textColorDisabled: tint(base.fontColorBase, 0.7),
    textColorDisabledLight: tint(base.fontColorBase, 0.8),
    textColorCaption: tint(base.fontColorBase, 0.8),
    borderColorBase: tint(base.fontColorBase, 0.8),
    borderColorDisabled: tint(base.fontColorBase, 0.8),
    borderColorSplit: tint(base.fontColorBase, 0.94),
    borderColorInverse: base.white,
    borderBase: `${base.borderWidthBase} ${base.borderStyleBase} ${base.borderColorBase}`,
    layoutInvertedBgColor: tint(base.fontColorBase, 0.05),
    tooltipTextBgColor: tint(base.fontColorBase, 0.3),
    selectTriggerIconColor: tint(base.fontColorBase, 0.6),
    scrollbarBgColor: fade(base.fontColorBase, 0.25),
    scrollbarActiveColor: fade(base.fontColorBase, 0.65),
    carouselColor: base.shadowColorSm,
    carouselHoverColor: base.maskColor,
    carouselActiveColor: fade(base.fontColorBase, 0.65)
  });
};

const CSS_VAR_PREFIX = '--f-';
function applyTheme(container, theme, themeOverrides) {
  // TODO 
  const _theme = baseTheme(themeOverrides);

  const _container = container || document.body;

  Object.keys(_theme).forEach(key => {
    _container.style.setProperty(`${CSS_VAR_PREFIX}${kebabCase$1(key)}`, _theme[key]);
  });
  return {
    themeVars: _theme
  };
}

function _useTheme() {
  // TODO: theme  config provider  getContainer  useTheme 
  const config = useConfig();
  const themeVars = ref(baseTheme());
  watch([() => {
    var _config$getContainer;

    return (_config$getContainer = config.getContainer) === null || _config$getContainer === void 0 ? void 0 : _config$getContainer.value;
  }, () => {
    var _config$theme;

    return (_config$theme = config.theme) === null || _config$theme === void 0 ? void 0 : _config$theme.value;
  }, () => {
    var _config$themeOverride;

    return (_config$themeOverride = config.themeOverrides) === null || _config$themeOverride === void 0 ? void 0 : _config$themeOverride.value;
  }], _ref => {
    let [getContainer, theme, themeOverrides] = _ref;
    if (!getContainer) return;
    const {
      themeVars: currentThemeVars
    } = applyTheme(getContainer(), theme, themeOverrides);
    themeVars.value = currentThemeVars;
  }, {
    immediate: true
  });
  return {
    config,
    themeVars
  };
}

const useTheme = createSharedComposable(_useTheme);

const isFragment = node => node.type === Fragment;
const isComment = node => node.type === Comment;
/**
 * determine if the element is a valid element type rather than fragments and comment e.g. <template> v-if
 * @param node {VNode} node to be tested
 */

const isValidElementNode = node => !(isFragment(node) || isComment(node));
function getFirstValidNode(vNodes) {
  const slotContent = flatten(vNodes); // vue will normalize the slot, so slot must be an array

  if (slotContent.length === 1) {
    return slotContent[0];
  } else {
    console.warn('getFirstSlotVNode', `vNodes should have exactly one child`);
    return null;
  }
}
function getSlot(slots) {
  let slotName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';
  let props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  const slot = slots[slotName];

  if (slot === undefined) {
    console.warn('getSlot', `slot[${slotName}] is empty.`);
    return null;
  }

  return slot(props);
} // o(n) flatten

function flatten(vNodes) {
  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let key = arguments.length > 2 ? arguments[2] : undefined;
  vNodes.forEach(vNode => {
    if (vNode === null) return;

    if (typeof vNode !== 'object') {
      if (typeof vNode === 'string' || typeof vNode === 'number') {
        result.push(createTextVNode(String(vNode)));
      }

      return;
    }

    if (Array.isArray(vNode)) {
      flatten(vNode, result);
      return;
    }

    if (vNode.type === Fragment) {
      if (vNode.children === null) return;
      const currentKey = key ? `${key}_${String(vNode.key)}` : String(vNode.key);

      if (Array.isArray(vNode.children)) {
        vNode.children.forEach((node, index) => {
          if (isVNode(node)) {
            if (node.key === undefined || node.key === null) {
              node.key = `${currentKey}_${index}`;
            }
          }
        });
        flatten(vNode.children, result, currentKey);
      }
    } // rawSlot
    else if (vNode.type !== Comment) {
      result.push(vNode);
    }
  });
  return result;
}

const _excluded = ["getContainer"];
let seed = 0;
const now = Date.now();

function genUid$1() {
  return `notice_manager_${now}_${seed++}`;
}

const Notification = defineComponent({
  props: {
    maxCount: Number,
    transitionName: String
  },

  setup(props) {
    const notices = ref([]);

    function remove(key) {
      const index = notices.value.findIndex(item => item.key === key);
      const notice = notices.value[index];

      if (notice) {
        var _notice$afterRemove;

        notices.value.splice(index, 1);
        (_notice$afterRemove = notice.afterRemove) === null || _notice$afterRemove === void 0 ? void 0 : _notice$afterRemove.call(notice);
      }
    }

    function append(notice) {
      if (!notice.key) notice.key = genUid$1();

      if (props.maxCount && notices.value.length >= props.maxCount) {
        notices.value.shift();
      }

      notices.value.push(notice);

      if (notice.duration > 0) {
        const timer = setTimeout(() => {
          remove(notice.key);
          clearTimeout(timer);
        }, notice.duration * 1000);
      }

      return notice;
    }

    return {
      notices,
      append,
      remove
    };
  },

  render() {
    const {
      notices,
      transitionName
    } = this;
    const children = notices.map(notice => {
      let vNode = typeof notice.children === 'function' ? notice.children() : notice.children;
      vNode = getFirstValidNode([vNode]);
      if (vNode) return cloneVNode(vNode, {
        key: notice.key
      });
    });
    return createVNode(TransitionGroup, {
      "name": transitionName,
      "tag": "div"
    }, {
      default: () => [children]
    });
  }

});
function createManager(opt) {
  return new Promise(resolve => {
    const {
      getContainer
    } = opt,
          props = _objectWithoutProperties(opt, _excluded);

    const div = document.createElement('div');

    if (getContainer) {
      const root = getContainer();
      root === null || root === void 0 ? void 0 : root.appendChild(div);
    } else {
      document.body.appendChild(div);
    }

    const app = createApp({
      setup() {
        useTheme();
        const notificationRef = ref();
        const instance = {
          append: noticeProps => notificationRef.value.append(noticeProps),
          remove: key => notificationRef.value.remove(key),

          destroy() {
            app.unmount();

            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
          },

          exited() {
            // 
            if (!getContainer) return true;

            try {
              if (!getContainer()) {
                instance.destroy();
                return false;
              }
            } catch (error) {
              instance.destroy();
              return false;
            }

            return true;
          }

        };
        onMounted(() => resolve(instance));
        return () => createVNode(Notification, mergeProps({
          "ref": notificationRef
        }, props), null);
      }

    });
    app.mount(div);
  });
}
const iconComponentMap = {
  info: InfoCircleFilled,
  success: CheckCircleFilled,
  error: CloseCircleFilled,
  warning: ExclamationCircleFilled
};

const prefixCls$16 = getPrefixCls('alert');
const alertProps = {
  message: String,
  description: String,
  showIcon: Boolean,
  closable: Boolean,
  center: Boolean,
  type: {
    type: String,
    default: 'info'
  },
  beforeClose: {
    type: Function,
    default: () => true
  }
};
var Alert = defineComponent({
  name: 'FAlert',
  props: alertProps,
  emits: [CLOSE_EVENT],

  setup(props, ctx) {
    useTheme();
    const visible = ref(true);

    function handleCloseClick(event) {
      var _props$beforeClose;

      Promise.resolve((_props$beforeClose = props.beforeClose) === null || _props$beforeClose === void 0 ? void 0 : _props$beforeClose.call(props, event)).then(res => {
        if (res) {
          visible.value = false;
          ctx.emit(CLOSE_EVENT);
        }
      });
    }

    const bodyClass = computed(() => [`${prefixCls$16}-body`, props.showIcon && !props.center && `${prefixCls$16}-icon-padding`]);

    const renderIcon = () => {
      var _iconComponentMap$pro;

      return ctx.slots.icon ? ctx.slots.icon() : (_iconComponentMap$pro = iconComponentMap[props.type]) === null || _iconComponentMap$pro === void 0 ? void 0 : _iconComponentMap$pro.call(iconComponentMap);
    };

    return () => {
      const {
        action: actionSlot,
        default: defaultSlot,
        description: descriptionSlot
      } = ctx.slots;
      const description = props.description || descriptionSlot ? createVNode("div", {
        "class": bodyClass.value
      }, [descriptionSlot ? descriptionSlot() : props.description]) : null;
      return createVNode(Transition, {
        "name": `${prefixCls$16}-fade-expand`
      }, {
        default: () => [!visible.value ? null : createVNode("div", {
          "class": `${prefixCls$16} ${props.center ? `${prefixCls$16}-message-center` : ''} ${prefixCls$16}-${props.type}`
        }, [createVNode("div", {
          "class": `${prefixCls$16}-head`
        }, [createVNode("div", {
          "class": `${prefixCls$16}-head-message`
        }, [props.showIcon ? createVNode("div", {
          "class": `${prefixCls$16}-head-message-icon`
        }, [renderIcon()]) : null, createVNode("div", null, [defaultSlot ? defaultSlot() : props.message])]), createVNode("div", {
          "class": `${prefixCls$16}-head-right`
        }, [actionSlot ? createVNode("div", {
          "class": `${prefixCls$16}-head-right-action`
        }, [actionSlot()]) : null, props.closable ? createVNode("div", {
          "class": `${prefixCls$16}-head-right-close`
        }, [createVNode(CloseCircleOutlined, {
          "onClick": handleCloseClick
        }, null)]) : null])]), description])]
      });
    };
  }

});

const FAlert = withInstall(Alert);

function useAnimate() {
  let duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 300;
  const animating = ref(false);
  const animateClassName = computed(() => animating.value ? 'is-animate' : '');
  const handelAnimate = throttle(() => {
    if (!animating.value) {
      animating.value = true;
    }

    setTimeout(() => {
      animating.value = false;
    }, duration);
  }, 100);
  return {
    animating,
    handelAnimate,
    animateClassName
  };
}

var useFormAdaptor = (formAdaptorConfig => {
  const valueType = formAdaptorConfig === null || formAdaptorConfig === void 0 ? void 0 : formAdaptorConfig.valueType;
  const forbidChildValidate = formAdaptorConfig === null || formAdaptorConfig === void 0 ? void 0 : formAdaptorConfig.forbidChildValidate;
  const {
    validate,
    isError,
    setRuleDefaultType,
    isFormDisabled
  } = inject(FORM_ITEM_INJECTION_KEY, {
    validate: noop$1,
    isError: ref(false),
    isFormDisabled: ref(false)
  }); //  form 

  if (setRuleDefaultType && valueType) {
    if (isString$1(valueType)) {
      setRuleDefaultType(valueType);
    } else if (isRef(valueType)) {
      watch(valueType, () => {
        if (valueType.value) setRuleDefaultType(valueType.value);
      }, {
        immediate: true
      });
    } else if (isFunction(valueType)) {
      setRuleDefaultType(valueType());
    }
  }

  if (forbidChildValidate) {
    // 
    provide(FORM_ITEM_INJECTION_KEY, {
      validate: noop$1,
      isError,
      isFormDisabled
    });
  }

  return {
    validate,
    isError,
    isFormDisabled
  };
});

const prefixCls$15 = getPrefixCls('btn');
const loadingIconClassName = `${prefixCls$15}-loading-icon`;
const buttonProps = {
  disabled: {
    type: Boolean,
    default: false
  },
  htmlType: {
    type: String,
    default: 'button'
  },
  size: {
    type: String,
    default: 'middle'
  },
  loading: {
    type: Boolean,
    default: false
  },
  long: {
    type: Boolean,
    default: false
  },
  throttle: {
    type: Number,
    default: 300
  },
  type: {
    type: String,
    default: 'default'
  }
};
var FButton$1 = defineComponent({
  name: 'FButton',
  props: buttonProps,
  emits: ['click'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const {
      animateClassName,
      handelAnimate
    } = useAnimate(400);
    const {
      isFormDisabled
    } = useFormAdaptor();
    useTheme();
    const notAllowed = ref(false);

    const handleClick = event => {
      if (notAllowed.value || props.disabled || props.loading || isFormDisabled.value) return;
      handelAnimate();
      notAllowed.value = true;
      setTimeout(() => {
        notAllowed.value = false;
      }, props.throttle);
      emit('click', event);
    };

    const classes = computed(() => [prefixCls$15, animateClassName.value, `${prefixCls$15}-type-${props.type}`, props.long && `${prefixCls$15}-long`, props.size !== 'middle' && `${prefixCls$15}-${props.size}`, props.loading && 'is-loading']);
    return () => {
      var _slots$icon, _slots$default;

      return createVNode("button", {
        "type": props.htmlType,
        "disabled": props.disabled || isFormDisabled.value,
        "class": classes.value,
        "onClick": handleClick
      }, [props.loading ? createVNode(LoadingOutlined, {
        "class": loadingIconClassName
      }, null) : (_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }

});

const FButton = withInstall(FButton$1);

function ownKeys$P(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$P(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$P(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$P(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const useNormalModel = function (props, emit) {
  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    prop = 'modelValue',
    deep = false,
    isEqual: isEqual$1 = false,
    defaultValue
  } = config;
  const usingProp = prop;
  const currentValue = ref(!isUndefined(props[usingProp]) ? props[usingProp] : defaultValue);

  const pureUpdateCurrentValue = value => {
    if (value === currentValue.value || isEqual$1 && isEqual(value, currentValue.value)) {
      return;
    }

    currentValue.value = value;
  };

  const updateCurrentValue = value => {
    pureUpdateCurrentValue(value);
    emit(`update:${usingProp}`, currentValue.value);
  };

  watch(() => props[usingProp], val => {
    if (val === currentValue.value) {
      return;
    }

    currentValue.value = val;
  }, {
    deep
  });
  return [computed({
    get() {
      return currentValue.value;
    },

    set(value) {
      updateCurrentValue(value);
    }

  }), updateCurrentValue];
};
const useArrayModel = function (props, emit) {
  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const [computedValue, updateCurrentValue] = useNormalModel(props, emit, _objectSpread$P(_objectSpread$P({}, config), {}, {
    defaultValue: []
  }));

  const updateItem = value => {
    if (isArray$1(value)) {
      updateCurrentValue(value);
      return;
    }

    const val = computedValue.value;
    const index = val.indexOf(value);

    if (index !== -1) {
      val.splice(index, 1);
    } else {
      val.push(value);
    }

    updateCurrentValue(val);
  };

  return [computedValue, updateItem];
};

var useSelect$1 = (_ref => {
  let {
    props,
    emit,
    parent
  } = _ref;
  const {
    validate,
    isFormDisabled
  } = useFormAdaptor({
    valueType: 'boolean'
  });
  const group = inject(parent.groupKey, null);
  const focus = ref(false);
  const hover = ref(false);
  const isGroup = group !== null;
  const [currentValue, updateCurrentValue] = useNormalModel(props, emit);
  const checked = computed(() => {
    if (!isGroup) {
      return currentValue.value;
    }

    return group.isSelect(props.value);
  });
  const innerDisabled = computed(() => {
    var _group$props;

    return props.disabled || isGroup && (group === null || group === void 0 ? void 0 : (_group$props = group.props) === null || _group$props === void 0 ? void 0 : _group$props.disabled) || isFormDisabled.value;
  });

  const handleClick = () => {
    if (innerDisabled.value) {
      return;
    }

    if (isGroup) {
      group.onSelect(props.value);
    } else {
      const newVal = !currentValue.value;
      updateCurrentValue(newVal);
      emit(CHANGE_EVENT$1, newVal);
      validate(CHANGE_EVENT$1);
    }
  };

  const handleMouseOver = () => {
    hover.value = true;
  };

  const handleMouseOut = () => {
    hover.value = false;
  };

  return {
    currentValue,
    updateCurrentValue,
    checked,
    innerDisabled,
    isGroup,
    group,
    focus,
    hover,
    handleClick,
    handleMouseOver,
    handleMouseOut
  };
});

const checkboxGroupKey = Symbol('FCheckboxGroup');
const name$1 = 'FCheckboxGroup';

function ownKeys$O(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$O(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$O(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$O(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const __default__$4 = {
  name: 'FCheckbox'
};
var script$C = /*#__PURE__*/defineComponent(_objectSpread$O(_objectSpread$O({}, __default__$4), {}, {
  props: {
    modelValue: {
      type: Boolean,
      required: false,
      default: false
    },
    indeterminate: {
      type: Boolean,
      required: false,
      default: false
    },
    value: {
      type: [String, Number, Boolean],
      required: false
    },
    label: {
      type: [String, Number],
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: ["update:modelValue", "change"],

  setup(__props, _ref) {
    let {
      emit
    } = _ref;
    const props = __props;
    const prefixCls = getPrefixCls('checkbox');
    useTheme();
    const {
      isGroup,
      group,
      hover,
      checked,
      innerDisabled,
      handleClick,
      handleMouseOver,
      handleMouseOut
    } = useSelect$1({
      props,
      emit,
      parent: {
        groupKey: checkboxGroupKey,
        name: name$1
      }
    });
    const wrapperClass = computed(() => {
      const arr = [`${prefixCls}`];

      if (checked.value) {
        arr.push('is-checked');
      }

      if (innerDisabled.value) {
        arr.push('is-disabled');
      }

      if (hover.value) {
        arr.push('is-hover');
      }

      if (isGroup) {
        var _group$props;

        arr.push('is-item');

        if (group !== null && group !== void 0 && (_group$props = group.props) !== null && _group$props !== void 0 && _group$props.vertical) {
          arr.push('is-item-vertical');
        }
      }

      if (props.indeterminate) {
        arr.push('is-indeterminate');
      }

      return arr;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        class: normalizeClass(unref(wrapperClass)),
        onClick: _cache[0] || (_cache[0] = //@ts-ignore
        function () {
          return unref(handleClick) && unref(handleClick)(...arguments);
        }),
        onMouseover: _cache[1] || (_cache[1] = //@ts-ignore
        function () {
          return unref(handleMouseOver) && unref(handleMouseOver)(...arguments);
        }),
        onMouseout: _cache[2] || (_cache[2] = //@ts-ignore
        function () {
          return unref(handleMouseOut) && unref(handleMouseOut)(...arguments);
        })
      }, [createElementVNode("span", {
        class: normalizeClass(`${unref(prefixCls)}-inner`)
      }, null, 2
      /* CLASS */
      ), _ctx.$slots.default || __props.label ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass(`${unref(prefixCls)}-content`)
      }, [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(__props.label), 1
      /* TEXT */
      )])], 2
      /* CLASS */
      )) : createCommentVNode("v-if", true)], 34
      /* CLASS, HYDRATE_EVENTS */
      );
    };
  }

}));

script$C.__file = "components/checkbox/checkbox.vue";

const FCheckbox = withInstall(script$C);

const useCheckboxGroup = (props, emit) => {
  const {
    validate,
    isFormDisabled
  } = useFormAdaptor({
    valueType: 'array',
    forbidChildValidate: true
  });
  const [currentValue, updateItem] = useArrayModel(props, emit);

  const handleChange = () => {
    emit(CHANGE_EVENT$1, currentValue.value);
    validate(CHANGE_EVENT$1);
  };

  const isSelect = value => {
    const groupVal = unref(currentValue);
    const itemVal = unref(value);

    if (groupVal === null || itemVal === null) {
      return false;
    }

    return groupVal.includes(itemVal);
  };

  const onSelect = value => {
    updateItem(unref(value));
    handleChange();
  };

  provide(checkboxGroupKey, {
    name: name$1,
    isSelect,
    onSelect,
    props
  });
  return {
    isFormDisabled
  };
};

function ownKeys$N(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$N(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$N(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$N(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const __default__$3 = {
  name: name$1
};
var script$B = /*#__PURE__*/defineComponent(_objectSpread$N(_objectSpread$N({}, __default__$3), {}, {
  props: {
    modelValue: {
      type: Array,
      required: false,
      default: () => []
    },
    vertical: {
      type: Boolean,
      required: false,
      default: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    options: {
      type: Array,
      required: false,
      default: () => []
    },
    valueField: {
      type: String,
      required: false,
      default: 'value'
    },
    labelField: {
      type: String,
      required: false,
      default: 'label'
    }
  },
  emits: ["update:modelValue", "change"],

  setup(__props, _ref) {
    let {
      emit
    } = _ref;
    const props = __props;
    const prefixCls = getPrefixCls('checkbox-group');
    useTheme();
    const {
      isFormDisabled
    } = useCheckboxGroup(props, emit);
    const classList = computed(() => [prefixCls, props.vertical && 'is-vertical', (isFormDisabled.value || props.disabled) && 'is-disabled']);
    const optionsRef = computed(() => props.options.map(opt => {
      return _objectSpread$N(_objectSpread$N({}, opt), {}, {
        value: opt[props.valueField],
        label: opt[props.labelField]
      });
    }));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(classList))
      }, [renderSlot(_ctx.$slots, "default"), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(optionsRef), opt => {
        return openBlock(), createBlock(script$C, {
          key: opt.value,
          value: opt.value,
          label: opt.label,
          disabled: opt.disabled
        }, null, 8
        /* PROPS */
        , ["value", "label", "disabled"]);
      }), 128
      /* KEYED_FRAGMENT */
      ))], 2
      /* CLASS */
      );
    };
  }

}));

script$B.__file = "components/checkbox-group/checkbox-group.vue";

const FCheckboxGroup = withInstall(script$B);

const prefixCls$14 = getPrefixCls('divider');
const dividerProps = {
  // 
  vertical: {
    type: Boolean,
    default: false
  },
  // 
  titlePlacement: {
    type: String,
    default: 'center'
  }
};
var Divider = defineComponent({
  name: 'FDivider',
  props: dividerProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useTheme();
    const classList = computed(() => [prefixCls$14, props.vertical && 'is-vertical'].filter(Boolean).join(' '));
    return () => {
      var _slots$default;

      return createVNode("div", {
        "class": classList.value
      }, [!props.vertical ? createVNode("div", {
        "class": `${prefixCls$14}-text is-${props.titlePlacement}`
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]) : null]);
    };
  }

});

const FDivider = withInstall(Divider);

function ownKeys$M(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$M(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$M(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$M(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const UPDATE_MODEL_EVENT = 'update:modelValue';
const DRAG_START_EVENT = 'dragstart';
const DRAG_END_EVENT = 'dragend';
let dragSourceCxt;
let sourceBackup;

function pushAt() {
  let array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let value = arguments.length > 1 ? arguments[1] : undefined;
  let index = arguments.length > 2 ? arguments[2] : undefined;

  if (index < 0) {
    return array.unshift(value);
  }

  if (index >= array.length) return array.push(value);
  const evens = array.splice(index, array.length - index);
  array.push(value, ...evens);
}
/**
 * 
 */


function arrayMove() {
  let array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
  let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
  let value = arguments.length > 3 ? arguments[3] : undefined;

  if (source < 0) {
    // add target
    pushAt(array, value, target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    return [value];
  }

  if (target < 0) {
    // remove source
    return array.splice(source, 1);
  }

  const evens = array.splice(source, 1);
  pushAt(array, evens[0], target);
  return evens;
} // 


function findElement(target, parent) {
  if (!parent || !target) return;

  for (let index = 0; index < parent.children.length; index++) {
    const el = parent.children[index];

    if (el.contains(target)) {
      return {
        el: el,
        index
      };
    }
  }

  return;
}

class DraggableItem {
  constructor() {
    _defineProperty(this, "draggable", null);

    _defineProperty(this, "first", {
      x: 0,
      y: 0
    });

    _defineProperty(this, "last", {
      x: 0,
      y: 0
    });

    _defineProperty(this, "style", {
      transition: '',
      transform: '',
      opacity: null
    });

    _defineProperty(this, "elStyle", {});
  }

  // 
  setDraggable() {
    let draggable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.draggable = draggable || null;

    if (!draggable) {
      this.style.opacity = null;
    }
  }

  setOpacity() {
    let opacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.4;
    this.style.opacity = opacity;
  }

}
const useDraggable = (containerRef, propsRef, ctx) => {
  const draggableItems = reactive([]);
  const current = {};
  const backup = {};

  const emit = (ctx === null || ctx === void 0 ? void 0 : ctx.emit) || (() => null);

  let mousedownEvent;
  const nextTickQueue = [];

  const newNextTick = fn => {
    if (propsRef.value.isDirective) {
      isFunction(fn) && nextTickQueue.push(fn);
    } else {
      nextTick(fn);
    }
  };

  const onUpdated = () => {
    while (nextTickQueue.length) {
      nextTickQueue.shift()();
    }
  };

  const FLIP = isFirst => {
    if (!containerRef.value) return;

    for (let index = 0; index < containerRef.value.children.length; index++) {
      const node = containerRef.value.children[index];

      if (!draggableItems[index]) {
        draggableItems[index] = new DraggableItem();
        const elStyle = {};

        for (let index = 0; index < node.style.length; index++) {
          const key = node.style[index];
          elStyle[key] = node.style[key];
        }

        draggableItems[index].elStyle = elStyle;
      }

      const item = draggableItems[index];
      const rect = node.getBoundingClientRect();

      if (isFirst) {
        // First
        item.first.x = rect.left;
        item.first.y = rect.top;
      } else {
        // Last
        item.last.x = rect.left;
        item.last.y = rect.top; // Invert

        item.style.transform = `translate3d(${item.first.x - item.last.x}px, ${item.first.y - item.last.y}px , 0)`;
        item.style.transition = '';
      }
    }

    if (isFirst) return;
    requestAnimationFrame(() => {
      // Play
      draggableItems.forEach(item => {
        item.style.transition = 'transform 200ms ease';
        item.style.transform = '';
      });
    });
  }; // backup


  const revertStatus = () => {
    FLIP(true);
    backup.list.forEach((item, index) => {
      var _backup$draggableItem;

      draggableItems[index] = (_backup$draggableItem = backup.draggableItems) === null || _backup$draggableItem === void 0 ? void 0 : _backup$draggableItem[index];
    });
    emit(UPDATE_MODEL_EVENT, backup.list);
    newNextTick(() => {
      FLIP(false);
    });
  };

  const computeDropTarget = event => {
    const target = findElement(event.target, containerRef.value);

    if (!target) {
      if (event.target === containerRef.value) {
        // 
        return {
          el: null,
          index: propsRef.value.list.length
        };
      }

      return null;
    }

    return target;
  };

  const resetDragWhenEnd = event => {
    var _current$drag, _sourceBackup;

    const index = (_current$drag = current.drag) === null || _current$drag === void 0 ? void 0 : _current$drag.index;

    if (event && index >= 0) {
      emit(DRAG_END_EVENT, event, propsRef.value.list[index], index);
    }

    backup.list = null;

    if ((_sourceBackup = sourceBackup) !== null && _sourceBackup !== void 0 && _sourceBackup.list) {
      sourceBackup.list = null;
    }

    backup.draggableItems = [];
    backup.index = -1;
    current.drag = null;
    current.animationEnd = true;
    current.isDropOverItem = false;
    draggableItems.forEach(item => {
      item.setDraggable(false);
      item.style.transition = null;
    });
  };

  const shareSource = () => {
    dragSourceCxt = {
      propsRef,
      current,
      draggableItems,
      FLIP,
      emit,
      resetDragWhenEnd,
      newNextTick
    };
  };

  const backupStatus = () => {
    var _current$drag2;

    backup.list = [...propsRef.value.list];
    backup.draggableItems = [...draggableItems];
    backup.index = (_current$drag2 = current.drag) === null || _current$drag2 === void 0 ? void 0 : _current$drag2.index;
    backup.revertStatus = revertStatus;
    backup.resetDragWhenEnd = resetDragWhenEnd;
  };

  const onAnimationEnd = () => {
    current.animationEnd = true;
    current.isDropOverItem = false;
  };
  /**  */


  const onDragstart = event => {
    mousedownEvent = event;
    const {
      disabled,
      droppable,
      list
    } = propsRef.value;
    if (disabled) return;
    current.drag = findElement(event.target, containerRef.value);
    if (!current.drag) return;
    const index = current.drag.index;
    const item = draggableItems[index];
    onAnimationEnd(); // 

    item.setDraggable(true); // 

    backupStatus();

    if (droppable) {
      shareSource(); // 

      sourceBackup = _objectSpread$M({}, backup);
    }

    emit(DRAG_START_EVENT, event, list[index], index);
  };

  const onMousemove = event => {
    var _current$drag3;

    if (!mousedownEvent) return;
    const item = draggableItems[current === null || current === void 0 ? void 0 : (_current$drag3 = current.drag) === null || _current$drag3 === void 0 ? void 0 : _current$drag3.index];

    if (item && (Math.abs(event.x - mousedownEvent.x) || Math.abs(event.y - mousedownEvent.y))) {
      item.setOpacity();
    }
  };

  const onDragover = event => {
    event.preventDefault();
    const {
      droppable,
      list
    } = propsRef.value;
    const {
      animationEnd,
      isDropOverItem,
      drag
    } = current;
    const s = dragSourceCxt; // 

    if (!animationEnd || s && !s.current.animationEnd) return; // 

    const drop = computeDropTarget(event);
    if (!drop) return;
    let listEvens; // 

    let draggableItemEvens; // 

    let dragIndex = -1;

    if (droppable && s && !containerRef.value.contains(s.current.drag.el)) {
      // sourcesource
      s.FLIP(true);
      current.isDropOverItem = !!drop.el;
      const sDragIndex = s.current.drag.index;

      if (!backup.list) {
        // 
        backupStatus();
        backup.index = sDragIndex;
      }

      listEvens = arrayMove(s.propsRef.value.list, sDragIndex)[0];
      draggableItemEvens = arrayMove(s.draggableItems, sDragIndex)[0];
      s.current.animationEnd = false; // 

      s.current.drag = null;
      s.emit(UPDATE_MODEL_EVENT, s.propsRef.value.list);
    } else {
      // 
      dragIndex = drag.index;
      if (drop.index < 0) drop.index = 0;
      if (drop.index >= list.length) drop.index = list.length - 1;
      if (dragIndex === drop.index || isDropOverItem) return;
    } // 


    FLIP(true);
    arrayMove(list, dragIndex, drop.index, listEvens);
    arrayMove(draggableItems, dragIndex, drop.index, draggableItemEvens);
    emit(UPDATE_MODEL_EVENT, list);
    current.animationEnd = false; // 

    if (droppable && s) {
      s.newNextTick(() => {
        s.FLIP(false);
        shareSource();
      });
    }

    newNextTick(() => {
      current.drag = {
        index: drop.index === -1 ? 0 : drop.index,
        el: null
      };
      current.drag.el = containerRef.value.children[drop.index];
      FLIP(false);
    });
  };

  const checkDragEnd = async () => {
    var _current$drag4;

    const {
      beforeDragend,
      list
    } = propsRef.value;
    const index = current === null || current === void 0 ? void 0 : (_current$drag4 = current.drag) === null || _current$drag4 === void 0 ? void 0 : _current$drag4.index;

    if (isFunction(beforeDragend) && index >= 0) {
      var _sourceBackup2;

      // 
      let isTrue = false;
      let drag = {
        list: backup.list,
        index: backup.index,
        item: backup.list[backup.index],
        resultList: list // 

      };

      const drop = _objectSpread$M(_objectSpread$M({}, drag), {}, {
        index
      });

      if ((_sourceBackup2 = sourceBackup) !== null && _sourceBackup2 !== void 0 && _sourceBackup2.list && backup.list !== sourceBackup.list) {
        const resultList = [...sourceBackup.list];
        arrayMove(resultList, sourceBackup.index);
        drag = {
          list: sourceBackup.list,
          index: sourceBackup.index,
          item: sourceBackup.list[sourceBackup.index],
          resultList
        };
        drop.item = drag.item;
      }

      try {
        isTrue = await beforeDragend(drag, drop);
      } catch (error) {
        console.error(error);
        isTrue = false;
      }

      if (!isTrue) {
        var _sourceBackup3;

        revertStatus();
        (_sourceBackup3 = sourceBackup) === null || _sourceBackup3 === void 0 ? void 0 : _sourceBackup3.revertStatus();
      }
    }
  };

  const onDragend = async event => {
    mousedownEvent = null;
    const {
      droppable
    } = propsRef.value;
    await checkDragEnd();

    if (droppable && dragSourceCxt) {
      var _sourceBackup4;

      (_sourceBackup4 = sourceBackup) === null || _sourceBackup4 === void 0 ? void 0 : _sourceBackup4.resetDragWhenEnd(event);
      dragSourceCxt = null;
    }

    resetDragWhenEnd(event);
  };

  resetDragWhenEnd();
  watch(containerRef, () => FLIP(true), {
    immediate: true
  });
  watch(propsRef, () => {
    if (draggableItems.length !== propsRef.value.list.length) {
      if (propsRef.value.isDirective) {
        FLIP(true); // listupdated
      } else {
        nextTick(() => FLIP(true));
      }
    }
  }, {
    immediate: true,
    deep: true
  });
  return {
    onAnimationEnd,
    onDragover,
    onDragstart,
    onDragend,
    draggableItems,
    nextTickQueue,
    onMousemove,
    onUpdated
  };
};

function ownKeys$L(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$L(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$L(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$L(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$13 = getPrefixCls('draggable');
var Draggable = defineComponent({
  name: 'FDraggable',
  props: {
    modelValue: {
      type: Array,
      default: []
    },
    droppable: Boolean,
    disabled: Boolean,
    beforeDragend: Function,
    tag: {
      type: String,
      default: 'div'
    }
  },
  emits: [UPDATE_MODEL_EVENT, DRAG_START_EVENT, DRAG_END_EVENT],

  setup(props, ctx) {
    useTheme();
    const rootRef = ref();
    const propsRef = computed(() => ({
      droppable: props.droppable,
      disabled: props.disabled,
      list: [...props.modelValue],
      beforeDragend: props.beforeDragend
    }));
    const {
      onAnimationEnd,
      onDragstart,
      onDragover,
      onDragend,
      onMousemove,
      draggableItems
    } = useDraggable(rootRef, propsRef, ctx);
    const tag = props.tag || 'div';

    const renderItem = (item, index) => {
      var _flatten, _vNodes$0$props, _draggableItems$index, _draggableItems$index2;

      const vNodes = (_flatten = flatten(ctx.slots.default({
        item,
        index
      }))) === null || _flatten === void 0 ? void 0 : _flatten.filter(node => !isComment(node));
      if (!vNodes || !vNodes.length) return;

      if (vNodes.length > 1) {
        console.warn('[FDraggable]: default slot must be a root element');
      }

      const style = _objectSpread$L({}, ((_vNodes$0$props = vNodes[0].props) === null || _vNodes$0$props === void 0 ? void 0 : _vNodes$0$props.style) || {});

      mergeWith$1(style, (_draggableItems$index = draggableItems[index]) === null || _draggableItems$index === void 0 ? void 0 : _draggableItems$index.style, (value, srcValue) => srcValue || value);
      return cloneVNode(vNodes[0], {
        key: index,
        draggable: (_draggableItems$index2 = draggableItems[index]) === null || _draggableItems$index2 === void 0 ? void 0 : _draggableItems$index2.draggable,
        style: style
      });
    };

    return () => createVNode(tag, {
      "ref": rootRef,
      "class": prefixCls$13,
      "onMousedown": onDragstart,
      "onDragover": onDragover,
      "onDragend": onDragend,
      "onDrop": onDragend,
      "onMouseup": onDragend,
      "onMousemove": onMousemove,
      "onTransitionend": onAnimationEnd
    }, {
      default: () => [props.modelValue.map(renderItem)]
    });
  }

});

const dragInstanceMap = new WeakMap();

const updateStyle = (el, items) => {
  var _el$children;

  if (!(el !== null && el !== void 0 && (_el$children = el.children) !== null && _el$children !== void 0 && _el$children.length)) return;

  for (let index = 0; index < el.children.length; index++) {
    const node = el.children[index];
    const item = items[index];

    if (item !== null && item !== void 0 && item.draggable) {
      node.setAttribute('draggable', 'true');
    } else {
      node.removeAttribute('draggable');
    }

    const opacity = (item === null || item === void 0 ? void 0 : item.style.opacity) || (item === null || item === void 0 ? void 0 : item.elStyle.opacity) || '';
    const transition = (item === null || item === void 0 ? void 0 : item.style.transition) || (item === null || item === void 0 ? void 0 : item.elStyle.transition) || '';
    const transform = (item === null || item === void 0 ? void 0 : item.style.transform) || (item === null || item === void 0 ? void 0 : item.elStyle.transform) || '';
    const style = node.style;
    style.opacity = opacity;
    style.transition = transition;
    style.transform = transform;
  }
};

const init = (el, binding) => {
  if (binding.modifiers.disabled) return;
  const bindArg = binding.arg;
  const props = reactive({
    list: binding.value || [],
    droppable: binding.modifiers.droppable,
    disabled: binding.modifiers.disabled,
    isDirective: true,
    beforeDragend: bindArg === null || bindArg === void 0 ? void 0 : bindArg.beforeDragend
  });
  const containerRef = ref(el);
  const propsRef = computed(() => props);

  const emit = function (type) {
    var _bindArg$onDragstart, _bindArg$onDragend;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    switch (type) {
      case DRAG_START_EVENT:
        bindArg === null || bindArg === void 0 ? void 0 : (_bindArg$onDragstart = bindArg.onDragstart) === null || _bindArg$onDragstart === void 0 ? void 0 : _bindArg$onDragstart.call(bindArg, ...args);
        break;

      case DRAG_END_EVENT:
        bindArg === null || bindArg === void 0 ? void 0 : (_bindArg$onDragend = bindArg.onDragend) === null || _bindArg$onDragend === void 0 ? void 0 : _bindArg$onDragend.call(bindArg, ...args);
        break;

      case UPDATE_MODEL_EVENT:
        const list = args[0] || [];
        list.forEach((item, index) => {
          propsRef.value.list[index] = list[index];
        });
        propsRef.value.list.length = list.length;
        break;
    }
  };

  const drag = useDraggable(containerRef, propsRef, {
    emit
  });
  el.addEventListener('mousedown', drag.onDragstart);
  el.addEventListener('dragover', drag.onDragover);
  el.addEventListener('drop', drag.onDragend);
  el.addEventListener('mouseup', drag.onDragend);
  el.addEventListener('dragend', drag.onDragend);
  el.addEventListener('transitionend', drag.onAnimationEnd);
  el.addEventListener('mousemove', drag.onMousemove);
  watch(() => drag.draggableItems, () => updateStyle(el, drag.draggableItems), {
    deep: true
  });
  dragInstanceMap.set(el, {
    drag,
    props
  });
};

var vDrag = {
  name: 'drag',

  mounted(el, binding) {
    init(el, binding);
  },

  updated(el, binding) {
    const {
      drag,
      props
    } = dragInstanceMap.get(el) || {};

    if (drag && props) {
      props.list = binding.value || [];
      props.droppable = binding.modifiers.droppable;
      props.disabled = binding.modifiers.disabled;
      drag.onUpdated();
      return;
    }

    init(el, binding);
  },

  beforeUnmount(el) {
    const {
      drag
    } = dragInstanceMap.get(el) || {};

    if (drag) {
      el.removeEventListener('mousedown', drag.onDragstart);
      el.removeEventListener('dragover', drag.onDragover);
      el.removeEventListener('drop', drag.onDragend);
      el.removeEventListener('mouseup', drag.onDragend);
      el.removeEventListener('dragend', drag.onDragend);
      el.removeEventListener('transitionend', drag.onAnimationEnd);
    }
  }

};

const FDraggable = withInstall(Draggable, {}, [vDrag]);

var LazyTeleport = defineComponent({
  name: 'LazyTeleport',
  props: {
    to: {
      type: [String, Object],
      default: undefined
    },
    disabled: Boolean,
    show: {
      type: Boolean,
      required: true
    }
  },

  setup(props) {
    const showTeleport = ref(props.show);
    watch(() => props.show, val => {
      if (val) {
        showTeleport.value = true;
      }
    });
    return {
      showTeleport: showTeleport,
      mergedTo: computed(() => {
        const {
          to
        } = props;
        return to !== null && to !== void 0 ? to : 'body';
      })
    };
  },

  render() {
    return this.showTeleport ? this.disabled ? getSlot(this.$slots) : h(Teleport, {
      disabled: this.disabled,
      to: this.mergedTo
    }, getSlot(this.$slots)) : null;
  }

});

var getElementFromRef = (val => {
  if (!val) return null;
  if (val instanceof Text) return val;
  return val instanceof HTMLElement ? val : val.$el;
});

function useClickOutSide(watchList, callback) {
  let disabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  const _watchList = Array.isArray(watchList) ? watchList : [watchList];

  let listened = false;
  const disabledRef = ref(disabled);

  function onGlobalMouseDown(event) {
    const target = event.target;

    const elements = _watchList.map(r => getElementFromRef(unref(r)));

    if (elements.every(element => element && !element.contains(target) && element !== target)) {
      callback && callback();
    }
  }

  const destroy = () => {
    if (listened) {
      listened = false;
      window.removeEventListener('click', onGlobalMouseDown, true);
    }
  };

  watch(disabledRef, () => {
    if (disabledRef.value) {
      destroy();
    } else if (!listened) {
      listened = true;
      window.addEventListener('click', onGlobalMouseDown, true);
    }
  }, {
    immediate: true
  });
  onBeforeUnmount(destroy);
  return destroy;
}

var resizeObservers = [];

var hasActiveObservations = function () {
  return resizeObservers.some(function (ro) {
    return ro.activeTargets.length > 0;
  });
};

var hasSkippedObservations = function () {
  return resizeObservers.some(function (ro) {
    return ro.skippedTargets.length > 0;
  });
};

var msg = 'ResizeObserver loop completed with undelivered notifications.';

var deliverResizeLoopError = function () {
  var event;

  if (typeof ErrorEvent === 'function') {
    event = new ErrorEvent('error', {
      message: msg
    });
  } else {
    event = document.createEvent('Event');
    event.initEvent('error', false, false);
    event.message = msg;
  }

  window.dispatchEvent(event);
};

var ResizeObserverBoxOptions;

(function (ResizeObserverBoxOptions) {
  ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

var freeze = function (obj) {
  return Object.freeze(obj);
};

var ResizeObserverSize = function () {
  function ResizeObserverSize(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }

  return ResizeObserverSize;
}();

var DOMRectReadOnly = function () {
  function DOMRectReadOnly(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }

  DOMRectReadOnly.prototype.toJSON = function () {
    var _a = this,
        x = _a.x,
        y = _a.y,
        top = _a.top,
        right = _a.right,
        bottom = _a.bottom,
        left = _a.left,
        width = _a.width,
        height = _a.height;

    return {
      x: x,
      y: y,
      top: top,
      right: right,
      bottom: bottom,
      left: left,
      width: width,
      height: height
    };
  };

  DOMRectReadOnly.fromRect = function (rectangle) {
    return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };

  return DOMRectReadOnly;
}();

var isSVG = function (target) {
  return target instanceof SVGElement && 'getBBox' in target;
};

var isHidden = function (target) {
  if (isSVG(target)) {
    var _a = target.getBBox(),
        width = _a.width,
        height = _a.height;

    return !width && !height;
  }

  var _b = target,
      offsetWidth = _b.offsetWidth,
      offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};

var isElement$1 = function (obj) {
  var _a, _b;

  if (obj instanceof Element) {
    return true;
  }

  var scope = (_b = (_a = obj) === null || _a === void 0 ? void 0 : _a.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView;
  return !!(scope && obj instanceof scope.Element);
};

var isReplacedElement = function (target) {
  switch (target.tagName) {
    case 'INPUT':
      if (target.type !== 'image') {
        break;
      }

    case 'VIDEO':
    case 'AUDIO':
    case 'EMBED':
    case 'OBJECT':
    case 'CANVAS':
    case 'IFRAME':
    case 'IMG':
      return true;
  }

  return false;
};

var global$1 = typeof window !== 'undefined' ? window : {};

var cache = new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);

var parseDimension = function (pixel) {
  return parseFloat(pixel || '0');
};

var size = function (inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }

  if (blockSize === void 0) {
    blockSize = 0;
  }

  if (switchSizes === void 0) {
    switchSizes = false;
  }

  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};

var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});

var calculateBoxSizes = function (target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }

  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }

  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }

  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === 'border-box';
  var switchSizes = verticalRegexp.test(cs.writingMode || '');
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};

var calculateBoxSize = function (target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation),
      borderBoxSize = _a.borderBoxSize,
      contentBoxSize = _a.contentBoxSize,
      devicePixelContentBoxSize = _a.devicePixelContentBoxSize;

  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;

    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;

    default:
      return contentBoxSize;
  }
};

var ResizeObserverEntry = function () {
  function ResizeObserverEntry(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }

  return ResizeObserverEntry;
}();

var calculateDepthForNode = function (node) {
  if (isHidden(node)) {
    return Infinity;
  }

  var depth = 0;
  var parent = node.parentNode;

  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }

  return depth;
};

var broadcastActiveObservations = function () {
  var shallowestDepth = Infinity;
  var callbacks = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }

    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);

      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });

  for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }

  return shallowestDepth;
};

var gatherActiveObservationsAtDepth = function (depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};

var process$1 = function () {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);

  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }

  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }

  return depth > 0;
};

var trigger;
var callbacks = [];

var notify = function () {
  return callbacks.splice(0).forEach(function (cb) {
    return cb();
  });
};

var queueMicroTask = function (callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode('');
    var config = {
      characterData: true
    };
    new MutationObserver(function () {
      return notify();
    }).observe(el_1, config);

    trigger = function () {
      el_1.textContent = "" + (toggle_1 ? toggle_1-- : toggle_1++);
    };
  }

  callbacks.push(callback);
  trigger();
};

var queueResizeObserver = function (cb) {
  queueMicroTask(function ResizeObserver() {
    requestAnimationFrame(cb);
  });
};

var watching = 0;

var isWatching = function () {
  return !!watching;
};

var CATCH_PERIOD = 250;
var observerConfig = {
  attributes: true,
  characterData: true,
  childList: true,
  subtree: true
};
var events = ['resize', 'load', 'transitionend', 'animationend', 'animationstart', 'animationiteration', 'keyup', 'keydown', 'mouseup', 'mousedown', 'mouseover', 'mouseout', 'blur', 'focus'];

var time = function (timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }

  return Date.now() + timeout;
};

var scheduled = false;

var Scheduler = function () {
  function Scheduler() {
    var _this = this;

    this.stopped = true;

    this.listener = function () {
      return _this.schedule();
    };
  }

  Scheduler.prototype.run = function (timeout) {
    var _this = this;

    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }

    if (scheduled) {
      return;
    }

    scheduled = true;
    var until = time(timeout);
    queueResizeObserver(function () {
      var elementsHaveResized = false;

      try {
        elementsHaveResized = process$1();
      } finally {
        scheduled = false;
        timeout = until - time();

        if (!isWatching()) {
          return;
        }

        if (elementsHaveResized) {
          _this.run(1000);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };

  Scheduler.prototype.schedule = function () {
    this.stop();
    this.run();
  };

  Scheduler.prototype.observe = function () {
    var _this = this;

    var cb = function () {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };

    document.body ? cb() : global$1.addEventListener('DOMContentLoaded', cb);
  };

  Scheduler.prototype.start = function () {
    var _this = this;

    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function (name) {
        return global$1.addEventListener(name, _this.listener, true);
      });
    }
  };

  Scheduler.prototype.stop = function () {
    var _this = this;

    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function (name) {
        return global$1.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };

  return Scheduler;
}();

var scheduler = new Scheduler();

var updateCount = function (n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};

var skipNotifyOnElement = function (target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === 'inline';
};

var ResizeObservation = function () {
  function ResizeObservation(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }

  ResizeObservation.prototype.isActive = function () {
    var size = calculateBoxSize(this.target, this.observedBox, true);

    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size;
    }

    if (this.lastReportedSize.inlineSize !== size.inlineSize || this.lastReportedSize.blockSize !== size.blockSize) {
      return true;
    }

    return false;
  };

  return ResizeObservation;
}();

var ResizeObserverDetail = function () {
  function ResizeObserverDetail(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }

  return ResizeObserverDetail;
}();

var observerMap = new WeakMap();

var getObservationIndex = function (observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }

  return -1;
};

var ResizeObserverController = function () {
  function ResizeObserverController() {}

  ResizeObserverController.connect = function (resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };

  ResizeObserverController.observe = function (resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;

    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };

  ResizeObserverController.unobserve = function (resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;

    if (index >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index, 1);
      updateCount(-1);
    }
  };

  ResizeObserverController.disconnect = function (resizeObserver) {
    var _this = this;

    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function (ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };

  return ResizeObserverController;
}();

var ResizeObserver = function () {
  function ResizeObserver(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }

    if (typeof callback !== 'function') {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }

    ResizeObserverController.connect(this, callback);
  }

  ResizeObserver.prototype.observe = function (target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }

    if (!isElement$1(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }

    ResizeObserverController.observe(this, target, options);
  };

  ResizeObserver.prototype.unobserve = function (target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }

    if (!isElement$1(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }

    ResizeObserverController.unobserve(this, target);
  };

  ResizeObserver.prototype.disconnect = function () {
    ResizeObserverController.disconnect(this);
  };

  ResizeObserver.toString = function () {
    return 'function ResizeObserver () { [polyfill code] }';
  };

  return ResizeObserver;
}();

var useResize = (function (triggerRef, callback, disabled) {
  let immediate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  const disabledRef = ref(disabled);

  const handleResize = () => {
    if (disabledRef.value) {
      return;
    }

    if (!immediate) {
      immediate = true;
      return;
    }

    callback && callback();
  };

  const ro = new ResizeObserver(handleResize);
  let observedDom = null;

  const handle = dom => {
    if (observedDom) {
      ro.unobserve(observedDom);
    }

    if (dom) {
      ro.observe(dom);
      observedDom = dom;
    }
  };

  onMounted(() => {
    watch(triggerRef, () => {
      nextTick(() => {
        handle(triggerRef.value);
      });
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(() => {
    ro.disconnect();
  });
});

const triggerEventsMap = {
  click: ['onClick'],
  hover: ['onMouseenter', 'onMouseleave'],
  focus: ['onFocus', 'onBlur'],
  contextmenu: ['onContextmenu', 'onClick']
};
function useTrigger(visible, updateVisible, props, updateVirtualRect) {
  let triggerFocused = false;
  let showTimer;
  let hideTimer;
  const events = ref({});

  function clearTimers() {
    clearTimeout(showTimer);
    clearTimeout(hideTimer);
  }

  const hide = () => {
    if (isBoolean(props.disabled) && props.disabled) return;
    if (isFunction(props.disabled) && props.disabled()) return;
    clearTimers();

    if (props.hideAfter) {
      hideTimer = setTimeout(() => {
        updateVisible(false);
      }, props.hideAfter);
    } else {
      updateVisible(false);
    }
  };

  const show = () => {
    if (isBoolean(props.disabled) && props.disabled) return;
    if (isFunction(props.disabled) && props.disabled()) return;
    clearTimers();

    if (props.showAfter) {
      showTimer = setTimeout(() => {
        updateVisible(true);
      }, props.showAfter);
    } else {
      updateVisible(true);
    }
  };

  const toggleState = () => {
    if (visible.value && !props.onlyShowTrigger) {
      hide();
    } else {
      show();
    }
  };

  const popperEventsHandler = (e, t) => {
    // 
    e.stopPropagation();

    switch (e.type) {
      case 'click':
        {
          if (t === 'contextmenu') {
            if (visible.value) {
              updateVirtualRect(null);
              toggleState();
            }
          } else if (triggerFocused) {
            // reset previous focus event
            triggerFocused = false;
          } else {
            toggleState();
          }

          break;
        }

      case 'mouseenter':
        {
          show();
          break;
        }

      case 'mouseleave':
        {
          hide();
          break;
        }

      case 'focus':
        {
          triggerFocused = true;
          show();
          break;
        }

      case 'blur':
        {
          triggerFocused = false;
          hide();
          break;
        }

      case 'contextmenu':
        {
          updateVirtualRect({
            x: e.clientX,
            y: e.clientY
          });
          e.preventDefault();
          show();
          break;
        }
    }
  };

  const mapEvents = t => {
    const _events = {};
    triggerEventsMap[t].forEach(event => {
      _events[event] = e => {
        popperEventsHandler(e, t);
      };
    });
    events.value = _events;
  };

  watch(() => props.trigger, () => {
    if (props.trigger) {
      mapEvents(props.trigger);
    }
  }, {
    immediate: true
  });

  function onPopperMouseEnter() {
    // if trigger is click, user won't be able to close popper when
    // user tries to move the mouse over popper contents
    if (props.trigger !== 'click') {
      clearTimeout(hideTimer);
    }
  }

  function onPopperMouseLeave() {
    const {
      trigger
    } = props;
    const shouldPrevent = trigger === 'click' || trigger === 'focus' || trigger === 'contextmenu';
    if (shouldPrevent) return;
    hide();
  }

  return {
    events,
    onPopperMouseEnter,
    onPopperMouseLeave
  };
}

const _excluded2 = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "flipAlignment"],
      _excluded4 = ["mainAxis", "crossAxis", "limiter"];

function ownKeys$K(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$K(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$K(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$K(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getSide(placement) {
  return placement.split('-')[0];
}

function getAlignment(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';
}

function getLengthFromAxis(axis) {
  return axis === 'y' ? 'height' : 'width';
}

function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === 'x';
  let coords;

  switch (side) {
    case 'top':
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;

    case 'bottom':
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case 'right':
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case 'left':
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;

    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }

  switch (getAlignment(placement)) {
    case 'start':
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;

    case 'end':
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }

  return coords;
}
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain positioning strategy.
 *
 * This export does not have any `platform` interface logic. You will need to
 * write one for the platform you are using Floating UI with.
 */


const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = 'bottom',
    strategy = 'absolute',
    middleware = [],
    platform
  } = config;
  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
  let { NODE_ENV } = process.env || {}
  if (NODE_ENV !== "production") {
    if (platform == null) {
      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));
    }

    if (middleware.filter(_ref => {
      let {
        name
      } = _ref;
      return name === 'autoPlacement' || name === 'flip';
    }).length > 1) {
      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));
    }
  }

  let rects = await platform.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let _debug_loop_count_ = 0;
  for (let i = 0; i < middleware.length; i++) {
    if (NODE_ENV !== "production") {
      _debug_loop_count_++;

      if (_debug_loop_count_ > 100) {
        throw new Error(['Floating UI: The middleware lifecycle appears to be', 'running in an infinite loop. This is usually caused by a `reset`', 'continually being returned without a break condition.'].join(' '));
      }
    }

    const {
      name,
      fn
    } = middleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = _objectSpread$K(_objectSpread$K({}, middlewareData), {}, {
      [name]: _objectSpread$K(_objectSpread$K({}, middlewareData[name]), data)
    });

    if (reset) {
      if (typeof reset === 'object') {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }

        if (reset.rects) {
          rects = reset.rects === true ? await platform.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }

        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }

      i = -1;
      continue;
    }
  }

  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};

function expandPaddingObject(padding) {
  return _objectSpread$K({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}

function getSideObjectFromPadding(padding) {
  return typeof padding !== 'number' ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}

function rectToClientRect(rect) {
  return _objectSpread$K(_objectSpread$K({}, rect), {}, {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
/**
 * Resolves with an object of overflow side offsets that determine how much the
 * element is overflowing a given clipping boundary.
 * - positive = overflowing the boundary by that number of pixels
 * - negative = how many pixels left before it will overflow
 * - 0 = lies flush with the boundary
 * @see https://floating-ui.com/docs/detectOverflow
 */


async function detectOverflow(middlewareArguments, options) {
  var _await$platform$isEle;

  if (options === void 0) {
    options = {};
  }

  const {
    x,
    y,
    platform,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = 'clippingAncestors',
    rootBoundary = 'viewport',
    elementContext = 'floating',
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === 'floating' ? 'reference' : 'floating';
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform.getClippingRect({
    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),
    boundary,
    rootBoundary,
    strategy
  }));
  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === 'floating' ? _objectSpread$K(_objectSpread$K({}, rects.floating), {}, {
      x,
      y
    }) : rects.reference,
    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
    strategy
  }) : rects[elementContext]); // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}

const min$1 = Math.min;
const max$1 = Math.max;

function within(min$1$1, value, max$1$1) {
  return max$1(min$1$1, min$1(value, max$1$1));
}
/**
 * Positions an inner element of the floating element such that it is centered
 * to the reference element.
 * @see https://floating-ui.com/docs/arrow
 */


const arrow = options => ({
  name: 'arrow',
  options,

  async fn(middlewareArguments) {
    // Since `element` is required, we don't Partial<> the type
    const {
      element,
      padding = 0
    } = options != null ? options : {};
    const {
      x,
      y,
      placement,
      rects,
      platform
    } = middlewareArguments;

    if (element == null) {
        let { NODE_ENV } = process.env || {}
      if (NODE_ENV !== "production") {
        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');
      }

      return {};
    }

    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform.getDimensions(element);
    const minProp = axis === 'y' ? 'top' : 'left';
    const maxProp = axis === 'y' ? 'bottom' : 'right';
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
    const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center
    // point is outside of the floating element's bounds

    const min = paddingObject[minProp];
    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset = within(min, center, max);
    return {
      data: {
        [axis]: offset,
        centerOffset: center - offset
      }
    };
  }

});

const hash$1 = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};

function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);
}

function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }

  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';

  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }

  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}

const hash = {
  start: 'end',
  end: 'start'
};

function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, matched => hash[matched]);
}

function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
/**
 * Changes the placement of the floating element to one that will fit if the
 * initially specified `placement` does not.
 * @see https://floating-ui.com/docs/flip
 */


const flip = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'flip',
    options,

    async fn(middlewareArguments) {
      var _middlewareData$flip;

      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform,
        elements
      } = middlewareArguments;

      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = 'bestFit',
        flipAlignment = true
      } = options,
            detectOverflowOptions = _objectWithoutProperties(options, _excluded2);

      const side = getSide(placement);
      const isBasePlacement = side === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];

      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }

      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
        overflows.push(overflow[main], overflow[cross]);
      }

      overflowsData = [...overflowsData, {
        placement,
        overflows
      }]; // One or more sides is overflowing

      if (!overflows.every(side => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip2;

        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];

        if (nextPlacement) {
          // Try next placement and re-run the lifecycle
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }

        let resetPlacement = 'bottom';

        switch (fallbackStrategy) {
          case 'bestFit':
            {
              var _overflowsData$slice$;

              const placement = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0) - b.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;

              if (placement) {
                resetPlacement = placement;
              }

              break;
            }

          case 'initialPlacement':
            resetPlacement = initialPlacement;
            break;
        }

        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }

      return {};
    }

  };
};

function convertValueToCoords(placement, rects, value, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }

  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === 'x';
  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === 'function' ? value(_objectSpread$K(_objectSpread$K({}, rects), {}, {
    placement
  })) : value;
  const isNumber = typeof rawValue === 'number'; // eslint-disable-next-line prefer-const

  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = isNumber ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : _objectSpread$K({
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null
  }, rawValue);

  if (alignment && typeof alignmentAxis === 'number') {
    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;
  }

  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
/**
 * Displaces the floating element from its reference element.
 * @see https://floating-ui.com/docs/offset
 */


const offset = function (value) {
  if (value === void 0) {
    value = 0;
  }

  return {
    name: 'offset',
    options: value,

    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement,
        rects,
        platform,
        elements
      } = middlewareArguments;
      const diffCoords = convertValueToCoords(placement, rects, value, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }

  };
};

function getCrossAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}
/**
 * Shifts the floating element in order to keep it in view when it will overflow
 * a clipping boundary.
 * @see https://floating-ui.com/docs/shift
 */


const shift = function (options) {
  if (options === void 0) {
    options = {};
  }

  return {
    name: 'shift',
    options,

    async fn(middlewareArguments) {
      const {
        x,
        y,
        placement
      } = middlewareArguments;

      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: _ref => {
            let {
              x,
              y
            } = _ref;
            return {
              x,
              y
            };
          }
        }
      } = options,
            detectOverflowOptions = _objectWithoutProperties(options, _excluded4);

      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];

      if (checkMainAxis) {
        const minSide = mainAxis === 'y' ? 'top' : 'left';
        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';
        const min = mainAxisCoord + overflow[minSide];
        const max = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min, mainAxisCoord, max);
      }

      if (checkCrossAxis) {
        const minSide = crossAxis === 'y' ? 'top' : 'left';
        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';
        const min = crossAxisCoord + overflow[minSide];
        const max = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min, crossAxisCoord, max);
      }

      const limitedCoords = limiter.fn(_objectSpread$K(_objectSpread$K({}, middlewareArguments), {}, {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      }));
      return _objectSpread$K(_objectSpread$K({}, limitedCoords), {}, {
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      });
    }

  };
};

function ownKeys$J(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$J(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$J(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$J(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isWindow(value) {
  return value && value.document && value.location && value.alert && value.setInterval;
}

function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}

function getNodeName(node) {
  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';
}

function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}

function isElement(value) {
  return value instanceof getWindow(value).Element;
}

function isNode(value) {
  return value instanceof getWindow(value).Node;
}

function isShadowRoot(node) {
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

function isOverflowElement(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

function isTableElement(element) {
  return ['table', 'td', 'th'].includes(getNodeName(element));
}

function isContainingBlock(element) {
  // TODO: Try and use feature detection here instead
  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that
  // create a containing block.
  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

  return css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);
}

function isLayoutViewport() {
  // Not Safari
  return !/^((?!chrome|android).)*safari/i.test(navigator.userAgent); // Feature detection for this fails in various ways
  //  Always-visible scrollbar or not
  //  Width of <html>, etc.
  // const vV = win.visualViewport;
  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;
}

const min = Math.min;
const max = Math.max;
const round = Math.round;

function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }

  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;

  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }

  const win = isElement(element) ? getWindow(element) : window;
  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  const x = (clientRect.left + (addVisualOffsets ? win.visualViewport.offsetLeft : 0)) / scaleX;
  const y = (clientRect.top + (addVisualOffsets ? win.visualViewport.offsetTop : 0)) / scaleY;
  const width = clientRect.width / scaleX;
  const height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}

function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}

function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}

function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

function getParentNode(node) {
  if (getNodeName(node) === 'html') {
    return node;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || ( // DOM Element detected
    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement(node) // fallback

  );
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
}

function getContainingBlock(element) {
  let currentNode = getParentNode(element);

  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }

  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

function getDimensions(element) {
  if (isHTMLElement(element)) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  }

  const rect = getBoundingClientRect(element);
  return {
    width: rect.width,
    height: rect.height
  };
}

function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);

  if (offsetParent === documentElement) {
    return rect;
  }

  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {
    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } // This doesn't appear to be need to be negated.
    // else if (documentElement) {
    //   offsets.x = getWindowScrollBarX(documentElement);
    // }

  }

  return _objectSpread$J(_objectSpread$J({}, rect), {}, {
    x: rect.x - scroll.scrollLeft + offsets.x,
    y: rect.y - scroll.scrollTop + offsets.y
  });
}

function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const layoutViewport = isLayoutViewport();

    if (layoutViewport || !layoutViewport && strategy === 'fixed') {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width,
    height,
    x,
    y
  };
} // of the `<html>` and `<body>` rect bounds if horizontally scrollable


function getDocumentRect(element) {
  var _element$ownerDocumen;

  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;

  if (getComputedStyle$1(body || html).direction === 'rtl') {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width,
    height,
    x,
    y
  };
}

function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);

  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {
    // @ts-ignore assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }

  return getNearestOverflowAncestor(parentNode);
}

function getOverflowAncestors(node, list) {
  var _node$ownerDocument;

  if (list === void 0) {
    list = [];
  }

  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
  const updatedList = list.concat(target);
  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here
  updatedList.concat(getOverflowAncestors(getParentNode(target)));
}

function contains(parent, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;

    do {
      // use `===` replace node.isSameNode()
      if (next && parent === next) {
        return true;
      } // @ts-ignore: need a better way to handle this...


      next = next.parentNode || next.host;
    } while (next);
  }

  return false;
}

function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}

function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
  if (clippingParent === 'viewport') {
    return rectToClientRect(getViewportRect(element, strategy));
  }

  if (isElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent, strategy);
  }

  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping ancestor" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingAncestors(element) {
  const clippingAncestors = getOverflowAncestors(element);
  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // @ts-ignore isElement check ensures we return Array<Element>


  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');
} // Gets the maximum area that the element is visible in due to any number of
// clipping ancestors


function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);
  const clippingAncestors = [...mainClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}

const platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getElementRects: _ref => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: _objectSpread$J(_objectSpread$J({}, getDimensions(floating)), {}, {
        x: 0,
        y: 0
      })
    };
  },
  getClientRects: element => Array.from(element.getClientRects()),
  isRTL: element => getComputedStyle$1(element).direction === 'rtl'
};
/**
 * Computes the `x` and `y` coordinates that will place the floating element
 * next to a reference element when it is given a certain CSS positioning
 * strategy.
 */


const computePosition = (reference, floating, options) => computePosition$1(reference, floating, _objectSpread$J({
  platform
}, options));

const PopupManager = {
  zIndex: 2000,

  nextZIndex() {
    return ++PopupManager.zIndex;
  }

};
var PopupManager$1 = PopupManager;

var usePopper = ((props, emit) => {
  const [visible, updateVisible] = useNormalModel(props, emit);
  const virtualRect = ref(null);
  const triggerRef = ref();
  const popperRef = ref();
  const arrowRef = ref();
  const popperStyle = reactive({
    zIndex: PopupManager$1.nextZIndex()
  });
  const placement = ref(props.placement);
  const cacheVisible = ref(true);

  const computePopper = () => {
    if (isBoolean(props.disabled) && props.disabled) return;
    if (isFunction(props.disabled) && props.disabled()) return;
    if (!visible.value) return;
    popperStyle.zIndex = PopupManager$1.nextZIndex();
    nextTick(() => {
      const triggerEl = virtualRect.value ? {
        getBoundingClientRect: () => virtualRect.value && {
          width: 0,
          height: 0,
          top: virtualRect.value.y,
          right: virtualRect.value.x,
          bottom: virtualRect.value.y,
          left: virtualRect.value.x
        },
        contextElement: getElementFromRef(triggerRef.value)
      } : getElementFromRef(triggerRef.value);
      const popperEl = popperRef.value;
      computePosition(triggerEl, popperEl, {
        placement: props.placement,
        middleware: [offset(props.offset), // 
        flip(), // 
        shift(), props.arrow && arrow({
          element: arrowRef.value
        })].filter(Boolean)
      }).then(state => {
        // 
        if (placement.value !== state.placement) {
          cacheVisible.value = false;
          nextTick(() => {
            cacheVisible.value = true;
          });
          placement.value = state.placement;
          return;
        }

        placement.value = state.placement;
        Object.assign(popperEl.style, {
          left: `${state.x}px`,
          top: `${state.y}px`
        });

        if (props.arrow) {
          // Accessing the data
          const {
            x: arrowX,
            y: arrowY
          } = state.middlewareData.arrow;
          const staticSide = {
            top: 'bottom',
            right: 'left',
            bottom: 'top',
            left: 'right'
          }[state.placement.split('-')[0]];
          Object.assign(arrowRef.value.style, {
            left: arrowX != null ? `${arrowX}px` : '',
            top: arrowY != null ? `${arrowY}px` : '',
            right: '',
            bottom: '',
            [staticSide]: '-3px'
          });
        }
      });
    });
  };

  const updateVirtualRect = value => {
    virtualRect.value = value;
  };

  watch(virtualRect, computePopper);
  onMounted(computePopper);
  onActivated(computePopper);
  return {
    visible,
    updateVisible,
    triggerRef,
    popperRef,
    arrowRef,
    popperStyle,
    computePopper,
    updateVirtualRect,
    placement,
    cacheVisible
  };
});

function useScroll(targetRef, onScroll) {
  // scroll related
  let scrollableNodes = [];

  const ensureScrollListener = () => {
    let cursor = targetRef.value;

    while (true) {
      cursor = getScrollParent(cursor);
      if (cursor === null) break;
      scrollableNodes.push(cursor);
    }

    for (const el of scrollableNodes) {
      el.addEventListener('scroll', onScroll, true);
    }
  };

  const removeScrollListeners = () => {
    for (const el of scrollableNodes) {
      el.removeEventListener('scroll', onScroll, true);
    }

    scrollableNodes = [];
  };

  onMounted(() => {
    ensureScrollListener();
  });
  onUnmounted(() => {
    removeScrollListeners();
  });
}

const popperProps = {
  modelValue: {
    type: Boolean,
    default: false
  },
  trigger: {
    type: String,
    default: 'hover'
  },
  placement: {
    type: String,
    default: 'bottom'
  },
  offset: {
    type: Number,
    default: 6
  },
  disabled: {
    type: [Boolean, Function],
    default: false
  },
  arrow: {
    type: Boolean,
    default: false
  },
  appendToContainer: {
    type: Boolean,
    default: true
  },
  popperClass: [String, Array, Object],
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  getContainer: {
    type: Function
  },
  lazy: {
    type: Boolean,
    default: true
  },
  onlyShowTrigger: {
    type: Boolean
  }
};

function ownKeys$I(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$I(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$I(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$I(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$12 = getPrefixCls('popper');
var Popper = defineComponent({
  name: 'FPopper',
  props: popperProps,
  emits: [UPDATE_MODEL_EVENT$1],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    useTheme();

    if (!slots.trigger) {
      throw new Error('[FPopper]: Trigger must be provided');
    }

    const config = useConfig();
    const getContainer = computed(() => {
      var _config$getContainer;

      return props.getContainer || ((_config$getContainer = config.getContainer) === null || _config$getContainer === void 0 ? void 0 : _config$getContainer.value);
    });
    const {
      visible,
      updateVisible,
      triggerRef,
      popperRef,
      arrowRef,
      computePopper,
      popperStyle,
      updateVirtualRect,
      placement,
      cacheVisible
    } = usePopper(props, emit);
    const disabledWatch = computed(() => (isBoolean(props.disabled) ? props.disabled : false) || !visible.value);
    const triggerElement = computed(() => {
      const elm = getElementFromRef(triggerRef.value);

      if (elm instanceof Text) {
        throw TypeError(`FPopper: trigger must be a Element, but get Text(${elm.nodeValue})`);
      }

      return elm;
    });
    useScroll(triggerElement, e => {
      var _getContainer$value;

      if (disabledWatch.value) return;
      if (isFunction(props.disabled) && props.disabled()) return; // container

      if (!props.appendToContainer) return;
      if (e.target === ((_getContainer$value = getContainer.value) === null || _getContainer$value === void 0 ? void 0 : _getContainer$value.call(getContainer))) return;
      computePopper();
    });
    useClickOutSide([triggerRef, popperRef], () => {
      updateVisible(false);
    }, disabledWatch);
    useResize(triggerElement, computePopper, disabledWatch);
    useResize(computed(() => getElementFromRef(popperRef.value)), computePopper, disabledWatch);
    const {
      events,
      onPopperMouseEnter,
      onPopperMouseLeave
    } = useTrigger(visible, updateVisible, props, updateVirtualRect);
    const popperClass = computed(() => [prefixCls$12, props.popperClass].filter(Boolean));

    const renderTrigger = () => {
      var _slots$trigger;

      const vNode = getFirstValidNode((_slots$trigger = slots.trigger) === null || _slots$trigger === void 0 ? void 0 : _slots$trigger.call(slots));

      if (vNode) {
        return cloneVNode(vNode, _objectSpread$I({
          ref: triggerRef
        }, events.value), true);
      }
    };

    const Content = () => {
      var _slots$default;

      return createVNode("div", {
        "class": popperClass.value
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots), props.arrow && createVNode("div", {
        "ref": arrowRef,
        "class": `${prefixCls$12}-arrow`
      }, null)]);
    };

    const transitionName = computed(() => {
      const placementValue = placement.value;
      const MAP = {
        bottom: 'up',
        top: 'down',
        left: 'right',
        right: 'left'
      };
      return `fes-slide-${MAP[placementValue.split('-')[0]]}`;
    });
    return () => {
      var _getContainer$value2;

      return createVNode(Fragment, null, [renderTrigger(), createVNode(LazyTeleport, {
        "to": (_getContainer$value2 = getContainer.value) === null || _getContainer$value2 === void 0 ? void 0 : _getContainer$value2.call(getContainer),
        "disabled": !props.appendToContainer,
        "show": !props.lazy || visible.value
      }, {
        default: () => [createVNode("div", {
          "ref": popperRef,
          "class": `${prefixCls$12}-wrapper`,
          "style": popperStyle,
          "role": 'tooltip',
          "onMouseenter": onPopperMouseEnter,
          "onMouseleave": onPopperMouseLeave
        }, [createVNode(Transition, {
          "name": transitionName.value,
          "appear": true,
          "onBeforeEnter": computePopper
        }, {
          default: () => [withDirectives(createVNode(Content, null, null), [[vShow, visible.value && cacheVisible.value]])]
        })])]
      })]);
    };
  }

});

const prefixCls$11 = getPrefixCls('dropdown');
const dropdownProps = {
  visible: {
    type: Boolean,
    default: false
  },
  appendToContainer: {
    type: Boolean,
    default: true
  },
  getContainer: {
    type: Function
  },
  trigger: {
    type: String,
    default: 'hover'
  },
  placement: {
    type: String,
    default: 'bottom'
  },
  offset: {
    type: Number,
    default: 6
  },
  options: {
    type: Array,

    default() {
      return [];
    }

  },
  disabled: {
    type: Boolean,
    default: false
  },
  valueField: {
    type: String,
    default: 'value'
  },
  labelField: {
    type: String,
    default: 'label'
  },
  arrow: {
    type: Boolean,
    default: false
  }
};
var Dropdown = defineComponent({
  name: 'FDropdown',
  props: dropdownProps,
  emits: ['click', 'visibleChange', 'update:visible'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    useTheme();
    const [visible, updateVisible] = useNormalModel(props, emit, {
      prop: 'visible'
    });
    const hasIcon = computed(() => props.options.some(option => option.icon));

    const handleClick = option => {
      if (option.disabled) return;
      const value = option[props.valueField];
      updateVisible(false);
      emit('click', value);
    };

    watch(visible, () => {
      emit('visibleChange', visible.value);
    });

    const renderOptions = () => createVNode("div", {
      "class": `${prefixCls$11}-option-wrapper ${hasIcon.value ? 'has-icon' : ''}`
    }, [props.options.map(option => {
      var _option$icon;

      const optionClassList = [`${prefixCls$11}-option`, option.disabled && 'is-disabled'].filter(Boolean).join(' ');
      const label = option[props.labelField];
      return createVNode("div", {
        "class": optionClassList,
        "onClick": () => {
          handleClick(option);
        }
      }, [createVNode("span", {
        "class": `${prefixCls$11}-option-icon`
      }, [(_option$icon = option.icon) === null || _option$icon === void 0 ? void 0 : _option$icon.call(option)]), createVNode("span", {
        "class": `${prefixCls$11}-option-label`
      }, [isFunction(label) ? label(option) : label])]);
    })]);

    return () => createVNode(Popper, {
      "modelValue": visible.value,
      "onUpdate:modelValue": $event => visible.value = $event,
      "trigger": props.trigger,
      "placement": props.placement,
      "popperClass": `${prefixCls$11}-popper`,
      "appendToContainer": props.appendToContainer,
      "getContainer": props.getContainer,
      "offset": props.offset,
      "disabled": props.disabled,
      "arrow": props.arrow
    }, {
      default: renderOptions,
      trigger: slots.default
    });
  }

});

const FDropdown = withInstall(Dropdown);

function ownKeys$H(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$H(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$H(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$H(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$10 = getPrefixCls('tooltip');
const defaultConfirmOption = {
  okText: '',
  cancelText: '',
  icon: createVNode(ExclamationCircleFilled, null, null)
};

const toolTipProps = _objectSpread$H(_objectSpread$H({}, popperProps), {}, {
  title: [Number, String],
  content: [Number, String],
  mode: {
    type: String,
    default: 'text'
  },
  confirmOption: {
    type: Object,
    default: () => defaultConfirmOption
  },
  arrow: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 8
  }
});

var Tooltip = defineComponent({
  name: 'FTooltip',
  props: toolTipProps,
  emits: [OK_EVENT$2, CANCEL_EVENT$2, UPDATE_MODEL_EVENT$1],

  setup(props, ctx) {
    useTheme();
    const [currentValue, updateCurrentValue] = useNormalModel(props, ctx.emit);

    function getPopperSlots() {
      return {
        trigger: ctx.slots.default
      };
    }

    function handleConfirmCB(name, event) {
      updateCurrentValue(false);
      ctx.emit(name, event);
    }

    function renderContent() {
      var _ctx$slots$content, _ctx$slots, _ctx$slots$content2, _ctx$slots$title, _ctx$slots2, _ctx$slots2$title;

      const content = (_ctx$slots$content = (_ctx$slots = ctx.slots) === null || _ctx$slots === void 0 ? void 0 : (_ctx$slots$content2 = _ctx$slots.content) === null || _ctx$slots$content2 === void 0 ? void 0 : _ctx$slots$content2.call(_ctx$slots)) !== null && _ctx$slots$content !== void 0 ? _ctx$slots$content : props.content;
      const title = (_ctx$slots$title = (_ctx$slots2 = ctx.slots) === null || _ctx$slots2 === void 0 ? void 0 : (_ctx$slots2$title = _ctx$slots2.title) === null || _ctx$slots2$title === void 0 ? void 0 : _ctx$slots2$title.call(_ctx$slots2)) !== null && _ctx$slots$title !== void 0 ? _ctx$slots$title : props.title;
      const isConfirm = props.mode === 'confirm';
      const isPopover = props.mode === 'popover';

      if (props.mode === 'text') {
        return content;
      }

      if (isConfirm || isPopover) {
        const mergeOpt = _objectSpread$H(_objectSpread$H({}, defaultConfirmOption), props.confirmOption);

        const contentClass = [`${prefixCls$10}-modal-body`, isConfirm && 'is-confirm', title && 'has-header'].filter(Boolean).join(' ');
        return createVNode(Fragment, null, [title && createVNode("div", {
          "class": `${prefixCls$10}-modal-header ${isConfirm && 'is-confirm'}`
        }, [isConfirm && createVNode("div", {
          "class": `${prefixCls$10}-modal-icon`
        }, [mergeOpt.icon]), title]), !isNil(content) ? createVNode("div", {
          "class": contentClass
        }, [content]) : content, isConfirm && createVNode(Fragment, null, [createVNode(FButton$1, {
          "class": `${prefixCls$10}-modal-btn`,
          "onClick": event => handleConfirmCB(OK_EVENT$2, event),
          "size": "small",
          "type": "primary"
        }, {
          default: () => [mergeOpt.okText]
        }), createVNode(FButton$1, {
          "class": `${prefixCls$10}-modal-btn`,
          "onClick": event => handleConfirmCB(CANCEL_EVENT$2, event),
          "size": "small"
        }, {
          default: () => [mergeOpt.cancelText]
        })])]);
      }
    }

    const popperPropsRef = computed(() => {
      const _props = {};
      Object.keys(popperProps).forEach(key => {
        _props[key] = props[key];
      });

      if (props.mode === 'confirm') {
        // confirm
        _props.trigger = 'click';
      }

      return _props;
    });
    return () => {
      return createVNode(Popper, mergeProps(popperPropsRef.value, {
        "modelValue": currentValue.value,
        "onUpdate:modelValue": $event => currentValue.value = $event,
        "popperClass": [prefixCls$10, `${prefixCls$10}-${props.mode}`, popperPropsRef.value.popperClass]
      }), _objectSpread$H({
        default: () => [renderContent()]
      }, getPopperSlots()));
    };
  }

});

const FTooltip = withInstall(Tooltip);

const prefixCls$$ = getPrefixCls('ellipsis');
const ellipsisProps = {
  content: [Number, String],
  line: {
    type: [Number, String],
    default: 1
  },
  tooltip: {
    type: [Boolean, Object],
    default: () => ({
      showAfter: 500
    })
  },
  class: [String, Array, Object],
  style: {
    type: [String, Array, Object],

    default() {
      return {};
    }

  }
};
var Ellipsis = defineComponent({
  name: 'FEllipsis',
  components: {
    Tooltip: FTooltip
  },
  props: ellipsisProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useTheme();
    const triggerRef = ref();
    const triggerInnerRef = ref();
    const classListRef = computed(() => [prefixCls$$, props.class].filter(Boolean));
    const line = computed(() => {
      return Number(props.line);
    });
    const styleRef = computed(() => {
      const ellStyle = line.value > 1 ? {
        display: '-webkit-inline-box',
        '-webkit-line-clamp': line.value,
        '-webkit-box-orient': 'vertical'
      } : {
        'text-overflow': 'ellipsis',
        'white-space': 'nowrap'
      };
      return [props.style, ellStyle];
    });
    const toolTipPropsRef = computed(() => {
      if (isObject(props.tooltip)) {
        return props.tooltip;
      }

      return {};
    }); // hover

    const getDisabled = () => {
      let isEllipsis = true;
      const {
        value: trigger
      } = triggerRef;
      if (!trigger) return true;
      const {
        offsetHeight,
        scrollHeight,
        offsetWidth
      } = trigger;

      if (offsetHeight && offsetWidth) {
        if (line.value > 1) {
          isEllipsis = scrollHeight > offsetHeight;
        } else {
          const {
            value: triggerInner
          } = triggerInnerRef;
          isEllipsis = triggerInner.getBoundingClientRect().width > trigger.getBoundingClientRect().width;
        }
      }

      return !isEllipsis;
    };

    const renderTrigger = () => {
      var _slots$default, _slots$default2, _slots$default3, _slots$default4;

      return createVNode("span", {
        "ref": triggerRef,
        "class": classListRef.value,
        "style": styleRef.value
      }, [line.value > 1 ? (_slots$default = (_slots$default2 = slots.default) === null || _slots$default2 === void 0 ? void 0 : _slots$default2.call(slots)) !== null && _slots$default !== void 0 ? _slots$default : props.content : createVNode("span", {
        "ref": triggerInnerRef
      }, [(_slots$default3 = (_slots$default4 = slots.default) === null || _slots$default4 === void 0 ? void 0 : _slots$default4.call(slots)) !== null && _slots$default3 !== void 0 ? _slots$default3 : props.content])]);
    };

    const renderContent = () => {
      return props.content;
    };

    return () => {
      var _ref2, _slots$tooltip;

      if (!props.tooltip) {
        return renderTrigger();
      }

      return createVNode(FTooltip, mergeProps({
        "placement": "top",
        "disabled": getDisabled
      }, toolTipPropsRef.value), {
        default: () => [renderTrigger()],
        content: (_ref2 = (_slots$tooltip = slots.tooltip) !== null && _slots$tooltip !== void 0 ? _slots$tooltip : slots.default) !== null && _ref2 !== void 0 ? _ref2 : renderContent
      });
    };
  }

});

const FEllipsis = withInstall(Ellipsis);

const ALIGN = ['flex-start', 'center', 'flex-end', 'baseline', 'stretch'];
const JUSTIFY = ['flex-start', 'flex-end', 'center', 'space-around', 'space-between'];
const GRID_KEY = Symbol('FGrid');

function ownKeys$G(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$G(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$G(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$G(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const __default__$2 = {
  name: 'FGrid'
};
var script$A = /*#__PURE__*/defineComponent(_objectSpread$G(_objectSpread$G({}, __default__$2), {}, {
  props: {
    align: {
      type: null,
      required: false,
      default: ALIGN[0]
    },
    gutter: {
      type: [Number, Array],
      required: false,
      default: 0
    },
    justify: {
      type: null,
      required: false,
      default: JUSTIFY[0]
    },
    wrap: {
      type: Boolean,
      required: false,
      default: false
    }
  },

  setup(__props) {
    const props = __props;
    const prefixCls = getPrefixCls('grid');
    useTheme();
    const gutterX = computed(() => {
      if (isArray$1(props.gutter)) {
        return props.gutter[0];
      }

      return props.gutter;
    });
    const gutterY = computed(() => {
      if (isArray$1(props.gutter)) {
        return props.gutter[1];
      }

      return 0;
    });
    const style = computed(() => {
      const _style = {
        'flex-wrap': props.wrap ? 'wrap' : 'nowrap',
        'justify-content': props.justify,
        'align-items': props.align
      };

      if (gutterX.value) {
        _style['margin-left'] = `-${gutterX.value / 2}px`;
        _style['margin-right'] = `-${gutterX.value / 2}px`;
      }

      if (gutterY.value) {
        _style['row-gap'] = `${gutterY.value}px`;
      }

      return _style;
    });
    const classList = computed(() => {
      const arr = [prefixCls];
      return arr;
    });
    provide(GRID_KEY, {
      gutterX
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(classList)),
        style: normalizeStyle(unref(style))
      }, [renderSlot(_ctx.$slots, "default")], 6
      /* CLASS, STYLE */
      );
    };
  }

}));

script$A.__file = "components/grid/grid.vue";

function ownKeys$F(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$F(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$F(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$F(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const __default__$1 = {
  name: 'FGridItem'
};
var script$z = /*#__PURE__*/defineComponent(_objectSpread$F(_objectSpread$F({}, __default__$1), {}, {
  props: {
    flex: {
      type: [String, Number],
      required: false
    },
    offset: {
      type: Number,
      required: false,
      default: 0
    },
    pull: {
      type: Number,
      required: false,
      default: 0
    },
    push: {
      type: Number,
      required: false,
      default: 0
    },
    span: {
      type: Number,
      required: false,
      default: 0
    },
    order: {
      type: Number,
      required: false,
      default: 0
    }
  },

  setup(__props) {
    const props = __props;
    const prefixCls = getPrefixCls('grid-item');

    function parseFlex(flex) {
      if (typeof flex === 'number') {
        return `${flex} ${flex} auto`;
      }

      if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
        return `0 0 ${flex}`;
      }

      return flex;
    }

    const rowProps = inject(GRID_KEY, {
      gutterX: {
        value: 0
      }
    });
    const classList = computed(() => [prefixCls, props.offset && `${prefixCls}-offset-${props.offset}`, props.pull && `${prefixCls}-pull-${props.pull}`, props.push && `${prefixCls}-push-${props.push}`, `${prefixCls}-${props.span}`].filter(Boolean));
    const style = computed(() => {
      var _rowProps$gutterX;

      const _style = {};

      if (props.flex) {
        _style.flex = parseFlex(props.flex);
      }

      if ((_rowProps$gutterX = rowProps.gutterX) !== null && _rowProps$gutterX !== void 0 && _rowProps$gutterX.value) {
        _style['padding-left'] = `${rowProps.gutterX.value / 2}px`;
        _style['padding-right'] = `${rowProps.gutterX.value / 2}px`;
      }

      if (props.order) {
        _style['order'] = props.order;
      }

      return _style;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(classList)),
        style: normalizeStyle(unref(style))
      }, [renderSlot(_ctx.$slots, "default")], 6
      /* CLASS, STYLE */
      );
    };
  }

}));

script$z.__file = "components/grid/gridItem.vue";

const FGrid = withInstall(script$A, {
  GridItem: script$z
});
const FGridItem = withNoopInstall(script$z);

function useInput$1(updateValue) {
  const isComposing = ref(false);

  const handleInput = event => {
    if (!isComposing.value) {
      if (event instanceof Event) {
        const {
          value
        } = event.target;
        updateValue(value);
      } else {
        updateValue(event);
      }
    }
  };

  const handleCompositionStart = () => {
    isComposing.value = true;
  };

  const handleCompositionEnd = event => {
    if (isComposing.value) {
      isComposing.value = false;
      handleInput(event);
    }
  };

  return {
    handleInput,
    handleCompositionStart,
    handleCompositionEnd
  };
}

let hiddenTextarea;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue('box-sizing');
  const paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
  const borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
  const contextStyle = CONTEXT_STYLE.map(name => `${name}:${style.getPropertyValue(name)}`).join(';');
  return {
    contextStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
}

function calcTextareaHeight(targetElement) {
  var _hiddenTextarea$paren;

  let minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  let maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  }

  const {
    paddingSize,
    borderSize,
    boxSizing,
    contextStyle
  } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute('style', `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';
  let height = hiddenTextarea.scrollHeight;
  const result = {
    height: ''
  };

  if (boxSizing === 'border-box') {
    height = height + borderSize;
  } else if (boxSizing === 'content-box') {
    height = height - paddingSize;
  }

  hiddenTextarea.value = '';
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

  if (minRows !== null) {
    let minHeight = singleRowHeight * minRows;

    if (boxSizing === 'border-box') {
      minHeight = minHeight + paddingSize + borderSize;
    }

    height = Math.max(minHeight, height);
    result.minHeight = `${minHeight}px`;
  }

  if (maxRows !== null) {
    let maxHeight = singleRowHeight * maxRows;

    if (boxSizing === 'border-box') {
      maxHeight = maxHeight + paddingSize + borderSize;
    }

    height = Math.min(maxHeight, height);
  }

  result.height = `${height}px`;
  (_hiddenTextarea$paren = hiddenTextarea.parentNode) === null || _hiddenTextarea$paren === void 0 ? void 0 : _hiddenTextarea$paren.removeChild(hiddenTextarea);
  hiddenTextarea = null;
  return result;
}

function useFocus(emit, validate) {
  const focused = ref(false);

  const handleFocus = event => {
    focused.value = true;
    emit('focus', event);
  };

  const handleBlur = event => {
    focused.value = false;
    emit('blur', event);
    validate('blur');
  };

  return {
    focused,
    handleFocus,
    handleBlur
  };
}
function useMouse$1(emit) {
  const hovering = ref(false);

  const onMouseLeave = e => {
    hovering.value = false;
    emit('mouseleave', e);
  };

  const onMouseEnter = e => {
    hovering.value = true;
    emit('mouseenter', e);
  };

  return {
    hovering,
    onMouseLeave,
    onMouseEnter
  };
}

const commonInputProps = {
  modelValue: {
    type: [Number, String]
  },
  type: {
    type: String,
    default: 'text'
  },
  placeholder: {
    type: String
  },
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  maxlength: {
    type: Number
  },
  showPassword: {
    type: Boolean,
    default: false
  },
  inputStyle: {
    type: Object,
    default: () => ({})
  },
  autocomplete: {
    type: String,
    default: 'off'
  }
};

function ownKeys$E(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$E(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$E(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$E(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const inputInnerProps = _objectSpread$E(_objectSpread$E({}, commonInputProps), {}, {
  //  input focus 
  innerIsFocus: Boolean,
  innerIsError: Boolean,
  canEdit: {
    type: Boolean,
    default: true
  }
});

const prefixCls$_ = getPrefixCls('input-inner');
function usePassword(currentValue, props, focused) {
  const passwordVisible = ref(false);

  const handlePasswordVisible = () => {
    passwordVisible.value = !passwordVisible.value;
  };

  const showPwdSwitchIcon = computed(() => props.showPassword && !props.readonly && !props.disabled && (currentValue.value != null || focused.value));
  return {
    passwordVisible,
    handlePasswordVisible,
    showPwdSwitchIcon
  };
}
function useClear(currentValue, props, focused, hovering, handleValueChange, emit) {
  const showClear = computed(() => props.clearable && !props.readonly && !props.disabled && currentValue.value && (focused.value || hovering.value));

  const clear = () => {
    if (currentValue.value !== '') {
      handleValueChange('');
    }

    emit('clear');
  };

  return {
    showClear,
    clear
  };
}
var script$y = defineComponent({
  name: 'FInputInner',
  components: {
    EyeOutlined,
    EyeInvisibleOutlined,
    CloseCircleFilled
  },
  props: inputInnerProps,
  emits: [UPDATE_MODEL_EVENT$1, 'input', 'focus', 'blur', 'change', 'clear', 'keydown', 'mouseleave', 'mouseenter'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const inputRefEl = ref();
    const [currentValue, updateCurrentValue] = useNormalModel(props, emit);
    const suffixVisible = computed(() => slots.suffix || props.showPassword || props.clearable);

    const handleValueChange = value => {
      updateCurrentValue(value);
      emit('input', value);
    };

    const focused = ref(false);

    const handleFocus = event => {
      focused.value = true;
      emit('focus', event);
    };

    const handleBlur = event => {
      focused.value = false;
      emit('blur', event);
    };

    const {
      hovering,
      onMouseLeave,
      onMouseEnter
    } = useMouse$1(emit);

    const handleChange = event => {
      const {
        value
      } = event.target;
      emit('change', value);
    };

    const handleKeydown = e => {
      emit('keydown', e);
    };

    const {
      showClear,
      clear
    } = useClear(currentValue, props, focused, hovering, handleValueChange, emit);

    const focus = () => {
      inputRefEl.value.focus();
    };

    const blur = () => {
      inputRefEl.value.blur();
    };

    const handleMousedown = e => {
      if (props.disabled) return;
      const {
        tagName
      } = e.target;

      if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {
        e.preventDefault();

        if (!focused.value) {
          focus();
        }
      }
    };

    return _objectSpread$E(_objectSpread$E({
      inputRefEl,
      // 
      focus,
      blur,
      focused,
      handleFocus,
      handleBlur,
      showClear,
      clear,
      handleChange,
      onMouseLeave,
      onMouseEnter,
      handleMousedown,
      handleKeydown,
      prefixCls: prefixCls$_,
      suffixVisible,
      currentValue
    }, useInput$1(handleValueChange)), usePassword(currentValue, props, focused));
  }

});

const _hoisted_1$a = ["tabindex", "value", "maxlength", "type", "readonly", "disabled", "placeholder", "autocomplete"];
function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CloseCircleFilled = resolveComponent("CloseCircleFilled");

  const _component_EyeOutlined = resolveComponent("EyeOutlined");

  const _component_EyeInvisibleOutlined = resolveComponent("EyeInvisibleOutlined");

  return openBlock(), createElementBlock("span", {
    class: normalizeClass([_ctx.prefixCls, (_ctx.focused || _ctx.innerIsFocus) && `${_ctx.prefixCls}-focus`, _ctx.disabled && `${_ctx.prefixCls}-disabled`, _ctx.innerIsError && `${_ctx.prefixCls}-error`]),
    onMousedown: _cache[9] || (_cache[9] = function () {
      return _ctx.handleMousedown && _ctx.handleMousedown(...arguments);
    }),
    onMouseenter: _cache[10] || (_cache[10] = function () {
      return _ctx.onMouseEnter && _ctx.onMouseEnter(...arguments);
    }),
    onMouseleave: _cache[11] || (_cache[11] = function () {
      return _ctx.onMouseLeave && _ctx.onMouseLeave(...arguments);
    })
  }, [createCommentVNode("  "), _ctx.$slots.prefix ? (openBlock(), createElementBlock("span", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-prefix`)
  }, [renderSlot(_ctx.$slots, "prefix")], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), createElementVNode("input", {
    ref: "inputRefEl",
    tabindex: !_ctx.disabled ? 0 : undefined,
    value: _ctx.currentValue,
    maxlength: _ctx.maxlength,
    type: _ctx.showPassword ? _ctx.passwordVisible ? 'text' : 'password' : _ctx.type,
    readonly: !_ctx.canEdit || _ctx.readonly,
    disabled: _ctx.disabled,
    placeholder: _ctx.placeholder,
    autocomplete: _ctx.autocomplete,
    style: normalizeStyle(_ctx.inputStyle),
    class: normalizeClass(`${_ctx.prefixCls}-el`),
    onCompositionstart: _cache[0] || (_cache[0] = function () {
      return _ctx.handleCompositionStart && _ctx.handleCompositionStart(...arguments);
    }),
    onCompositionend: _cache[1] || (_cache[1] = function () {
      return _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...arguments);
    }),
    onInput: _cache[2] || (_cache[2] = function () {
      return _ctx.handleInput && _ctx.handleInput(...arguments);
    }),
    onChange: _cache[3] || (_cache[3] = function () {
      return _ctx.handleChange && _ctx.handleChange(...arguments);
    }),
    onKeydown: [_cache[4] || (_cache[4] = withKeys(function () {
      return _ctx.handleChange && _ctx.handleChange(...arguments);
    }, ["enter"])), _cache[7] || (_cache[7] = function () {
      return _ctx.handleKeydown && _ctx.handleKeydown(...arguments);
    })],
    onFocus: _cache[5] || (_cache[5] = function () {
      return _ctx.handleFocus && _ctx.handleFocus(...arguments);
    }),
    onBlur: _cache[6] || (_cache[6] = function () {
      return _ctx.handleBlur && _ctx.handleBlur(...arguments);
    })
  }, null, 46
  /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
  , _hoisted_1$a), createCommentVNode("  "), _ctx.suffixVisible ? (openBlock(), createElementBlock("span", {
    key: 1,
    class: normalizeClass(`${_ctx.prefixCls}-suffix`),
    onMousedown: _cache[8] || (_cache[8] = withModifiers(() => {}, ["prevent"]))
  }, [!_ctx.showClear && !_ctx.showPwdSwitchIcon ? renderSlot(_ctx.$slots, "suffix", {
    key: 0
  }) : createCommentVNode("v-if", true), _ctx.showClear ? (openBlock(), createBlock(_component_CloseCircleFilled, {
    key: 1,
    class: normalizeClass(`${_ctx.prefixCls}-icon`),
    onClick: withModifiers(_ctx.clear, ["stop"])
  }, null, 8
  /* PROPS */
  , ["class", "onClick"])) : createCommentVNode("v-if", true), _ctx.showPwdSwitchIcon ? (openBlock(), createElementBlock(Fragment, {
    key: 2
  }, [_ctx.passwordVisible ? (openBlock(), createBlock(_component_EyeOutlined, {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-icon`),
    onClick: withModifiers(_ctx.handlePasswordVisible, ["stop"])
  }, null, 8
  /* PROPS */
  , ["class", "onClick"])) : (openBlock(), createBlock(_component_EyeInvisibleOutlined, {
    key: 1,
    class: normalizeClass(`${_ctx.prefixCls}-icon`),
    onClick: withModifiers(_ctx.handlePasswordVisible, ["stop"])
  }, null, 8
  /* PROPS */
  , ["class", "onClick"]))], 64
  /* STABLE_FRAGMENT */
  )) : createCommentVNode("v-if", true)], 34
  /* CLASS, HYDRATE_EVENTS */
  )) : createCommentVNode("v-if", true)], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

script$y.render = render$v;
script$y.__file = "components/input/inputInner.vue";

function ownKeys$D(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$D(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$D(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$D(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$Z = getPrefixCls('input');
const textareaPrefixCls = getPrefixCls('textarea');

const inputProps = _objectSpread$D(_objectSpread$D({}, commonInputProps), {}, {
  rows: {
    type: Number,
    default: 2
  },
  showWordLimit: {
    type: Boolean,
    default: false
  },
  autosize: {
    type: [Boolean, Object],
    default: false
  },
  resize: String
});

function useWordLimit(currentValue, props) {
  const isWordLimitVisible = computed(() => props.showWordLimit && props.maxlength && !props.disabled);
  const textLength = computed(() => {
    var _currentValue$value;

    return ((_currentValue$value = currentValue.value) === null || _currentValue$value === void 0 ? void 0 : _currentValue$value.toString().length) || 0;
  });
  return {
    isWordLimitVisible,
    textLength
  };
}
var script$x = defineComponent({
  name: 'FInput',
  components: {
    InputInner: script$y
  },
  props: inputProps,
  emits: [UPDATE_MODEL_EVENT$1, 'change', 'input', 'keydown', 'blur', 'focus', 'clear', 'mouseleave', 'mouseenter'],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    useTheme();
    const {
      validate,
      isError,
      isFormDisabled
    } = useFormAdaptor();
    const inputRef = ref();
    const textareaRef = ref();
    const {
      handleFocus,
      handleBlur
    } = useFocus(emit, validate);
    const {
      onMouseLeave,
      onMouseEnter
    } = useMouse$1(emit);
    const [currentValue, updateCurrentValue] = useNormalModel(props, emit);

    const handleChange = value => {
      emit('change', value);
    };

    const handleTextareaChange = event => {
      const {
        value
      } = event.target;
      handleChange(value);
    };

    const handleValueChange = value => {
      updateCurrentValue(value);
      emit('input', value); //  form Input  input  change 

      validate('input');
      validate('change');
    };

    const classes = computed(() => [props.type === 'textarea' ? textareaPrefixCls : prefixCls$Z, {
      'is-error': isError.value,
      [`${prefixCls$Z}-group`]: slots.prepend || slots.append,
      [`${prefixCls$Z}-group-prepend`]: slots.prepend,
      [`${prefixCls$Z}-group-append`]: slots.append
    }]);
    const innerDisabled = computed(() => props.disabled || isFormDisabled.value);
    const textareaCalcStyle = shallowRef(props.inputStyle);
    const textareaStyle = computed(() => [props.inputStyle, textareaCalcStyle.value, {
      resize: props.resize
    }]);

    const resizeTextarea = () => {
      const {
        type,
        autosize
      } = props;
      if (type !== 'textarea' || !textareaRef.value) return;

      if (autosize) {
        let minRows;
        let maxRows;

        if (typeof autosize === 'object') {
          minRows = autosize.minRows;
          maxRows = autosize.maxRows;
        }

        textareaCalcStyle.value = _objectSpread$D({}, calcTextareaHeight(textareaRef.value, minRows, maxRows));
      } else {
        textareaCalcStyle.value = {
          minHeight: calcTextareaHeight(textareaRef.value).minHeight
        };
      }
    };

    watch(() => props.modelValue, () => {
      nextTick(resizeTextarea);
    });
    onMounted(() => {
      nextTick(resizeTextarea);
    });

    const handleKeydown = e => {
      emit('keydown', e);
    };

    const currentInput = computed(() => props.type === 'textarea' ? textareaRef.value : inputRef.value);

    const focus = () => {
      currentInput.value.focus();
    };

    const blur = () => {
      currentInput.value.blur();
    };

    return _objectSpread$D(_objectSpread$D({
      innerDisabled,
      isError,
      inputRef,
      textareaRef,
      prefixCls: prefixCls$Z,
      textareaPrefixCls,
      classes,
      currentValue
    }, useInput$1(handleValueChange)), {}, {
      handleFocus,
      handleBlur,
      focus,
      blur,
      handleTextareaChange,
      handleChange,
      handleKeydown,
      onMouseLeave,
      onMouseEnter,
      textareaStyle,
      resizeTextarea
    }, useWordLimit(currentValue, props));
  }

});

const _hoisted_1$9 = ["value", "readonly", "disabled", "autocomplete", "maxlength", "placeholder", "rows"];
function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_InputInner = resolveComponent("InputInner");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    onMouseenter: _cache[7] || (_cache[7] = function () {
      return _ctx.onMouseEnter && _ctx.onMouseEnter(...arguments);
    }),
    onMouseleave: _cache[8] || (_cache[8] = function () {
      return _ctx.onMouseLeave && _ctx.onMouseLeave(...arguments);
    })
  }, [_ctx.type !== 'textarea' ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [_ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-prepend`)
  }, [renderSlot(_ctx.$slots, "prepend")], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), createVNode(_component_InputInner, {
    ref: "inputRef",
    modelValue: _ctx.currentValue,
    type: _ctx.type,
    placeholder: _ctx.placeholder,
    readonly: _ctx.readonly,
    disabled: _ctx.innerDisabled,
    clearable: _ctx.clearable,
    maxlength: _ctx.maxlength,
    showPassword: _ctx.showPassword,
    inputStyle: _ctx.inputStyle,
    autocomplete: _ctx.autocomplete,
    innerIsError: _ctx.isError,
    onInput: _ctx.handleInput,
    onChange: _ctx.handleChange,
    onFocus: _ctx.handleFocus,
    onBlur: _ctx.handleBlur,
    onKeydown: _ctx.handleKeydown
  }, createSlots({
    _: 2
    /* DYNAMIC */

  }, [_ctx.$slots.prefix ? {
    name: "prefix",
    fn: withCtx(() => [renderSlot(_ctx.$slots, "prefix")]),
    key: "0"
  } : undefined, _ctx.$slots.suffix || _ctx.isWordLimitVisible ? {
    name: "suffix",
    fn: withCtx(() => [renderSlot(_ctx.$slots, "suffix"), _ctx.isWordLimitVisible ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-count`)
    }, toDisplayString(_ctx.textLength) + "/" + toDisplayString(_ctx.maxlength), 3
    /* TEXT, CLASS */
    )) : createCommentVNode("v-if", true)]),
    key: "1"
  } : undefined]), 1032
  /* PROPS, DYNAMIC_SLOTS */
  , ["modelValue", "type", "placeholder", "readonly", "disabled", "clearable", "maxlength", "showPassword", "inputStyle", "autocomplete", "innerIsError", "onInput", "onChange", "onFocus", "onBlur", "onKeydown"]), _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(`${_ctx.prefixCls}-append`)
  }, [renderSlot(_ctx.$slots, "append")], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true)], 64
  /* STABLE_FRAGMENT */
  )) : (openBlock(), createElementBlock("textarea", {
    key: 1,
    ref: "textareaRef",
    value: _ctx.currentValue,
    style: normalizeStyle(_ctx.textareaStyle),
    class: normalizeClass(`${_ctx.textareaPrefixCls}-inner`),
    readonly: _ctx.readonly,
    disabled: _ctx.innerDisabled,
    autocomplete: _ctx.autocomplete,
    maxlength: _ctx.maxlength,
    placeholder: _ctx.placeholder,
    rows: _ctx.rows,
    onCompositionstart: _cache[0] || (_cache[0] = function () {
      return _ctx.handleCompositionStart && _ctx.handleCompositionStart(...arguments);
    }),
    onCompositionend: _cache[1] || (_cache[1] = function () {
      return _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...arguments);
    }),
    onInput: _cache[2] || (_cache[2] = function () {
      return _ctx.handleInput && _ctx.handleInput(...arguments);
    }),
    onChange: _cache[3] || (_cache[3] = function () {
      return _ctx.handleTextareaChange && _ctx.handleTextareaChange(...arguments);
    }),
    onFocus: _cache[4] || (_cache[4] = function () {
      return _ctx.handleFocus && _ctx.handleFocus(...arguments);
    }),
    onBlur: _cache[5] || (_cache[5] = function () {
      return _ctx.handleBlur && _ctx.handleBlur(...arguments);
    }),
    onKeydown: _cache[6] || (_cache[6] = function () {
      return _ctx.handleKeydown && _ctx.handleKeydown(...arguments);
    })
  }, "\n        ", 46
  /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
  , _hoisted_1$9)), _ctx.isWordLimitVisible && _ctx.type === 'textarea' ? (openBlock(), createElementBlock("span", {
    key: 2,
    class: normalizeClass(`${_ctx.textareaPrefixCls}-count`)
  }, toDisplayString(_ctx.textLength) + "/" + toDisplayString(_ctx.maxlength), 3
  /* TEXT, CLASS */
  )) : createCommentVNode("v-if", true)], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

script$x.render = render$u;
script$x.__file = "components/input/input.vue";

const FInput = withInstall(script$x);

const prefixCls$Y = getPrefixCls('input-number');
var ActionEnum;

(function (ActionEnum) {
  ActionEnum[ActionEnum["PLUS"] = 0] = "PLUS";
  ActionEnum[ActionEnum["REDUCE"] = 1] = "REDUCE";
})(ActionEnum || (ActionEnum = {}));

var script$w = defineComponent({
  name: 'FInputNumber',
  components: {
    InputInner: script$y,
    UpOutlined,
    DownOutlined
  },
  props: {
    modelValue: Number,
    min: {
      type: Number,
      default: -Infinity
    },
    max: {
      type: Number,
      default: Infinity
    },
    step: {
      type: Number,
      default: 1
    },
    precision: Number,
    disabled: Boolean,
    placeholder: String
  },
  emits: ['update:modelValue', 'change', 'input', 'blur', 'focus'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    useTheme();
    const {
      validate,
      isError,
      isFormDisabled
    } = useFormAdaptor({
      valueType: 'number',
      forbidChildValidate: true
    });
    const [currentValue, updateCurrentValue] = useNormalModel(props, emit);
    const innerDisabled = computed(() => props.disabled || isFormDisabled.value);
    const classes = computed(() => [`${prefixCls$Y}`, innerDisabled.value && 'is-disabled'].filter(Boolean));
    const tempValue = ref();
    const displayValue = computed(() => {
      if (tempValue.value != null) return tempValue.value;
      return currentValue.value;
    }); // 

    const getPrecision = val => {
      if (val == null) return 0;
      const valueString = val.toString();
      const dotPosition = valueString.indexOf('.');
      let valuePrecision = 0;

      if (dotPosition !== -1) {
        valuePrecision = valueString.length - dotPosition - 1;
      }

      return valuePrecision;
    }; //  


    const numPrecision = computed(() => {
      const stepPrecision = getPrecision(props.step);

      if (props.precision != null) {
        const positiveIntegerPrecision = Math.abs(Math.round(props.precision));

        if (stepPrecision > positiveIntegerPrecision) {
          console.warn('[InputNumber]precision should not be less than the decimal places of step');
        }

        return positiveIntegerPrecision;
      }

      return Math.max(getPrecision(currentValue.value), stepPrecision); // currentvalue 
    }); // 

    const toPrecision = (num, pre) => {
      if (pre == null) pre = numPrecision.value;
      return Math.round(num * 10 ** pre) / 10 ** pre;
    };

    const setCurrentValue = newVal => {
      const oldVal = currentValue.value;

      if (isNumber(newVal) && props.precision != null) {
        newVal = toPrecision(newVal, props.precision);
      }

      if (newVal != null && newVal >= props.max) newVal = props.max;
      if (newVal != null && newVal <= props.min) newVal = props.min;
      if (oldVal === newVal) return;
      tempValue.value = null;
      updateCurrentValue(newVal);
      emit('input', newVal);
      emit('change', newVal, oldVal);
      validate('input');
      validate('change');
    };

    const handleBlur = e => {
      if (tempValue.value) tempValue.value = null;
      emit('blur', e);
      validate('blur');
    };

    const handleInput = value => {
      tempValue.value = value; //  tick  tempValue displayValue

      nextTick(() => {
        if (!value.endsWith('.') && (!Number.isNaN(Number(value)) || value === '')) {
          setCurrentValue(value === '' ? null : Number(value));
        }
      });
    };

    const onFocused = e => {
      emit('focus', e);
    };

    const _calculationNum = (val, type) => {
      if (!isNumber(val) && val != null) return tempValue.value;
      const precisionFactor = 10 ** numPrecision.value;
      let tmp;

      if (type === ActionEnum.PLUS) {
        tmp = precisionFactor * val + precisionFactor * props.step;
      } else {
        tmp = precisionFactor * val - precisionFactor * props.step;
      }

      return toPrecision(tmp / precisionFactor);
    }; // 


    const minDisabled = computed(() => _calculationNum(currentValue.value, ActionEnum.REDUCE) < props.min); // 

    const maxDisabled = computed(() => _calculationNum(currentValue.value, ActionEnum.PLUS) > props.max);

    const calculationNum = type => {
      if (props.disabled || maxDisabled.value && type === ActionEnum.PLUS || minDisabled.value && type === ActionEnum.REDUCE || isFormDisabled.value) return;
      tempValue.value = null;
      setCurrentValue(_calculationNum(currentValue.value || 0, type));
    };

    return {
      prefixCls: prefixCls$Y,
      isError,
      ActionEnum,
      innerDisabled,
      classes,
      handleInput,
      onFocused,
      handleBlur,
      calculationNum,
      displayValue,
      minDisabled,
      maxDisabled
    };
  }

});

function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_UpOutlined = resolveComponent("UpOutlined");

  const _component_DownOutlined = resolveComponent("DownOutlined");

  const _component_InputInner = resolveComponent("InputInner");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    onDragstart: _cache[4] || (_cache[4] = withModifiers(() => {}, ["prevent"]))
  }, [createVNode(_component_InputInner, {
    modelValue: _ctx.displayValue,
    disabled: _ctx.innerDisabled,
    placeholder: _ctx.placeholder,
    class: normalizeClass([`${_ctx.prefixCls}-inner`]),
    innerIsError: _ctx.isError,
    onInput: _ctx.handleInput,
    onFocus: _ctx.onFocused,
    onBlur: _ctx.handleBlur
  }, createSlots({
    suffix: withCtx(() => [renderSlot(_ctx.$slots, "suffix"), createElementVNode("div", {
      class: normalizeClass([`${_ctx.prefixCls}-actions`, _ctx.$slots.suffix && `${_ctx.prefixCls}-actions-suffix`])
    }, [createElementVNode("span", {
      class: normalizeClass([`${_ctx.prefixCls}-actions-increase`, {
        'is-disabled': _ctx.maxDisabled || _ctx.innerDisabled
      }]),
      onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"])),
      onClick: _cache[1] || (_cache[1] = $event => _ctx.calculationNum(_ctx.ActionEnum.PLUS))
    }, [createVNode(_component_UpOutlined)], 34
    /* CLASS, HYDRATE_EVENTS */
    ), createElementVNode("span", {
      class: normalizeClass([`${_ctx.prefixCls}-actions-decrease`, {
        'is-disabled': _ctx.minDisabled || _ctx.innerDisabled
      }]),
      onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {}, ["prevent"])),
      onClick: _cache[3] || (_cache[3] = $event => _ctx.calculationNum(_ctx.ActionEnum.REDUCE))
    }, [createVNode(_component_DownOutlined)], 34
    /* CLASS, HYDRATE_EVENTS */
    )], 2
    /* CLASS */
    )]),
    _: 2
    /* DYNAMIC */

  }, [_ctx.$slots.prefix ? {
    name: "prefix",
    fn: withCtx(() => [renderSlot(_ctx.$slots, "prefix")]),
    key: "0"
  } : undefined]), 1032
  /* PROPS, DYNAMIC_SLOTS */
  , ["modelValue", "disabled", "placeholder", "class", "innerIsError", "onInput", "onFocus", "onBlur"])], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

script$w.render = render$t;
script$w.__file = "components/input-number/input-number.vue";

const FInputNumber = withInstall(script$w);

let COMPONENT_NAME$5;

(function (COMPONENT_NAME) {
  COMPONENT_NAME["LAYOUT"] = "FLayout";
  COMPONENT_NAME["HEADER"] = "FHeader";
  COMPONENT_NAME["FOOTER"] = "FFooter";
  COMPONENT_NAME["ASIDE"] = "FAside";
  COMPONENT_NAME["MAIN"] = "FMain";
})(COMPONENT_NAME$5 || (COMPONENT_NAME$5 = {}));

const layoutProps = {
  embedded: {
    type: Boolean,
    default: false
  },
  fixed: {
    type: Boolean,
    default: false
  },
  containerClass: [Array, Object, String],
  containerStyle: Object
};
const LAYOUT_PROVIDE_KEY = Symbol('FLayout');

function ownKeys$C(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$C(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$C(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$C(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$X = getPrefixCls('layout');
var script$v = defineComponent({
  name: COMPONENT_NAME$5.LAYOUT,
  props: layoutProps,

  setup(props) {
    useTheme();
    const isRoot = ref(true); // layoutlayoutlayout

    const parent = inject(LAYOUT_PROVIDE_KEY, null);

    if (parent) {
      isRoot.value = false;
      parent.addChild({
        type: COMPONENT_NAME$5.LAYOUT
      });
    }

    const children = reactive([]);

    const addChild = child => {
      children.push(child);
    };

    const isHorizontal = computed(() => {
      if (children.length) {
        return children.some(node => node.type === COMPONENT_NAME$5.ASIDE);
      }

      return false;
    });
    const asidePlacement = computed(() => {
      if (children.length > 0) {
        if (children[0].type === COMPONENT_NAME$5.ASIDE) {
          return 'left';
        }

        if (children[children.length - 1].type === COMPONENT_NAME$5.ASIDE) {
          return 'right';
        }
      }

      return '';
    });
    const classList = computed(() => [prefixCls$X, isHorizontal.value && 'is-horizontal', props.fixed && 'is-fixed', isRoot.value && 'is-root'].filter(Boolean));
    const containerClassRef = computed(() => {
      const base = `${prefixCls$X}-container`;

      if (isPlainObject(props.containerClass)) {
        return _objectSpread$C({
          [base]: true
        }, props.containerClass);
      }

      if (isArray$1(props.containerClass)) {
        return [base, ...props.containerClass];
      }

      if (isString$1(props.containerClass)) {
        return [base, props.containerClass];
      }

      return [base];
    });
    provide(LAYOUT_PROVIDE_KEY, _objectSpread$C({
      addChild,
      asidePlacement
    }, toRefs(props)));
    return {
      prefixCls: prefixCls$X,
      classList,
      containerClassRef
    };
  }

});

function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("section", {
    class: normalizeClass(_ctx.classList)
  }, [createElementVNode("div", {
    class: normalizeClass(_ctx.containerClassRef),
    style: normalizeStyle(_ctx.containerStyle)
  }, [renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  )], 2
  /* CLASS */
  );
}

script$v.render = render$s;
script$v.__file = "components/layout/layout.vue";

const prefixCls$W = getPrefixCls('layout');
var script$u = defineComponent({
  name: COMPONENT_NAME$5.HEADER,
  props: {
    inverted: {
      type: Boolean,
      default: false
    },
    bordered: {
      type: Boolean,
      default: false
    },
    fixed: {
      type: Boolean,
      default: false
    }
  },

  setup(props) {
    const vm = getCurrentInstance();

    if (!vm.parent || !vm.parent.type || vm.parent.type.name !== COMPONENT_NAME$5.LAYOUT) {
      console.warn(`[${COMPONENT_NAME$5.HEADER}] must be a child of ${COMPONENT_NAME$5.LAYOUT}`);
    }

    const {
      addChild
    } = inject(LAYOUT_PROVIDE_KEY, {
      addChild: noop$1
    });
    addChild({
      type: COMPONENT_NAME$5.HEADER
    });
    const classList = computed(() => [`${prefixCls$W}-header`, props.fixed && 'is-fixed', props.inverted && 'is-inverted', props.bordered && 'is-bordered'].filter(Boolean));
    return {
      classList
    };
  }

});

function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("header", {
    class: normalizeClass(_ctx.classList)
  }, [renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$u.render = render$r;
script$u.__file = "components/layout/header.vue";

const prefixCls$V = getPrefixCls('layout');
var script$t = defineComponent({
  name: COMPONENT_NAME$5.MAIN,
  props: {
    embedded: {
      type: Boolean,
      default: false
    }
  },

  setup(props) {
    const vm = getCurrentInstance();

    if (!vm.parent || !vm.parent.type || vm.parent.type.name !== COMPONENT_NAME$5.LAYOUT) {
      console.warn(`[${COMPONENT_NAME$5.MAIN}] must be a child of ${COMPONENT_NAME$5.LAYOUT}`);
    }

    const {
      addChild,
      embedded
    } = inject(LAYOUT_PROVIDE_KEY, {
      addChild: noop$1,
      embedded: ref(false)
    });
    addChild({
      type: COMPONENT_NAME$5.MAIN
    });
    const classList = computed(() => [`${prefixCls$V}-main`, (embedded.value || props.embedded) && 'is-embedded'].filter(Boolean));
    return {
      classList
    };
  }

});

function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("main", {
    class: normalizeClass(_ctx.classList)
  }, [renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$t.render = render$q;
script$t.__file = "components/layout/main.vue";

const prefixCls$U = getPrefixCls('layout');
var script$s = defineComponent({
  name: COMPONENT_NAME$5.ASIDE,
  components: {
    LeftOutlined,
    RightOutlined
  },
  props: {
    collapsible: {
      type: Boolean,
      default: false
    },
    collapsedWidth: {
      type: String,
      default: '48px'
    },
    width: {
      type: String,
      default: '200px'
    },
    fixed: {
      type: Boolean,
      default: false
    },
    inverted: {
      type: Boolean,
      default: false
    },
    bordered: {
      type: Boolean,
      default: false
    },
    showTrigger: {
      type: Boolean,
      default: true
    }
  },
  emits: ['update:collapsed'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const vm = getCurrentInstance();

    if (!vm.parent || !vm.parent.type || vm.parent.type.name !== COMPONENT_NAME$5.LAYOUT) {
      console.warn(`[${COMPONENT_NAME$5.ASIDE}] must be a child of ${COMPONENT_NAME$5.LAYOUT}`);
    }

    const {
      addChild,
      asidePlacement
    } = inject(LAYOUT_PROVIDE_KEY, {
      addChild: noop$1,
      asidePlacement: ref('')
    });
    const [currentCollapsed, updateCurrentCollapsed] = useNormalModel(props, emit, {
      prop: 'collapsed'
    });
    const classList = computed(() => [`${prefixCls$U}-aside`, props.fixed && 'is-fixed', props.collapsible && props.showTrigger && 'is-has-trigger', props.inverted && 'is-inverted', props.collapsible && currentCollapsed.value && 'is-collapsed', asidePlacement.value && `is-placement-${asidePlacement.value}`, props.bordered && 'is-bordered'].filter(Boolean));
    const style = computed(() => ({
      width: props.collapsible && currentCollapsed.value ? props.collapsedWidth : props.width
    }));

    const handleTrigger = () => {
      updateCurrentCollapsed(!currentCollapsed.value);
    };

    addChild({
      type: COMPONENT_NAME$5.ASIDE
    });
    return {
      prefixCls: prefixCls$U,
      classList,
      style,
      handleTrigger,
      asidePlacement,
      currentCollapsed
    };
  }

});

function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LeftOutlined = resolveComponent("LeftOutlined");

  const _component_RightOutlined = resolveComponent("RightOutlined");

  return openBlock(), createElementBlock("aside", {
    class: normalizeClass(_ctx.classList),
    style: normalizeStyle(_ctx.style)
  }, [createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-aside-wrapper`)
  }, [renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  ), _ctx.collapsible && _ctx.showTrigger ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-aside-trigger`),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.handleTrigger && _ctx.handleTrigger(...arguments);
    })
  }, [_ctx.asidePlacement === 'left' ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [!_ctx.currentCollapsed ? (openBlock(), createBlock(_component_LeftOutlined, {
    key: 0
  })) : (openBlock(), createBlock(_component_RightOutlined, {
    key: 1
  }))], 64
  /* STABLE_FRAGMENT */
  )) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [_ctx.currentCollapsed ? (openBlock(), createBlock(_component_LeftOutlined, {
    key: 0
  })) : (openBlock(), createBlock(_component_RightOutlined, {
    key: 1
  }))], 64
  /* STABLE_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true)], 6
  /* CLASS, STYLE */
  );
}

script$s.render = render$p;
script$s.__file = "components/layout/aside.vue";

const prefixCls$T = getPrefixCls('layout');
var script$r = defineComponent({
  name: COMPONENT_NAME$5.FOOTER,
  props: {
    embedded: {
      type: Boolean,
      default: false
    },
    bordered: {
      type: Boolean,
      default: false
    },
    fixed: {
      type: Boolean,
      default: false
    }
  },

  setup(props) {
    const vm = getCurrentInstance();

    if (!vm.parent || !vm.parent.type || vm.parent.type.name !== COMPONENT_NAME$5.LAYOUT) {
      console.warn(`[${COMPONENT_NAME$5.FOOTER}] must be a child of ${COMPONENT_NAME$5.LAYOUT}`);
    }

    const {
      addChild,
      embedded
    } = inject(LAYOUT_PROVIDE_KEY, {
      addChild: noop$1,
      embedded: ref(false)
    });
    addChild({
      type: COMPONENT_NAME$5.FOOTER
    });
    const classList = computed(() => [`${prefixCls$T}-footer`, props.bordered && 'is-bordered', (embedded.value || props.embedded) && 'is-embedded', props.fixed && 'is-fixed'].filter(Boolean));
    return {
      classList
    };
  }

});

function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("footer", {
    class: normalizeClass(_ctx.classList)
  }, [renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$r.render = render$o;
script$r.__file = "components/layout/footer.vue";

const FLayout = withInstall(script$v, {
  Header: script$u,
  Main: script$t,
  Aside: script$s,
  Footer: script$r
});
const FHeader = withNoopInstall(script$u);
const FMain = withNoopInstall(script$t);
const FAside = withNoopInstall(script$s);
const FFooter = withNoopInstall(script$r);

const MODE = ['horizontal', 'vertical'];
const COMPONENT_NAME$4 = {
  MENU: 'FMenu',
  SUB_MENU: 'FSubMenu',
  MENU_ITEM: 'FMenuItem',
  MENU_GROUP: 'FMenuGroup'
};
const CHILDREN_KEY = Symbol('FMenuChildren');
const MENU_KEY = Symbol('FMenu');
const MENU_PROPS = {
  // 
  modelValue: {
    type: [String, Number]
  },
  // 
  mode: {
    type: String,
    default: MODE[0]
  },
  // 
  collapsed: {
    type: Boolean,
    default: false
  },
  // 
  inverted: {
    type: Boolean,
    default: false
  },
  // subMenu
  defaultExpandAll: {
    type: Boolean,
    default: false
  },
  // subMenukey
  expandedKeys: {
    type: Array,
    default: () => []
  },
  // 
  accordion: {
    type: Boolean,
    default: false
  },
  options: {
    type: Array,

    default() {
      return [];
    }

  }
};

var useParent = (() => {
  const children = reactive([]);

  const addChild = child => {
    if (children.every(item => {
      return item.uid !== child.uid;
    })) {
      children.push(child);
    }
  };

  const removeChild = child => {
    const index = children.findIndex(item => {
      return item.uid === child.uid;
    });

    if (index !== -1) {
      children.splice(index, 1);
    }
  };

  provide(CHILDREN_KEY, {
    addChild,
    removeChild
  });
  return {
    children
  };
});

var useMenu = (instance => {
  var _instance;

  instance = (_instance = instance) !== null && _instance !== void 0 ? _instance : getCurrentInstance();
  const node = {
    name: instance.type.name,
    uid: instance.props.value || instance.uid
  };
  const {
    parentPath
  } = inject(MENU_KEY, {
    parentPath: computed(() => [])
  });
  const indexPath = computed(() => {
    return parentPath.value.concat(node);
  });
  provide(MENU_KEY, {
    parentPath: indexPath
  });
  return {
    indexPath
  };
});

var useChildren = (indexPath => {
  //  menu
  const rootMenu = inject('rootMenu', null); //  menu / sub-menu / menu-group

  const parentMenu = inject(CHILDREN_KEY, null);
  const paddingStyle = computed(() => {
    if (rootMenu.renderWithPopper.value) return {};
    let padding = 16;
    const len = indexPath.value.length;

    if (len > 2) {
      for (let i = len - 2; i >= 0; i--) {
        const node = indexPath.value[i];

        if (node.name === COMPONENT_NAME$4.SUB_MENU) {
          padding += 14;
        }

        if (node.name === COMPONENT_NAME$4.MENU_GROUP) {
          padding += 8;
        }
      }
    }

    return {
      paddingLeft: `${padding}px`
    };
  });
  const isFirstLevel = computed(() => {
    return indexPath.value.length < 3;
  });
  const onlyIcon = computed(() => {
    if (rootMenu.props.mode !== 'vertical') return false;
    return isFirstLevel.value && rootMenu.props.collapsed;
  });
  return {
    rootMenu,
    parentMenu,
    paddingStyle,
    onlyIcon,
    isFirstLevel,
    indexPath
  };
});

const prefixCls$S = getPrefixCls('menu-group');
var MenuGroup = defineComponent({
  name: COMPONENT_NAME$4.MENU_GROUP,
  props: {
    // 
    label: {
      type: String
    }
  },

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const instance = getCurrentInstance();
    const {
      indexPath
    } = useMenu(instance);
    const {
      rootMenu,
      parentMenu,
      paddingStyle
    } = useChildren(indexPath); //  menu

    if (!rootMenu) {
      console.warn(`[${COMPONENT_NAME$4.MENU_GROUP}] must be a child of ${COMPONENT_NAME$4.MENU}`);
    } //  menu  sub-menu


    if (!parentMenu) {
      console.warn(`[${COMPONENT_NAME$4.MENU_GROUP}] must be a child of ${COMPONENT_NAME$4.MENU} or ${COMPONENT_NAME$4.SUB_MENU}`);
    }

    const {
      children
    } = useParent();
    const isActive = computed(() => children.some(child => child === null || child === void 0 ? void 0 : child.isActive));
    const subMenu = {
      uid: instance.uid,
      type: 'menuGroup',
      children,
      isActive
    };
    onMounted(() => {
      parentMenu.addChild(subMenu);
    });
    onBeforeUnmount(() => {
      parentMenu.removeChild(subMenu);
    });

    const renderTitle = () => {
      var _slots$label;

      return createVNode(Ellipsis, {
        "class": `${prefixCls$S}-label`,
        "style": paddingStyle.value
      }, {
        default: () => [((_slots$label = slots.label) === null || _slots$label === void 0 ? void 0 : _slots$label.call(slots)) || props.label]
      });
    };

    return () => {
      var _slots$default;

      return createVNode("div", {
        "class": prefixCls$S
      }, [renderTitle(), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }

});

const prefixCls$R = getPrefixCls('menu-item');
var MenuItem = defineComponent({
  name: COMPONENT_NAME$4.MENU_ITEM,
  components: {
    Ellipsis
  },
  props: {
    value: {
      type: [String, Number],
      required: true
    },
    label: String
  },

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const instance = getCurrentInstance();
    const {
      indexPath
    } = useMenu(instance);
    const {
      rootMenu,
      parentMenu,
      paddingStyle,
      onlyIcon
    } = useChildren(indexPath); //  menu

    if (!rootMenu) {
      console.warn(`[${COMPONENT_NAME$4.MENU_ITEM}] must be a child of ${COMPONENT_NAME$4.MENU}`);
    } //  menu  sub-menu


    if (!parentMenu) {
      console.warn(`[${COMPONENT_NAME$4.MENU_ITEM}] must be a child of ${COMPONENT_NAME$4.MENU} or ${COMPONENT_NAME$4.SUB_MENU}`);
    }

    const isActive = computed(() => rootMenu.currentValue.value === props.value);
    const menuItem = {
      uid: instance.uid,
      type: 'menu',
      value: props.value,
      isActive
    };
    onMounted(() => {
      parentMenu.addChild(menuItem);
    });
    onBeforeUnmount(() => {
      parentMenu.removeChild(menuItem);
    });
    const classList = computed(() => [prefixCls$R, isActive.value && 'is-active'].filter(Boolean).join(' '));

    const handleClick = () => {
      rootMenu.clickMenuItem(props.value);
    };

    const renderTitle = () => {
      var _slots$label;

      return createVNode(Ellipsis, {
        "class": `${prefixCls$R}-label`
      }, {
        default: () => [((_slots$label = slots.label) === null || _slots$label === void 0 ? void 0 : _slots$label.call(slots)) || props.label]
      });
    };

    const renderIcon = () => {
      if (slots.icon) {
        return createVNode("span", {
          "class": `${prefixCls$R}-icon`
        }, [slots.icon()]);
      }

      if (onlyIcon.value) {
        return renderTitle();
      }

      return null;
    };

    return () => createVNode("div", {
      "class": classList.value,
      "onClick": handleClick
    }, [createVNode("div", {
      "class": `${prefixCls$R}-wrapper`,
      "style": paddingStyle.value
    }, [renderIcon(), !onlyIcon.value ? renderTitle() : null])]);
  }

});

var FadeInExpandTransition = defineComponent({
  name: 'FadeInExpandTransition',
  props: {
    appear: Boolean,
    group: Boolean,
    mode: String,
    onLeave: Function,
    onAfterLeave: Function,
    onAfterEnter: Function,
    width: Boolean,
    // reverse mode is only used in tree
    // it make it from expanded to collapsed after mounted
    reverse: Boolean
  },

  setup(props, _ref) {
    let {
      slots
    } = _ref;

    function handleBeforeLeave(el) {
      if (props.width) {
        el.style.maxWidth = `${el.offsetWidth}px`;
      } else {
        el.style.maxHeight = `${el.offsetHeight}px`;
      }

      void el.offsetWidth;
    }

    function handleLeave(el) {
      if (props.width) {
        el.style.maxWidth = '0';
      } else {
        el.style.maxHeight = '0';
      }

      void el.offsetWidth;
      const {
        onLeave
      } = props;
      if (onLeave) onLeave();
    }

    function handleAfterLeave(el) {
      if (props.width) {
        el.style.maxWidth = '';
      } else {
        el.style.maxHeight = '';
      }

      const {
        onAfterLeave
      } = props;
      if (onAfterLeave) onAfterLeave();
    }

    function handleEnter(el) {
      el.style.transition = 'none';

      if (props.width) {
        const memorizedWidth = el.offsetWidth;
        el.style.maxWidth = '0';
        void el.offsetWidth;
        el.style.transition = '';
        el.style.maxWidth = `${memorizedWidth}px`;
      } else {
        if (props.reverse) {
          el.style.maxHeight = `${el.offsetHeight}px`;
          void el.offsetHeight;
          el.style.transition = '';
          el.style.maxHeight = '0';
        } else {
          const memorizedHeight = el.offsetHeight;
          el.style.maxHeight = '0';
          void el.offsetWidth;
          el.style.transition = '';
          el.style.maxHeight = `${memorizedHeight}px`;
        }
      }

      void el.offsetWidth;
    }

    function handleAfterEnter(el) {
      var _props$onAfterEnter;

      if (props.width) {
        el.style.maxWidth = '';
      } else {
        if (!props.reverse) {
          el.style.maxHeight = '';
        }
      }

      (_props$onAfterEnter = props.onAfterEnter) === null || _props$onAfterEnter === void 0 ? void 0 : _props$onAfterEnter.call(props);
    }

    return () => {
      const type = props.group ? TransitionGroup : Transition;
      return h(type, {
        name: props.width ? 'fes-fade-in-width-expand' : 'fes-fade-in-height-expand',
        mode: props.mode,
        appear: props.appear,
        onEnter: handleEnter,
        onAfterEnter: handleAfterEnter,
        onBeforeLeave: handleBeforeLeave,
        onLeave: handleLeave,
        onAfterLeave: handleAfterLeave
      }, slots);
    };
  }

});

const prefixCls$Q = getPrefixCls('sub-menu');
var SubMenu = defineComponent({
  name: COMPONENT_NAME$4.SUB_MENU,
  components: {
    Ellipsis,
    FadeInExpandTransition
  },
  props: {
    value: {
      type: [String, Number],
      default: null
    },
    label: String
  },

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const instance = getCurrentInstance();
    const {
      indexPath
    } = useMenu(instance);
    const subMenuRef = ref(null);
    const {
      rootMenu,
      parentMenu,
      paddingStyle,
      isFirstLevel,
      onlyIcon
    } = useChildren(indexPath); //  menu

    if (!rootMenu) {
      console.warn(`[${COMPONENT_NAME$4.SUB_MENU}] must be a child of ${COMPONENT_NAME$4.MENU}`);
    } //  menu  sub-menu


    if (!parentMenu) {
      console.warn(`[${COMPONENT_NAME$4.SUB_MENU}] must be a child of ${COMPONENT_NAME$4.MENU} or ${COMPONENT_NAME$4.SUB_MENU}`);
    }

    const {
      children
    } = useParent();
    const isOpened = ref(false);
    const isActive = computed(() => children.some(child => child === null || child === void 0 ? void 0 : child.isActive));
    const subMenu = {
      uid: instance.uid,
      value: props.value,
      type: 'subMenu',
      children,
      isOpened,
      isActive
    };
    onMounted(() => {
      parentMenu.addChild(subMenu);
    });
    onBeforeUnmount(() => {
      parentMenu.removeChild(subMenu);
    });
    const placement = computed(() => {
      if (rootMenu.props.mode === 'horizontal') {
        return isFirstLevel.value ? 'bottom-start' : 'right-start';
      }

      return 'right-start';
    });
    const classList = computed(() => [prefixCls$Q, isActive.value && 'is-active'].filter(Boolean).join(' '));

    const handleClickTrigger = () => {
      isOpened.value = !isOpened.value;
      rootMenu.clickSubMenu(subMenu, indexPath);
    };

    watch(rootMenu.currentExpandedKeys, () => {
      if (!rootMenu.renderWithPopper.value) {
        const index = rootMenu.currentExpandedKeys.value.indexOf(props.value || instance.uid);

        if (index === -1 && isOpened.value) {
          isOpened.value = false;
        } else if (index !== -1 && !isOpened.value) {
          isOpened.value = true;
        }
      }
    }, {
      immediate: true
    });

    const renderTitle = () => {
      var _slots$label;

      return createVNode(Ellipsis, {
        "class": `${prefixCls$Q}-label`
      }, {
        default: () => [((_slots$label = slots.label) === null || _slots$label === void 0 ? void 0 : _slots$label.call(slots)) || props.label]
      });
    };

    const renderIcon = () => {
      if (slots.icon) {
        return createVNode("div", {
          "class": `${prefixCls$Q}-icon`
        }, [slots.icon()]);
      }

      if (onlyIcon.value) {
        return renderTitle();
      }

      return null;
    };

    const renderArrow = () => {
      if (rootMenu.renderWithPopper.value && !isFirstLevel.value) {
        return createVNode("span", {
          "class": `${prefixCls$Q}-arrow`
        }, [createVNode(RightOutlined, null, null)]);
      }

      return createVNode("span", {
        "class": [`${prefixCls$Q}-arrow`, isOpened.value && 'is-opened']
      }, [createVNode(DownOutlined, null, null)]);
    };

    const renderWrapper = trigger => createVNode("div", {
      "class": `${prefixCls$Q}-wrapper`,
      "style": paddingStyle.value,
      "onClick": () => {
        if (trigger === 'click') {
          handleClickTrigger();
        }
      }
    }, [renderIcon(), !onlyIcon.value ? renderTitle() : null, !onlyIcon.value ? renderArrow() : null]);

    const renderDefault = () => {
      var _slots$default;

      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };

    const renderContent = () => {
      if (rootMenu.renderWithPopper.value) {
        return createVNode(Popper, {
          "modelValue": isOpened.value,
          "onUpdate:modelValue": $event => isOpened.value = $event,
          "trigger": "hover",
          "placement": placement.value,
          "popperClass": `${prefixCls$Q}-popper`,
          "appendToContainer": false,
          "offset": 1
        }, {
          default: renderDefault,
          trigger: renderWrapper
        });
      }

      return createVNode(Fragment, null, [renderWrapper('click'), createVNode(FadeInExpandTransition, null, {
        default: () => [withDirectives(createVNode("div", {
          "class": `${prefixCls$Q}-children`
        }, [renderDefault()]), [[vShow, isOpened.value]])]
      })]);
    };

    return () => createVNode("div", {
      "class": classList.value,
      "ref": subMenuRef
    }, [renderContent()]);
  }

});

function ownKeys$B(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$B(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$B(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$B(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$P = getPrefixCls('menu');
var Menu = defineComponent({
  name: COMPONENT_NAME$4.MENU,
  props: MENU_PROPS,
  emits: ['select', UPDATE_MODEL_EVENT$1, 'update:expandedKeys'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    useTheme();
    useMenu();
    const [currentValue, updateCurrentValue] = useNormalModel(props, emit);
    const [currentExpandedKeys, updateExpandedKeys] = useArrayModel(props, emit, {
      prop: 'expandedKeys'
    });
    const renderWithPopper = computed(() => {
      if (props.mode === 'horizontal') {
        return true;
      }

      return props.collapsed;
    });
    const {
      children
    } = useParent();

    const clickMenuItem = value => {
      updateCurrentValue(value);
      emit('select', {
        value
      }); // hoverhover

      if (renderWithPopper.value) {
        children.forEach(item => {
          if (item.type === 'subMenu') {
            item.isOpened = false;
          }
        });
      }
    };

    const flatNodes = function () {
      let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return nodes.reduce((res, node) => {
        var _node$children;

        if (node.type === 'subMenu') {
          res.push(node.value || node.uid);
        }

        if ((_node$children = node.children) !== null && _node$children !== void 0 && _node$children.length) {
          const keys = flatNodes(node.children); // Array.concat

          concat(res, keys);
        }

        return res;
      }, []);
    };

    onMounted(() => {
      if (props.defaultExpandAll && currentExpandedKeys.value.length === 0) {
        const keys = flatNodes(children);
        updateExpandedKeys(keys);
      }
    });

    const clickSubMenu = (subMenu, indexPath) => {
      if (subMenu.isOpened.value) {
        if (props.accordion) {
          updateExpandedKeys(currentExpandedKeys.value.filter(uid => indexPath.value.some(node => {
            return node.uid === uid;
          })));
        }

        updateExpandedKeys(subMenu.value || subMenu.uid);
      } else {
        updateExpandedKeys(subMenu.value || subMenu.uid);
      }
    };

    provide('rootMenu', {
      props,
      currentValue,
      clickMenuItem,
      clickSubMenu,
      renderWithPopper,
      currentExpandedKeys,
      updateExpandedKeys
    });
    const classList = computed(() => [prefixCls$P, `is-${props.mode}`, props.inverted && 'is-inverted', props.mode === 'vertical' && props.collapsed && 'is-collapsed'].filter(Boolean));

    const renderChildren = arr => arr.map(item => {
      const itemSlots = {};

      if (isFunction(item.icon)) {
        itemSlots.icon = item.icon;
      }

      itemSlots.label = () => isFunction(item.label) ? item.label() : item.label;

      if (!item.children) {
        return createVNode(MenuItem, {
          "value": item.value
        }, itemSlots);
      }

      if (item.isGroup) {
        return createVNode(MenuGroup, null, _objectSpread$B({
          default: () => [renderChildren(item.children)]
        }, itemSlots));
      }

      return createVNode(SubMenu, {
        "value": item.value
      }, _objectSpread$B({
        default: () => [renderChildren(item.children)]
      }, itemSlots));
    });

    const render = () => {
      if (props.options.length === 0) {
        var _slots$default;

        return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      }

      return renderChildren(props.options);
    };

    return () => createVNode("div", {
      "class": classList.value
    }, [render()]);
  }

});

const FMenu = withInstall(Menu, {
  MenuItem,
  MenuGroup,
  SubMenu
});
const FMenuItem = withNoopInstall(MenuItem);
const FMenuGroup = withNoopInstall(MenuGroup);
const FSubMenu = withNoopInstall(SubMenu);

function ownKeys$A(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$A(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$A(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$A(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$O = getPrefixCls('message');
const defaultConfig$1 = {
  duration: 3,
  getContainer: () => document.body,
  top: '24px',
  colorful: false
};
let mergeConfig$1 = defaultConfig$1;
let messageInstance = null;
const managerStyle = reactive({
  zIndex: 0,
  top: mergeConfig$1.top
});

async function create$1(_ref) {
  var _messageInstance, _messageInstance$exit;

  let {
    type,
    content,
    duration,
    icon,
    closable,
    afterClose,
    colorful
  } = _ref;
  managerStyle.zIndex = PopupManager$1.nextZIndex();

  if (!((_messageInstance = messageInstance) !== null && _messageInstance !== void 0 && (_messageInstance$exit = _messageInstance.exited) !== null && _messageInstance$exit !== void 0 && _messageInstance$exit.call(_messageInstance))) {
    messageInstance = await createManager({
      getContainer: mergeConfig$1.getContainer,
      transitionName: `${prefixCls$O}`,
      class: `${prefixCls$O}-wrapper`,
      maxCount: mergeConfig$1.maxCount,
      style: managerStyle
    });
  }

  const classNames = [`${prefixCls$O}`]; // colorful

  if (!(colorful || colorful !== false && mergeConfig$1.colorful)) {
    classNames.push(`${prefixCls$O}-no-colorful`);
  }

  if (closable) classNames.push(`${prefixCls$O}-close`);
  let item;

  function handleCloseClick() {
    var _item;

    messageInstance.remove((_item = item) === null || _item === void 0 ? void 0 : _item.key);
  }

  const contentIsFunc = typeof content === 'function';
  const iconIsFunc = typeof icon === 'function';
  const scopedSlots = {
    default: contentIsFunc ? content : null,
    icon: iconIsFunc ? icon : null
  };
  item = messageInstance.append({
    afterRemove: afterClose,
    duration: duration != null && duration >= 0 ? duration : mergeConfig$1.duration,
    style: {
      zIndex: PopupManager$1.nextZIndex()
    },
    children: createVNode("div", {
      "class": `${prefixCls$O}-item`
    }, [createVNode(Alert, {
      "class": classNames,
      "type": type,
      "message": contentIsFunc ? '' : content,
      "showIcon": true,
      "closable": closable,
      "onClose": handleCloseClick
    }, scopedSlots)])
  });
} // function message(type: MessageType, content: string, duration?: number): void;
// function message(type: MessageType, options: Options): void;


function message(type, options, duration) {
  const params = {
    type
  };

  if (typeof options === 'string') {
    params.content = options;
    params.duration = duration;
  } else {
    Object.assign(params, options);
  }

  create$1(params);
}

var FMessage = {
  config(options) {
    if (options) {
      mergeConfig$1 = _objectSpread$A(_objectSpread$A({}, defaultConfig$1), options);
    }
  },

  info: (content, duration) => message('info', content, duration),
  success: (content, duration) => message('success', content, duration),
  warning: (content, duration) => message('warning', content, duration),
  warn: (content, duration) => message('warning', content, duration),
  error: (content, duration) => message('error', content, duration),

  destroy() {
    messageInstance && messageInstance.destroy();
    messageInstance = null;
  }

};

function useEsc(action, open) {
  const onGlobalKeyDown = event => {
    if (event.code === 'Escape') {
      action(event);
    }
  }; // 


  if (isRef(open)) {
    watch(open, () => {
      if (open.value) {
        window.addEventListener('keydown', onGlobalKeyDown);
      } else {
        window.removeEventListener('keydown', onGlobalKeyDown);
      }
    });
  }

  onMounted(() => {
    window.addEventListener('keydown', onGlobalKeyDown);
  });
  onBeforeUnmount(() => {
    window.removeEventListener('keydown', onGlobalKeyDown);
  });
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
let { NODE_ENV } = process.env
NODE_ENV !== 'production' ? Object.freeze({}) : {};
NODE_ENV !== 'production' ? Object.freeze([]) : [];

const cacheStringFunction = fn => {
  const cache = Object.create(null);
  return str => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};

const camelizeRE = /-(\w)/g;
/**
 * @private
 */

const camelize = cacheStringFunction(str => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '');
});

/* istanbul ignore next */

function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');

  if (el.classList) {
    return el.classList.contains(cls);
  }

  return ` ${el.className} `.indexOf(` ${cls} `) > -1;
}
/* istanbul ignore next */

function addClass(el, cls) {
  if (!el) return;
  let curClass = el.className;
  const classes = (cls || '').split(' ');

  for (let i = 0, j = classes.length; i < j; i++) {
    const clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ` ${clsName}`;
    }
  }

  if (!el.classList) {
    el.className = curClass;
  }
}
/* istanbul ignore next */

function removeClass(el, cls) {
  if (!el || !cls) return;
  const classes = cls.split(' ');
  let curClass = ` ${el.className} `;

  for (let i = 0, j = classes.length; i < j; i++) {
    const clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(` ${clsName} `, ' ');
    }
  }

  if (!el.classList) {
    el.className = curClass.trim();
  }
}
/* istanbul ignore next */
// Here I want to use the type CSSProperties, but the definition for CSSProperties
// has { [index: number]: string } in its type annotation, which does not satisfy the method
// camelize(s: string)
// Same as the return type

const getStyle = function (element, styleName) {
  if (!element || !styleName) return '';
  styleName = camelize(styleName);

  if (styleName === 'float') {
    styleName = 'cssFloat';
  }

  try {
    const style = element.style[styleName];
    if (style) return style; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

    const computed = document.defaultView.getComputedStyle(element, '');
    return computed ? computed[styleName] : '';
  } catch (e) {
    return element.style[styleName];
  }
};
let scrollBarWidth;
function getScrollBarWidth() {
  var _outer$parentNode;

  if (scrollBarWidth || scrollBarWidth === 0) return scrollBarWidth;
  const outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';
  const inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  (_outer$parentNode = outer.parentNode) === null || _outer$parentNode === void 0 ? void 0 : _outer$parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
}
function isHtmlElement(el) {
  return el && el.nodeType === Node.ELEMENT_NODE;
}
function isScroll(el, isVertical) {
  const hasDirection = isVertical !== null && isVertical !== void 0 ? isVertical : '';
  const overflow = hasDirection ? isVertical ? getStyle(el, 'overflow-y') : getStyle(el, 'overflow-x') : getStyle(el, 'overflow');
  return overflow.match(/(scroll|auto|overlay)/);
}
function getScrollContainer(el, isVertical) {
  let parent = el;

  while (parent) {
    if ([window, document, document.documentElement].includes(parent)) {
      return window;
    }

    if (isScroll(parent, isVertical)) {
      return parent;
    }

    parent = parent.parentNode;
  }

  return parent;
}
function isInContainer(el, container) {
  // 
  if (!el || !container) return false;
  const elRect = el.getBoundingClientRect();
  let containerRect;

  if (container instanceof Element) {
    containerRect = container.getBoundingClientRect();
  } else {
    containerRect = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    };
  }

  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
}

const cls = getPrefixCls('popup-hidden');
/**
 * Hook that monitoring the ref value to lock or unlock the screen.
 * When the trigger became true, it assumes modal is now opened and vice versa.
 */

var useLockScreen = (trigger => {
  let scrollBarWidth = 0;
  let withoutHiddenClass = false;
  let bodyPaddingRight = '0';
  let computedBodyPaddingRight = 0;

  const cleanup = () => {
    removeClass(document.body, cls);

    if (withoutHiddenClass) {
      document.body.style.paddingRight = bodyPaddingRight;
    }
  };

  onUnmounted(() => {
    cleanup();
  });
  watch(trigger, val => {
    if (val) {
      withoutHiddenClass = !hasClass(document.body, cls);

      if (withoutHiddenClass) {
        bodyPaddingRight = document.body.style.paddingRight;
        computedBodyPaddingRight = parseInt(getStyle(document.body, 'paddingRight'), 10);
      }

      scrollBarWidth = getScrollBarWidth();
      const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
      const bodyOverflowY = getStyle(document.body, 'overflowY');

      if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && withoutHiddenClass) {
        document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarWidth}px`;
      }

      addClass(document.body, cls);
    } else {
      cleanup();
    }
  });
});

var zhCN = {
  name: 'zh-cn',
  desc: '',
  select: {
    emptyText: '',
    placeholder: '',
    tagOption: ''
  },
  cascader: {
    loadingRequiredMessage: ' {label} '
  },
  pagination: {
    goto: ' ',
    pageSize: '/',
    total: ' {total} ',
    pageClassifier: ''
  },
  timePicker: {
    placeholder: '',
    confirm: '',
    now: ''
  },
  datePicker: {
    confirm: '',
    select: '',
    selectTime: '',
    selectDate: '',
    selectDateTime: '',
    selectMonth: '',
    selectYear: '',
    selectQuarter: '',
    selectStartTime: '',
    selectEndTime: '',
    selectStartDate: '',
    selectEndDate: '',
    selectStartDateTime: '',
    selectEndDateTime: '',
    selectStartDateMonth: '',
    selectEndDateMonth: '',
    now: '',
    today: '',
    current: '',
    currentYear: '',
    currentMonth: '',
    currentQuarter: '',
    year: '',
    month1: '1 ',
    month2: '2 ',
    month3: '3 ',
    month4: '4 ',
    month5: '5 ',
    month6: '6 ',
    month7: '7 ',
    month8: '8 ',
    month9: '9 ',
    month10: '10 ',
    month11: '11 ',
    month12: '12 ',
    weeks: {
      sun: '',
      mon: '',
      tue: '',
      wed: '',
      thu: '',
      fri: '',
      sat: ''
    },
    months: {
      jan: '',
      feb: '',
      mar: '',
      apr: '',
      may: '',
      jun: '',
      jul: '',
      aug: '',
      sep: '',
      oct: '',
      nov: '',
      dec: ''
    },
    quarters: {
      Q1: 'Q1',
      Q2: 'Q2',
      Q3: 'Q3',
      Q4: 'Q4'
    }
  },
  upload: {
    btnText: '',
    fileTypeInvalidTip: ''
  },
  modal: {
    okText: '',
    cancelText: ''
  }
};

var enUS = {
  name: 'en',
  desc: '',
  select: {
    emptyText: 'No Data',
    placeholder: 'Select',
    tagOption: 'Custom'
  },
  cascader: {
    loadingRequiredMessage: "Please load all {label}'s descendants before checking it."
  },
  pagination: {
    goto: 'Go to',
    pageSize: '/Page',
    total: 'Total {total}',
    pageClassifier: ''
  },
  timePicker: {
    placeholder: 'Please Input',
    confirm: 'OK',
    now: 'Now'
  },
  datePicker: {
    confirm: 'OK',
    select: 'Please Select',
    selectTime: 'Select Time',
    selectDate: 'Select Date',
    selectDateTime: 'Select DateTime',
    selectMonth: 'Select Month',
    selectYear: 'Select Year',
    selectQuarter: 'Select Quarter',
    selectStartTime: 'Start Time',
    selectEndTime: 'End Time',
    selectStartDate: 'Start Date',
    selectEndDate: 'End Date',
    selectStartDateTime: 'Start DateTime',
    selectEndDateTime: 'End DateTime',
    selectStartDateMonth: 'Start Month',
    selectEndDateMonth: 'End Month',
    now: 'Now',
    today: 'Today',
    current: 'Current',
    currentYear: 'Current Year',
    currentMonth: 'Current Month',
    currentQuarter: 'Current Quarter',
    year: '',
    month1: 'January',
    month2: 'February',
    month3: 'March',
    month4: 'April',
    month5: 'May',
    month6: 'June',
    month7: 'July',
    month8: 'August',
    month9: 'September',
    month10: 'October',
    month11: 'November',
    month12: 'December',
    weeks: {
      sun: 'Sun',
      mon: 'Mon',
      tue: 'Tue',
      wed: 'Wed',
      thu: 'Thu',
      fri: 'Fri',
      sat: 'Sat'
    },
    months: {
      jan: 'Jan',
      feb: 'Feb',
      mar: 'Mar',
      apr: 'Apr',
      may: 'May',
      jun: 'Jun',
      jul: 'Jul',
      aug: 'Aug',
      sep: 'Sep',
      oct: 'Oct',
      nov: 'Nov',
      dec: 'Dec'
    },
    quarters: {
      Q1: 'Q1',
      Q2: 'Q2',
      Q3: 'Q3',
      Q4: 'Q4'
    }
  },
  upload: {
    btnText: 'Upload File',
    fileTypeInvalidTip: 'Upload file format is incorrect!'
  },
  modal: {
    okText: 'Confirm',
    cancelText: 'Cancel'
  }
};

const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
  var _option$key;

  return `${(_option$key = option === null || option === void 0 ? void 0 : option[key]) !== null && _option$key !== void 0 ? _option$key : `{${key}}`}`;
});

const buildTranslator = locale => (path, option) => translate(path, option, unref(locale));

const useLocale = () => {
  const providerConfig = inject(CONFIG_PROVIDER_INJECTION_KEY, {});
  const localeRef = computed(() => {
    var _providerConfig$local;

    return ((_providerConfig$local = providerConfig.locale) === null || _providerConfig$local === void 0 ? void 0 : _providerConfig$local.value) || zhCN;
  });
  return {
    lang: computed(() => {
      return localeRef.value.name;
    }),
    locale: localeRef,
    t: buildTranslator(localeRef)
  };
};

function ownKeys$z(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$z(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$z(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$z(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$N = getPrefixCls('modal');
const UPDATE_SHOW_EVENT$1 = 'update:show';
const OK_EVENT$1 = 'ok';
const CANCEL_EVENT$1 = 'cancel';
const AFTER_LEAVE_EVENT$1 = 'after-leave';

const modalIconMap = _objectSpread$z(_objectSpread$z({}, iconComponentMap), {}, {
  confirm: iconComponentMap.warning
});

// 
const globalModalProps = {
  type: {
    type: String,
    default: 'info'
  },
  content: String,
  forGlobal: Boolean
}; // 

const modalProps = {
  show: Boolean,
  displayDirective: {
    type: String,
    default: 'show'
  },
  closable: {
    type: Boolean,
    default: true
  },
  mask: {
    type: Boolean,
    default: true
  },
  maskClosable: {
    type: Boolean,
    default: true
  },
  title: String,
  okText: String,
  cancelText: String,
  width: {
    type: [String, Number],
    default: 520
  },
  top: {
    type: [String, Number],
    default: 50
  },
  verticalCenter: Boolean,
  center: Boolean,
  footer: {
    type: Boolean,
    default: true
  },
  getContainer: {
    type: Function
  },
  fullScreen: {
    type: Boolean,
    default: false
  },
  contentClass: String
};
const Modal = defineComponent({
  name: 'FModal',
  props: _objectSpread$z(_objectSpread$z({}, globalModalProps), modalProps),
  emits: [UPDATE_SHOW_EVENT$1, OK_EVENT$1, CANCEL_EVENT$1, AFTER_LEAVE_EVENT$1],

  setup(props, ctx) {
    useTheme();
    const zIndex = ref(PopupManager$1.nextZIndex());
    const visible = ref(false);
    useLockScreen(visible);
    watch(() => props.show, () => {
      if (props.show) zIndex.value = PopupManager$1.nextZIndex();
      nextTick(() => {
        visible.value = props.show;
      });
    }, {
      immediate: true
    });
    const config = useConfig();
    const getContainer = computed(() => {
      var _config$getContainer;

      return props.getContainer || ((_config$getContainer = config.getContainer) === null || _config$getContainer === void 0 ? void 0 : _config$getContainer.value);
    });
    const {
      t
    } = useLocale();

    function handleCancel(event) {
      ctx.emit(UPDATE_SHOW_EVENT$1, false);
      ctx.emit(CANCEL_EVENT$1, event);
    }

    useEsc(handleCancel);

    function handleOk(event) {
      ctx.emit(OK_EVENT$1, event);
    }

    function handleTransitionAfterLeave(el) {
      ctx.emit(AFTER_LEAVE_EVENT$1, el);
    }

    const hasHeader = computed(() => ctx.slots.title || props.title);

    function getHeader() {
      var _ctx$slots$title, _ctx$slots;

      const closeJsx = props.closable && createVNode("div", {
        "class": `${prefixCls$N}-close`,
        "onClick": handleCancel
      }, [createVNode(CloseOutlined, null, null)]);

      if (!hasHeader.value) return closeJsx;
      const header = ((_ctx$slots$title = (_ctx$slots = ctx.slots).title) === null || _ctx$slots$title === void 0 ? void 0 : _ctx$slots$title.call(_ctx$slots)) || props.title;
      return createVNode("div", {
        "class": `${prefixCls$N}-header`
      }, [props.forGlobal && createVNode("div", {
        "class": `${prefixCls$N}-icon ${prefixCls$N}-status-${props.type}`
      }, [props.type && modalIconMap[props.type]()]), createVNode("div", null, [header]), closeJsx]);
    }

    function getFooter() {
      if (!props.footer) return null;
      let footer = null;

      if (ctx.slots.footer) {
        footer = ctx.slots.footer();
      } else {
        footer = createVNode(Fragment, null, [(!props.forGlobal || props.type === 'confirm') && createVNode(FButton$1, {
          "size": "middle",
          "class": "btn-margin",
          "onClick": handleCancel
        }, {
          default: () => [props.cancelText || t('modal.cancelText')]
        }), createVNode(FButton$1, {
          "type": "primary",
          "size": "middle",
          "onClick": handleOk
        }, {
          default: () => [props.okText || t('modal.okText')]
        })]);
      }

      return createVNode("div", {
        "class": `${prefixCls$N}-footer`
      }, [footer]);
    }

    const styles = computed(() => {
      if (props.fullScreen) return {};
      return {
        width: isNumber(props.width) ? `${props.width}px` : props.width,
        marginTop: props.verticalCenter ? 0 : isNumber(props.top) ? `${props.top}px` : props.top
      };
    });
    const showDom = computed(() => props.displayDirective === 'if' && visible.value || props.displayDirective === 'show');
    return () => {
      var _getContainer$value, _getContainer$value2;

      return createVNode(Teleport, {
        "disabled": !((_getContainer$value = getContainer.value) !== null && _getContainer$value !== void 0 && _getContainer$value.call(getContainer)),
        "to": (_getContainer$value2 = getContainer.value) === null || _getContainer$value2 === void 0 ? void 0 : _getContainer$value2.call(getContainer)
      }, {
        default: () => [createVNode("div", {
          "class": `${prefixCls$N}`
        }, [createVNode(Transition, {
          "name": `${prefixCls$N}-mask-fade`
        }, {
          default: () => [props.mask && showDom.value && withDirectives(createVNode("div", {
            "class": `${prefixCls$N}-mask`,
            "style": {
              zIndex: zIndex.value
            }
          }, null), [[vShow, visible.value]])]
        }), createVNode(Transition, {
          "name": `${prefixCls$N}-fade`,
          "onAfterLeave": handleTransitionAfterLeave
        }, {
          default: () => [showDom.value && withDirectives(createVNode("div", {
            "class": {
              [`${prefixCls$N}-container`]: true,
              [`${prefixCls$N}-center`]: props.center,
              [`${prefixCls$N}-vertical-center`]: props.verticalCenter,
              [`${prefixCls$N}-fullscreen`]: props.fullScreen,
              [`${prefixCls$N}-global`]: props.forGlobal,
              [`${prefixCls$N}-no-header`]: !hasHeader.value,
              [`${prefixCls$N}-no-footer`]: !props.footer
            },
            "style": {
              zIndex: zIndex.value
            },
            "onClick": event => props.maskClosable && props.mask && handleCancel(event)
          }, [createVNode("div", {
            "class": `${prefixCls$N}-wrapper ${props.contentClass || ''}`,
            "style": styles.value,
            "onClick": event => event.stopPropagation()
          }, [getHeader(), createVNode("div", {
            "class": `${prefixCls$N}-body`
          }, [ctx.slots.default ? ctx.slots.default() : props.forGlobal && props.content]), getFooter()])]), [[vShow, visible.value]])]
        })])]
      });
    };
  }

});
var Modal$1 = Modal;

function ownKeys$y(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$y(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$y(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$y(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const forceProps = {
  maskClosable: false,
  forGlobal: true,
  displayDirective: 'if',
  footer: true
};
const defaultConfig = {
  getContainer: () => document.body,
  width: 400,
  closable: false
};
let mergeConfig = defaultConfig;
/**
 * Model
 */

function create(type, config) {
  const div = document.createElement('div');
  const slots = {};

  const mergeProps = _objectSpread$y(_objectSpread$y({}, mergeConfig), {}, {
    show: true
  });

  let cbFuncEnd = false;

  function removeModal() {
    render$w(null, div);
  }

  function renderModal() {
    const props = _objectSpread$y(_objectSpread$y(_objectSpread$y({}, mergeProps), forceProps), {}, {
      type,
      onAfterLeave: removeModal
    });

    render$w(createVNode(Modal$1, props, slots), div);
  }

  async function handleCallBack(event, cbFunc) {
    if (cbFuncEnd) return;
    cbFuncEnd = true;

    try {
      if (isFunction(cbFunc)) await cbFunc(event);
      mergeProps.show = false;
      renderModal();
    } catch (error) {}

    cbFuncEnd = false;
  }

  function updateProps(options) {
    //  props
    Object.assign(mergeProps, options || {});

    mergeProps.onOk = event => handleCallBack(event, options.onOk);

    mergeProps.onCancel = event => handleCallBack(event, options.onCancel); //  slots


    ['title', 'content', 'footer'].forEach(key => {
      const slot = options[key];

      if (slot) {
        slots[key] = isFunction(slot) ? slot : () => slot;
      }

      if (key === 'content') {
        slots.default = slots.content;
        delete slots.content;
      }

      delete mergeProps[key];
    });
  }

  function update(options) {
    if (mergeProps.show) {
      // 
      updateProps(options);
      renderModal();
    }
  }

  function destroy() {
    mergeProps.show = false;
    renderModal();
  }

  updateProps(config);
  renderModal();
  return {
    update,
    destroy
  };
}

var Api = {
  config(config) {
    if (config) {
      mergeConfig = _objectSpread$y(_objectSpread$y({}, defaultConfig), config);
    }
  },

  info: config => create('info', config),
  warning: config => create('warning', config),
  warn: config => create('warning', config),
  success: config => create('success', config),
  error: config => create('error', config),
  confirm: config => create('confirm', config)
};

Object.keys(Api).forEach(key => {
  Modal$1[key] = Api[key];
});
const FModal = withInstall(Modal$1);

const FPopper = withInstall(Popper);

const radioGroupKey = Symbol('FRadioGroup');
const name = 'FRadioGroup';
const radioGroupProps = {
  modelValue: {
    type: [String, Number, Boolean]
  },
  vertical: Boolean,
  disabled: Boolean,
  cancelable: {
    type: Boolean,
    default: true
  },
  options: {
    type: Array,
    default: () => []
  },
  valueField: {
    type: String,
    default: 'value'
  },
  labelField: {
    type: String,
    default: 'label'
  },
  size: {
    type: String,
    default: 'middle'
  },
  type: {
    type: String,
    default: 'default'
  },
  bordered: {
    type: Boolean,
    default: true
  },
  optionType: {
    type: String,
    default: 'default'
  }
};

function ownKeys$x(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$x(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$x(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$x(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const __default__ = {
  name: 'FRadio'
};
var script$q = /*#__PURE__*/defineComponent(_objectSpread$x(_objectSpread$x({}, __default__), {}, {
  props: {
    modelValue: {
      type: Boolean,
      required: false,
      default: false
    },
    value: {
      type: [String, Number, Boolean],
      required: false
    },
    label: {
      type: [String, Number],
      required: false
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    }
  },

  setup(__props, _ref) {
    let {
      emit
    } = _ref;
    const props = __props;
    const prefixCls = getPrefixCls('radio');
    useTheme();
    const {
      isGroup,
      group,
      hover,
      checked,
      innerDisabled,
      handleClick,
      handleMouseOver,
      handleMouseOut
    } = useSelect$1({
      props,
      emit,
      parent: {
        groupKey: radioGroupKey,
        name
      }
    });
    const wrapperClass = computed(() => {
      const arr = [`${prefixCls}`];

      if (checked.value) {
        arr.push('is-checked');
      }

      if (innerDisabled.value) {
        arr.push('is-disabled');
      }

      if (hover.value) {
        arr.push('is-hover');
      }

      if (isGroup) {
        arr.push('is-item');

        if (group.props.vertical) {
          arr.push('is-item-vertical');
        }
      }

      return arr;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("label", {
        class: normalizeClass(unref(wrapperClass)),
        onClick: _cache[0] || (_cache[0] = //@ts-ignore
        function () {
          return unref(handleClick) && unref(handleClick)(...arguments);
        }),
        onMouseover: _cache[1] || (_cache[1] = //@ts-ignore
        function () {
          return unref(handleMouseOver) && unref(handleMouseOver)(...arguments);
        }),
        onMouseout: _cache[2] || (_cache[2] = //@ts-ignore
        function () {
          return unref(handleMouseOut) && unref(handleMouseOut)(...arguments);
        })
      }, [createElementVNode("span", {
        class: normalizeClass(`${unref(prefixCls)}-inner`)
      }, null, 2
      /* CLASS */
      ), createElementVNode("span", {
        class: normalizeClass(`${unref(prefixCls)}-content`)
      }, [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(__props.label), 1
      /* TEXT */
      )])], 2
      /* CLASS */
      )], 34
      /* CLASS, HYDRATE_EVENTS */
      );
    };
  }

}));

script$q.__file = "components/radio/radio.vue";

const FRadio = withInstall(script$q);

const prefixCls$M = getPrefixCls('radio-button');
const radioButtonProps = {
  disabled: {
    type: Boolean
  },
  value: {
    type: [String, Number, Boolean]
  },
  label: {
    type: [String, Number]
  }
};
var RadioButton = defineComponent({
  name: 'FRadioButton',
  props: radioButtonProps,
  emits: [CHANGE_EVENT$1, UPDATE_MODEL_EVENT$1],

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const {
      checked,
      innerDisabled,
      handleClick,
      group
    } = useSelect$1({
      props,
      emit,
      parent: {
        groupKey: radioGroupKey,
        name
      }
    });
    useTheme(); // ,

    const btnClasses = computed(() => {
      return [prefixCls$M, `${prefixCls$M}-${group.props.size}`, `${prefixCls$M}-${group.props.bordered ? 'border' : 'no-border'}`, innerDisabled.value && 'is-disabled', checked.value && group.props.bordered ? `is-checked-${group.props.type}-${'border'}` : ''];
    }); // content

    const contentClasses = computed(() => {
      const arr = [`${prefixCls$M}-content-${group.props.size}`]; // 

      if (!group.props.bordered && checked.value) {
        arr.push(`${prefixCls$M}-content-checked`);
        arr.push(`${prefixCls$M}-content-checked-${group.props.size}`);
        arr.push(`${prefixCls$M}-content-checked-${group.props.type}`);
      }

      return arr;
    });
    return () => {
      var _slots$default, _slots$default2;

      return createVNode("div", {
        "class": btnClasses.value,
        "onClick": handleClick
      }, [createVNode("div", {
        "class": contentClasses.value
      }, [(_slots$default = (_slots$default2 = slots.default) === null || _slots$default2 === void 0 ? void 0 : _slots$default2.call(slots)) !== null && _slots$default !== void 0 ? _slots$default : props.label])]);
    };
  }

});

const FRadioButton = withInstall(RadioButton);

const useRadioGroup = (props, emit) => {
  const {
    validate,
    isFormDisabled
  } = useFormAdaptor({
    forbidChildValidate: true
  });
  const [currentValue, updateCurrentValue] = useNormalModel(props, emit);

  const handleChange = () => {
    emit(CHANGE_EVENT$1, currentValue.value);
    validate(CHANGE_EVENT$1);
  };

  const isSelect = value => {
    const radioGroupVal = unref(currentValue);
    const radioVal = unref(value);
    return radioGroupVal === radioVal;
  };

  const onSelect = value => {
    const radioGroupVal = unref(currentValue);
    const radioVal = unref(value);

    if (radioGroupVal === radioVal) {
      if (!props.cancelable) {
        return;
      }

      updateCurrentValue(null);
    } else {
      updateCurrentValue(radioVal);
    }

    handleChange();
  };

  provide(radioGroupKey, {
    name,
    isSelect,
    onSelect,
    props
  });
  return {
    isFormDisabled
  };
};

function ownKeys$w(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$w(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$w(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$w(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$L = getPrefixCls('radio-group');
var script$p = defineComponent({
  name,
  components: {
    FRadio,
    RadioButton: FRadioButton
  },
  props: radioGroupProps,

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    useTheme();
    const {
      isFormDisabled
    } = useRadioGroup(props, emit);
    const classList = computed(() => [prefixCls$L, props.vertical && 'is-vertical', (props.disabled || isFormDisabled.value) && 'is-disabled']);
    const optionsRef = computed(() => props.options.map(opt => {
      return _objectSpread$w(_objectSpread$w({}, opt), {}, {
        value: opt[props.valueField],
        label: opt[props.labelField]
      });
    }));
    return {
      classList,
      optionsRef,
      isFormDisabled
    };
  }

});

function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FRadio = resolveComponent("FRadio");

  const _component_RadioButton = resolveComponent("RadioButton");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classList)
  }, [renderSlot(_ctx.$slots, "default"), _ctx.optionType === 'default' ? (openBlock(true), createElementBlock(Fragment, {
    key: 0
  }, renderList(_ctx.optionsRef, opt => {
    return openBlock(), createBlock(_component_FRadio, {
      key: opt.value,
      value: opt.value,
      label: opt.label,
      disabled: opt.disabled || _ctx.isFormDisabled
    }, null, 8
    /* PROPS */
    , ["value", "label", "disabled"]);
  }), 128
  /* KEYED_FRAGMENT */
  )) : (openBlock(true), createElementBlock(Fragment, {
    key: 1
  }, renderList(_ctx.optionsRef, opt => {
    return openBlock(), createBlock(_component_RadioButton, {
      key: opt.value,
      value: opt.value,
      label: opt.label,
      disabled: opt.disabled || _ctx.isFormDisabled
    }, null, 8
    /* PROPS */
    , ["value", "label", "disabled"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  );
}

script$p.render = render$n;
script$p.__file = "components/radio-group/radio-group.vue";

const FRadioGroup = withInstall(script$p);

function ownKeys$v(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$v(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$v(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$v(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const BAR_MAP = {
  vertical: {
    offset: 'offsetHeight',
    scroll: 'scrollTop',
    scrollSize: 'scrollHeight',
    size: 'height',
    key: 'vertical',
    axis: 'Y',
    client: 'clientY',
    direction: 'top'
  },
  horizontal: {
    offset: 'offsetWidth',
    scroll: 'scrollLeft',
    scrollSize: 'scrollWidth',
    size: 'width',
    key: 'horizontal',
    axis: 'X',
    client: 'clientX',
    direction: 'left'
  }
};
const COMMON_PROPS$1 = {
  shadow: {
    type: [Boolean, Object],
    default: false
  }
};
const scrollbarProps = _objectSpread$v({
  height: {
    type: [Number, String]
  },
  maxHeight: {
    type: [Number, String]
  },
  native: {
    type: Boolean,
    default: false
  },
  containerClass: [Array, Object, String],
  containerStyle: [String, Object],
  contentStyle: [String, Object],
  horizontalRatioStyle: [String, Object],
  verticalRatioStyle: [String, Object],
  shadowStyle: [String, Object],
  noresize: Boolean,
  always: {
    type: Boolean,
    default: false
  },
  minSize: {
    type: Number,
    default: 20
  }
}, COMMON_PROPS$1);

const prefixCls$K = getPrefixCls('scrollbar-track');

function renderThumbStyle(_ref) {
  let {
    move,
    size,
    bar
  } = _ref;
  const style = {};
  const translate = `translate${bar.axis}(${move}%)`;
  style[bar.size] = size;
  style.transform = translate;
  return style;
}

const barProps = {
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: Number,
  always: Boolean,
  scrollbarRef: Array,
  containerRef: Object
};
var script$o = defineComponent({
  name: 'FBar',
  props: barProps,

  setup(props) {
    const containerRef = computed(() => props.containerRef);
    const barStore = ref({});
    const barRef = ref();
    const thumbRef = ref();
    const barMap = computed(() => BAR_MAP[props.vertical ? 'vertical' : 'horizontal']);
    const thumbStyle = computed(() => renderThumbStyle({
      size: props.size,
      move: props.move,
      bar: barMap.value
    }));
    const offsetRatio = computed(() => barRef.value[barMap.value.offset] ** 2 / containerRef.value[barMap.value.scrollSize] / props.ratio / thumbRef.value[barMap.value.offset]);
    const visible = ref(false);
    const cursorLeave = ref();
    const cursorDown = ref();
    let onselectstartStore = null;

    const mouseMoveDocumentHandler = e => {
      if (cursorDown.value === false) return;
      const prevPage = barStore.value[barMap.value.axis];
      if (!prevPage) return;
      const offset = (barRef.value.getBoundingClientRect()[barMap.value.direction] - e[barMap.value.client]) * -1;
      const thumbClickPosition = thumbRef.value[barMap.value.offset] - prevPage;
      const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / barRef.value[barMap.value.offset];
      containerRef.value[barMap.value.scroll] = thumbPositionPercentage * containerRef.value[barMap.value.scrollSize] / 100;
    };

    let docMouseMoveClose;

    const mouseUpDocumentHandler = () => {
      var _docMouseMoveClose;

      cursorDown.value = false;
      barStore.value[barMap.value.axis] = 0;
      (_docMouseMoveClose = docMouseMoveClose) === null || _docMouseMoveClose === void 0 ? void 0 : _docMouseMoveClose();
      document.onselectstart = onselectstartStore;

      if (cursorLeave.value) {
        visible.value = false;
      }
    };

    const startDrag = e => {
      e.stopImmediatePropagation();
      cursorDown.value = true;
      docMouseMoveClose = useEventListener(document, 'mousemove', mouseMoveDocumentHandler);
      useEventListener(document, 'mouseup', mouseUpDocumentHandler);
      onselectstartStore = document.onselectstart;

      document.onselectstart = () => false;
    };

    const mouseMoveScrollbarHandler = () => {
      cursorLeave.value = false;
      visible.value = !!props.size;
    };

    const mouseLeaveScrollbarHandler = () => {
      cursorLeave.value = true;
      visible.value = cursorDown.value;
    };

    onMounted(() => {
      nextTick(() => {
        props.scrollbarRef.forEach(item => {
          useEventListener(item, 'mouseenter', mouseMoveScrollbarHandler);
          useEventListener(item, 'mousemove', mouseMoveScrollbarHandler);
          useEventListener(item, 'mouseleave', mouseLeaveScrollbarHandler);
        });
      });
    });

    const clickTrackHandler = e => {
      const offset = Math.abs(e.target.getBoundingClientRect()[barMap.value.direction] - e[barMap.value.client]);
      const thumbHalf = thumbRef.value[barMap.value.offset] / 2;
      const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / barRef.value[barMap.value.offset];
      containerRef.value[barMap.value.scroll] = thumbPositionPercentage * containerRef.value[barMap.value.scrollSize] / 100;
    };

    const clickThumbHandler = e => {
      // prevent click event of middle and right button
      e.stopPropagation();

      if (e.ctrlKey || [1, 2].includes(e.button)) {
        return;
      }

      window.getSelection().removeAllRanges();
      startDrag(e);
      barStore.value[barMap.value.axis] = e.currentTarget[barMap.value.offset] - (e[barMap.value.client] - e.currentTarget.getBoundingClientRect()[barMap.value.direction]);
    };

    return {
      prefixCls: prefixCls$K,
      barRef,
      thumbRef,
      visible,
      cursorDown,
      barMap,
      thumbStyle,
      clickTrackHandler,
      clickThumbHandler
    };
  }

});

function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: `${_ctx.prefixCls}-fade`,
    persisted: ""
  }, {
    default: withCtx(() => [withDirectives(createElementVNode("div", {
      ref: "barRef",
      class: normalizeClass([_ctx.prefixCls, `is-${_ctx.barMap.key}`]),
      onMousedown: _cache[1] || (_cache[1] = withModifiers(function () {
        return _ctx.clickTrackHandler && _ctx.clickTrackHandler(...arguments);
      }, ["stop", "prevent"]))
    }, [createElementVNode("div", {
      ref: "thumbRef",
      class: normalizeClass([`${_ctx.prefixCls}-thumb`, _ctx.cursorDown && `is-hovering`]),
      style: normalizeStyle(_ctx.thumbStyle),
      onMousedown: _cache[0] || (_cache[0] = withModifiers(function () {
        return _ctx.clickThumbHandler && _ctx.clickThumbHandler(...arguments);
      }, ["stop", "prevent"]))
    }, null, 38
    /* CLASS, STYLE, HYDRATE_EVENTS */
    )], 34
    /* CLASS, HYDRATE_EVENTS */
    ), [[vShow, _ctx.always || _ctx.visible]])]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["name"]);
}

script$o.render = render$m;
script$o.__file = "components/scrollbar/bar.vue";

var useScrollbar = (props => {
  const containerRef = ref();
  const ratioX = ref(1);
  const ratioY = ref(1);
  const thumbMoveX = ref(0);
  const thumbMoveY = ref(0);
  const sizeHeight = ref('0');
  const sizeWidth = ref('0');
  const scrollX = ref(false);
  const scrollXRatio = ref(0);
  const scrollY = ref(false);
  const scrollYRatio = ref(0);
  const GAP = 4;

  const onUpdate = () => {
    if (containerRef.value) {
      const offsetHeight = containerRef.value.offsetHeight - GAP;
      const offsetWidth = containerRef.value.offsetWidth - GAP;
      const originalThumbHeight = offsetHeight ** 2 / containerRef.value.scrollHeight;
      const originalThumbWidth = offsetWidth ** 2 / containerRef.value.scrollWidth;
      const height = Math.max(originalThumbHeight, props.minSize);
      const width = Math.max(originalThumbWidth, props.minSize);
      ratioY.value = originalThumbHeight / (offsetHeight - originalThumbHeight) / (height / (offsetHeight - height));
      ratioX.value = originalThumbWidth / (offsetWidth - originalThumbWidth) / (width / (offsetWidth - width));
      sizeHeight.value = height + GAP < offsetHeight ? addUnit(height) : '';
      sizeWidth.value = width + GAP < offsetWidth ? addUnit(width) : '';
    }
  };

  const onScroll = () => {
    const containerRefValue = containerRef.value;

    if (containerRefValue) {
      const offsetHeight = containerRefValue.offsetHeight - GAP;
      const offsetWidth = containerRefValue.offsetWidth - GAP; // 

      thumbMoveY.value = containerRefValue.scrollTop * 100 / offsetHeight * ratioY.value;
      thumbMoveX.value = containerRefValue.scrollLeft * 100 / offsetWidth * ratioX.value;
      scrollY.value = containerRefValue.scrollHeight > containerRefValue.offsetHeight;
      scrollYRatio.value = containerRefValue.scrollTop / (containerRefValue.scrollHeight - containerRefValue.offsetHeight);
      scrollX.value = containerRefValue.scrollWidth > containerRefValue.offsetWidth;
      scrollXRatio.value = containerRefValue.scrollLeft / (containerRefValue.scrollWidth - containerRefValue.offsetWidth);
    }
  };

  return {
    containerRef,
    onUpdate,
    onScroll,
    ratioX,
    ratioY,
    thumbMoveX,
    thumbMoveY,
    sizeHeight,
    sizeWidth,
    scrollX,
    scrollXRatio,
    scrollY,
    scrollYRatio
  };
});

const prefixCls$J = getPrefixCls('scrollbar');
var script$n = defineComponent({
  name: 'FScrollbar',
  components: {
    FBar: script$o
  },
  props: scrollbarProps,
  emits: ['scroll'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    useTheme();
    const {
      onUpdate,
      onScroll,
      containerRef,
      ratioX,
      ratioY,
      thumbMoveX,
      thumbMoveY,
      sizeHeight,
      sizeWidth,
      scrollX,
      scrollXRatio,
      scrollY,
      scrollYRatio
    } = useScrollbar(props);
    const scrollbarRef = ref();
    const contentRef = ref();
    const shadowRef = computed(() => {
      if (typeof props.shadow === 'boolean') {
        return {
          x: props.shadow,
          y: props.shadow
        };
      }

      return props.shadow;
    });
    const style = computed(() => [props.containerStyle, {
      height: addUnit(props.height),
      maxHeight: addUnit(props.maxHeight)
    }]);
    const wrapperClassRef = computed(() => [prefixCls$J]);
    const containerClassRef = computed(() => [`${prefixCls$J}-container`, props.containerClass, !props.native && `${prefixCls$J}-hidden-native-bar`]);

    const handleScroll = event => {
      onScroll();
      const containerRefValue = containerRef.value;

      if (containerRefValue) {
        emit('scroll', event, containerRefValue);
      }
    };

    useResize(contentRef, () => {
      onUpdate();
      onScroll();
    }, computed(() => props.noresize), false);
    useResize(scrollbarRef, () => {
      onUpdate();
      onScroll();
    }, computed(() => props.noresize), false);
    onMounted(() => {
      // contentsetTimeout
      if (!props.native) {
        setTimeout(onUpdate, 0);
      }

      setTimeout(onScroll, 0);
    });

    const move = (type, to, duration) => {
      if (!duration || duration <= 0) {
        containerRef.value[type] = to;
        return;
      }

      const difference = to - containerRef.value[type];
      const perTick = difference / duration * 10;
      requestAnimationFrame$1(() => {
        containerRef.value[type] += perTick;

        if (containerRef.value[type] === to) {
          return;
        }

        move(type, to, duration - 10);
      });
    };

    const setScrollTop = (val, duration) => {
      move('scrollTop', val, duration);
    };

    const setScrollLeft = (val, duration) => {
      move('scrollLeft', val, duration);
    };

    return {
      scrollbarRef,
      containerRef,
      contentRef,
      style,
      prefixCls: prefixCls$J,
      setScrollTop,
      setScrollLeft,
      update: onUpdate,
      handleScroll,
      thumbMoveX,
      thumbMoveY,
      ratioX,
      ratioY,
      sizeHeight,
      sizeWidth,
      wrapperClassRef,
      containerClassRef,
      scrollX,
      scrollXRatio,
      scrollY,
      scrollYRatio,
      shadowRef
    };
  }

});

function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FBar = resolveComponent("FBar");

  return openBlock(), createElementBlock("div", {
    ref: "scrollbarRef",
    class: normalizeClass(_ctx.wrapperClassRef)
  }, [createElementVNode("div", {
    ref: "containerRef",
    class: normalizeClass(_ctx.containerClassRef),
    style: normalizeStyle(_ctx.style),
    onScroll: _cache[0] || (_cache[0] = function () {
      return _ctx.handleScroll && _ctx.handleScroll(...arguments);
    })
  }, [createElementVNode("div", {
    ref: "contentRef",
    class: normalizeClass(`${_ctx.prefixCls}-content`),
    style: normalizeStyle([_ctx.scrollX && {
      width: 'fit-content'
    }, _ctx.contentStyle])
  }, [renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  )], 38
  /* CLASS, STYLE, HYDRATE_EVENTS */
  ), !_ctx.native ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [createVNode(_component_FBar, {
    scrollbarRef: [_ctx.scrollbarRef],
    containerRef: _ctx.containerRef,
    move: _ctx.thumbMoveX,
    ratio: _ctx.ratioX,
    size: _ctx.sizeWidth,
    always: _ctx.always,
    style: normalizeStyle(_ctx.horizontalRatioStyle)
  }, null, 8
  /* PROPS */
  , ["scrollbarRef", "containerRef", "move", "ratio", "size", "always", "style"]), createVNode(_component_FBar, {
    scrollbarRef: [_ctx.scrollbarRef],
    containerRef: _ctx.containerRef,
    move: _ctx.thumbMoveY,
    ratio: _ctx.ratioY,
    size: _ctx.sizeHeight,
    vertical: "",
    always: _ctx.always,
    style: normalizeStyle(_ctx.verticalRatioStyle)
  }, null, 8
  /* PROPS */
  , ["scrollbarRef", "containerRef", "move", "ratio", "size", "always", "style"])], 64
  /* STABLE_FRAGMENT */
  )) : createCommentVNode("v-if", true), _ctx.shadowRef.x && _ctx.scrollX && _ctx.scrollXRatio < 1 ? (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(`${_ctx.prefixCls}-shadow-right`),
    style: normalizeStyle(_ctx.shadowStyle)
  }, null, 6
  /* CLASS, STYLE */
  )) : createCommentVNode("v-if", true), _ctx.shadowRef.x && _ctx.scrollX && _ctx.scrollXRatio > 0 ? (openBlock(), createElementBlock("div", {
    key: 2,
    class: normalizeClass(`${_ctx.prefixCls}-shadow-left`),
    style: normalizeStyle(_ctx.shadowStyle)
  }, null, 6
  /* CLASS, STYLE */
  )) : createCommentVNode("v-if", true), _ctx.shadowRef.y && _ctx.scrollY && _ctx.scrollYRatio < 1 ? (openBlock(), createElementBlock("div", {
    key: 3,
    class: normalizeClass(`${_ctx.prefixCls}-shadow-bottom`),
    style: normalizeStyle(_ctx.shadowStyle)
  }, null, 6
  /* CLASS, STYLE */
  )) : createCommentVNode("v-if", true), _ctx.shadowRef.y && _ctx.scrollY && _ctx.scrollYRatio > 0 ? (openBlock(), createElementBlock("div", {
    key: 4,
    class: normalizeClass(`${_ctx.prefixCls}-shadow-top`),
    style: normalizeStyle(_ctx.shadowStyle)
  }, null, 6
  /* CLASS, STYLE */
  )) : createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$n.render = render$l;
script$n.__file = "components/scrollbar/scrollbar.vue";

const FScrollbar = withInstall(script$n);

const tagProps = {
  type: {
    type: String,
    default: 'default'
  },
  closable: {
    type: Boolean,
    default: false
  },
  backgroundColor: {
    type: String,
    default: ''
  },
  size: {
    type: String,
    default: 'middle'
  },
  effect: {
    type: String,
    default: 'light'
  },
  bordered: {
    type: Boolean,
    default: true
  }
};

function useHover() {
  const isHover = ref(false);

  const mouseCloseOver = () => {
    isHover.value = true;
  };

  const mouseCloseLeave = () => {
    isHover.value = false;
  };

  return {
    isHover,
    mouseCloseOver,
    mouseCloseLeave
  };
}

function ownKeys$u(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$u(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$u(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$u(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$I = getPrefixCls('tag');
var script$m = defineComponent({
  name: 'FTag',
  components: {
    CloseCircleFilled,
    CloseCircleOutlined
  },
  props: _objectSpread$u({}, tagProps),
  emits: ['click', CLOSE_EVENT],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    useTheme();
    const classes = computed(() => ({
      [prefixCls$I]: true,
      [`${prefixCls$I}-type--${props.type}`]: props.type,
      [`${prefixCls$I}-size--${props.size}`]: props.size,
      [`${prefixCls$I}-effect--${props.effect}`]: props.effect,
      'is-bordered': props.bordered
    }));

    const handleClose = event => {
      emit(CLOSE_EVENT, event);
    };

    const handleClick = event => {
      emit('click', event);
    };

    const {
      isHover,
      mouseCloseOver,
      mouseCloseLeave
    } = useHover();
    return {
      prefixCls: prefixCls$I,
      classes,
      handleClose,
      handleClick,
      isHover,
      mouseCloseOver,
      mouseCloseLeave
    };
  }

});

function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CloseCircleOutlined = resolveComponent("CloseCircleOutlined");

  const _component_CloseCircleFilled = resolveComponent("CloseCircleFilled");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle({
      backgroundColor: _ctx.backgroundColor
    }),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.handleClick && _ctx.handleClick(...arguments);
    })
  }, [_ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", {
    key: 0
  }) : createCommentVNode("v-if", true), renderSlot(_ctx.$slots, "default"), _ctx.closable ? (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [withDirectives(createVNode(_component_CloseCircleOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}__close`),
    onClick: withModifiers(_ctx.handleClose, ["stop"]),
    onMouseover: _ctx.mouseCloseOver
  }, null, 8
  /* PROPS */
  , ["class", "onClick", "onMouseover"]), [[vShow, !_ctx.isHover]]), withDirectives(createVNode(_component_CloseCircleFilled, {
    class: normalizeClass(`${_ctx.prefixCls}__close`),
    onClick: withModifiers(_ctx.handleClose, ["stop"]),
    onMouseleave: _ctx.mouseCloseLeave
  }, null, 8
  /* PROPS */
  , ["class", "onClick", "onMouseleave"]), [[vShow, _ctx.isHover]])], 64
  /* STABLE_FRAGMENT */
  )) : createCommentVNode("v-if", true)], 6
  /* CLASS, STYLE */
  );
}

script$m.render = render$k;
script$m.__file = "components/tag/tag.vue";

var RenderTag = defineComponent({
  props: {
    option: Object,
    renderTag: Function
  },
  emits: ['close'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;

    const handleClose = () => {
      emit('close');
    };

    return () => {
      var _slots$default;

      const {
        option,
        renderTag
      } = props;

      if (renderTag) {
        return renderTag({
          option,
          handleClose
        });
      }

      return (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
    };
  }

});

function ownKeys$t(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$t(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$t(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$t(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$H = getPrefixCls('select-trigger');
const selectTriggerProps = {
  selectedOptions: {
    type: Array,

    default() {
      return [];
    }

  },
  disabled: Boolean,
  clearable: Boolean,
  isOpened: Boolean,
  multiple: Boolean,
  filterable: Boolean,
  placeholder: String,
  collapseTags: Boolean,
  collapseTagsLimit: Number,
  renderTag: Function,
  tagBordered: {
    type: Boolean,
    default: false
  }
};
var script$l = defineComponent({
  name: 'FSelect',
  components: {
    Tag: script$m,
    Ellipsis: FEllipsis,
    UpOutlined,
    DownOutlined,
    CloseCircleFilled,
    RenderTag
  },
  props: selectTriggerProps,
  emits: ['remove', 'clear', 'focus', 'blur', 'input'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    useTheme();
    const inputHoveringRef = ref(false);
    const inputRef = ref();
    const filterTextRef = ref('');
    const isComposingRef = ref(false);
    const compositionValueRef = ref('');
    const isFocusRef = ref(false);
    const unSelectedRef = computed(() => props.selectedOptions.length === 0);
    const hasClearRef = computed(() => !props.disabled && props.clearable && !unSelectedRef.value && inputHoveringRef.value);
    const inputWidthRef = computed(() => {
      const totalText = filterTextRef.value + compositionValueRef.value;
      return totalText.length ? `${totalText.length + 1}em` : '1em';
    });
    const triggerClass = computed(() => ({
      [`${prefixCls$H}`]: true,
      'is-active': props.isOpened || isFocusRef.value,
      'is-disabled': props.disabled,
      'is-multiple': props.multiple
    }));

    const genTag = option => {
      var _ref2;

      const {
        label,
        value
      } = option;
      return _objectSpread$t(_objectSpread$t({}, option), {}, {
        label: (_ref2 = label !== null && label !== void 0 ? label : value) !== null && _ref2 !== void 0 ? _ref2 : '',
        closable: !props.disabled
      });
    };

    const labelTextRef = computed(() => {
      const options = props.selectedOptions;

      if (options.length) {
        var _ref3, _options$0$label;

        return `${(_ref3 = (_options$0$label = options[0].label) !== null && _options$0$label !== void 0 ? _options$0$label : options[0].value) !== null && _ref3 !== void 0 ? _ref3 : ''}`;
      }

      return '';
    });
    const multiLabelRef = computed(() => {
      const options = props.selectedOptions;
      const tags = [];

      if (props.collapseTags) {
        const showOptions = options.slice(0, props.collapseTagsLimit);
        const rest = options.slice(props.collapseTagsLimit);
        const restCount = rest.length;
        showOptions.forEach(option => tags.push(genTag(option)));

        if (restCount > 0) {
          tags.push({
            isCollapsed: true,
            value: null,
            label: `+ ${restCount}`,
            closable: false
          });
        }
      } else {
        options.forEach(option => tags.push(genTag(option)));
      }

      return tags;
    });
    const hasTagBordered = computed(() => {
      return props.disabled || props.tagBordered;
    });

    const handleFocus = event => {
      if (props.disabled) return;
      isFocusRef.value = true;
      emit('focus', event);
    };

    const handleBlur = event => {
      if (props.disabled) return;
      isFocusRef.value = false;

      if (filterTextRef.value) {
        filterTextRef.value = '';
        emit('input', filterTextRef.value, {
          isClear: true
        });
      }

      emit('blur', event);
    };

    const handleRemove = index => {
      if (props.disabled) return;
      emit('remove', props.selectedOptions[index].value);
    };

    const handleClear = () => {
      if (props.disabled) return;
      emit('clear');
    };

    const handleInput = e => {
      if (props.disabled || isComposingRef.value) return;
      filterTextRef.value = e.target.value;
      emit('input', filterTextRef.value);
    };

    const handleCompositionStart = () => {
      isComposingRef.value = true;
      compositionValueRef.value = '';
    };

    const handelCompositionUpdate = event => {
      if (isComposingRef.value) {
        compositionValueRef.value = event.target.value;
      }
    };

    const handleCompositionEnd = event => {
      if (isComposingRef.value) {
        compositionValueRef.value = '';
        isComposingRef.value = false;
        handleInput(event);
      }
    };

    const handleMouseDown = e => {
      if (props.filterable && e.target !== inputRef.value) {
        e.preventDefault();
      }
    };

    watch(() => props.isOpened, isOpened => {
      if (isOpened) {
        nextTick(() => {
          if (!inputRef.value) return;
          if (!props.filterable) return;
          inputRef.value.focus();
        });
      }
    });
    watch(() => props.selectedOptions, (val, oldVal) => {
      if (!isEqual(val, oldVal)) {
        filterTextRef.value = '';
      }
    }, {
      deep: true
    });
    return {
      prefixCls: prefixCls$H,
      inputHoveringRef,
      hasClearRef,
      triggerClass,
      unSelectedRef,
      handleRemove,
      handleClear,
      handleFocus,
      handleBlur,
      inputRef,
      filterTextRef,
      handleCompositionStart,
      handelCompositionUpdate,
      handleCompositionEnd,
      handleInput,
      labelTextRef,
      multiLabelRef,
      handleMouseDown,
      isComposingRef,
      compositionValueRef,
      inputWidthRef,
      hasTagBordered
    };
  }

});

const _hoisted_1$8 = ["value", "placeholder", "disabled"];
const _hoisted_2$5 = ["value", "disabled"];
function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Ellipsis = resolveComponent("Ellipsis");

  const _component_RenderTag = resolveComponent("RenderTag");

  const _component_Tag = resolveComponent("Tag");

  const _component_UpOutlined = resolveComponent("UpOutlined");

  const _component_DownOutlined = resolveComponent("DownOutlined");

  const _component_CloseCircleFilled = resolveComponent("CloseCircleFilled");

  return openBlock(), createElementBlock("div", {
    tabindex: "0",
    class: normalizeClass(_ctx.triggerClass),
    onMouseenter: _cache[9] || (_cache[9] = $event => _ctx.inputHoveringRef = true),
    onMouseleave: _cache[10] || (_cache[10] = $event => _ctx.inputHoveringRef = false),
    onFocusin: _cache[11] || (_cache[11] = function () {
      return _ctx.handleFocus && _ctx.handleFocus(...arguments);
    }),
    onFocusout: _cache[12] || (_cache[12] = function () {
      return _ctx.handleBlur && _ctx.handleBlur(...arguments);
    }),
    onMousedown: _cache[13] || (_cache[13] = function () {
      return _ctx.handleMouseDown && _ctx.handleMouseDown(...arguments);
    })
  }, [createElementVNode("div", {
    class: normalizeClass([`${_ctx.prefixCls}-label`, _ctx.multiple && 'is-multiple', _ctx.unSelectedRef && 'is-selected-null'])
  }, [!_ctx.multiple ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [!_ctx.filterable ? (openBlock(), createElementBlock(Fragment, {
    key: 0
  }, [!_ctx.unSelectedRef ? (openBlock(), createBlock(_component_RenderTag, {
    key: 0,
    renderTag: _ctx.renderTag,
    option: _ctx.selectedOptions[0]
  }, {
    default: withCtx(() => [createVNode(_component_Ellipsis, {
      class: normalizeClass(`${_ctx.prefixCls}-label-text`),
      content: _ctx.labelTextRef
    }, null, 8
    /* PROPS */
    , ["class", "content"])]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["renderTag", "option"])) : (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(`${_ctx.prefixCls}-label-placeholder`)
  }, toDisplayString(_ctx.placeholder), 3
  /* TEXT, CLASS */
  ))], 64
  /* STABLE_FRAGMENT */
  )) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [createElementVNode("input", {
    ref: "inputRef",
    value: _ctx.filterTextRef,
    placeholder: _ctx.isOpened || _ctx.unSelectedRef ? _ctx.labelTextRef || _ctx.placeholder : '',
    class: normalizeClass(`${_ctx.prefixCls}-label-input`),
    disabled: _ctx.disabled,
    onInput: _cache[0] || (_cache[0] = function () {
      return _ctx.handleInput && _ctx.handleInput(...arguments);
    }),
    onCompositionstart: _cache[1] || (_cache[1] = function () {
      return _ctx.handleCompositionStart && _ctx.handleCompositionStart(...arguments);
    }),
    onCompositionupdate: _cache[2] || (_cache[2] = function () {
      return _ctx.handelCompositionUpdate && _ctx.handelCompositionUpdate(...arguments);
    }),
    onCompositionend: _cache[3] || (_cache[3] = function () {
      return _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...arguments);
    })
  }, null, 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , _hoisted_1$8), !(_ctx.unSelectedRef || _ctx.isOpened) ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-label-overlay`)
  }, [createVNode(_component_RenderTag, {
    renderTag: _ctx.renderTag,
    option: _ctx.selectedOptions[0]
  }, {
    default: withCtx(() => [createVNode(_component_Ellipsis, {
      class: normalizeClass(`${_ctx.prefixCls}-label-text`),
      content: _ctx.labelTextRef
    }, null, 8
    /* PROPS */
    , ["class", "content"])]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["renderTag", "option"])], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true)], 64
  /* STABLE_FRAGMENT */
  ))], 64
  /* STABLE_FRAGMENT */
  )) : (openBlock(), createElementBlock(Fragment, {
    key: 1
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.multiLabelRef, (tag, index) => {
    return openBlock(), createBlock(_component_RenderTag, {
      key: index,
      renderTag: _ctx.renderTag,
      option: tag,
      onClose: $event => _ctx.handleRemove(index)
    }, {
      default: withCtx(() => [createVNode(_component_Tag, {
        type: "info",
        size: "small",
        closable: tag.closable,
        class: normalizeClass(`${_ctx.prefixCls}-label-item`),
        bordered: _ctx.hasTagBordered,
        onClose: $event => _ctx.handleRemove(index)
      }, {
        default: withCtx(() => [createVNode(_component_Ellipsis, {
          class: normalizeClass(`${_ctx.prefixCls}-label-text`),
          content: tag.label
        }, null, 8
        /* PROPS */
        , ["class", "content"])]),
        _: 2
        /* DYNAMIC */

      }, 1032
      /* PROPS, DYNAMIC_SLOTS */
      , ["closable", "class", "bordered", "onClose"])]),
      _: 2
      /* DYNAMIC */

    }, 1032
    /* PROPS, DYNAMIC_SLOTS */
    , ["renderTag", "option", "onClose"]);
  }), 128
  /* KEYED_FRAGMENT */
  )), _ctx.unSelectedRef && !_ctx.filterTextRef.length && !_ctx.isComposingRef ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass([`${_ctx.prefixCls}-label-placeholder`, `${_ctx.prefixCls}-label-overlay`])
  }, toDisplayString(_ctx.placeholder), 3
  /* TEXT, CLASS */
  )) : createCommentVNode("v-if", true), _ctx.filterable ? (openBlock(), createElementBlock("input", {
    key: 1,
    ref: "inputRef",
    value: _ctx.filterTextRef,
    class: normalizeClass(`${_ctx.prefixCls}-label-input`),
    style: normalizeStyle({
      width: _ctx.inputWidthRef
    }),
    disabled: _ctx.disabled,
    onCompositionstart: _cache[4] || (_cache[4] = function () {
      return _ctx.handleCompositionStart && _ctx.handleCompositionStart(...arguments);
    }),
    onCompositionend: _cache[5] || (_cache[5] = function () {
      return _ctx.handleCompositionEnd && _ctx.handleCompositionEnd(...arguments);
    }),
    onCompositionupdate: _cache[6] || (_cache[6] = function () {
      return _ctx.handelCompositionUpdate && _ctx.handelCompositionUpdate(...arguments);
    }),
    onInput: _cache[7] || (_cache[7] = function () {
      return _ctx.handleInput && _ctx.handleInput(...arguments);
    })
  }, null, 46
  /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
  , _hoisted_2$5)) : createCommentVNode("v-if", true)], 64
  /* STABLE_FRAGMENT */
  ))], 2
  /* CLASS */
  ), createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-icons`),
    onMousedown: _cache[8] || (_cache[8] = withModifiers(() => {}, ["prevent"]))
  }, [withDirectives(createVNode(_component_UpOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-icon`)
  }, null, 8
  /* PROPS */
  , ["class"]), [[vShow, _ctx.isOpened && !_ctx.hasClearRef]]), withDirectives(createVNode(_component_DownOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-icon`)
  }, null, 8
  /* PROPS */
  , ["class"]), [[vShow, !_ctx.isOpened && !_ctx.hasClearRef]]), _ctx.clearable ? withDirectives((openBlock(), createBlock(_component_CloseCircleFilled, {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-icon`),
    onClick: withModifiers(_ctx.handleClear, ["stop"])
  }, null, 8
  /* PROPS */
  , ["class", "onClick"])), [[vShow, _ctx.hasClearRef]]) : createCommentVNode("v-if", true)], 34
  /* CLASS, HYDRATE_EVENTS */
  )], 34
  /* CLASS, HYDRATE_EVENTS */
  );
}

script$l.render = render$j;
script$l.__file = "components/select-trigger/selectTrigger.vue";

const key$1 = Symbol('FSelect');

/**
 * virtual list core calculating center
 */
var DIRECTION_TYPE;

(function (DIRECTION_TYPE) {
  DIRECTION_TYPE["FRONT"] = "FRONT";
  DIRECTION_TYPE["BEHIND"] = "BEHIND";
})(DIRECTION_TYPE || (DIRECTION_TYPE = {}));

var CALC_TYPE;

(function (CALC_TYPE) {
  CALC_TYPE["INIT"] = "INIT";
  CALC_TYPE["FIXED"] = "FIXED";
  CALC_TYPE["DYNAMIC"] = "DYNAMIC";
})(CALC_TYPE || (CALC_TYPE = {}));

const LEADING_BUFFER = 0;
class Virtual {
  constructor(param, callUpdate) {
    this.init(param, callUpdate);
  }

  init() {
    let param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let callUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    this.param = param;
    this.callUpdate = callUpdate; // size data

    this.sizes = reactive(new Map());
    this.firstRangeTotalSize = 0;
    this.firstRangeAverageSize = 0;
    this.lastCalcIndex = 0;
    this.fixedSizeValue = 0;
    this.calcType = CALC_TYPE.INIT; // scroll data

    this.offset = 0; // range data

    this.range = Object.create(null);

    if (this.param) {
      this.checkRange(0, this.param.keeps - 1);
    }
  }

  destroy() {
    this.init();
  } // return current render range


  getRange() {
    const range = Object.create(null);
    range.start = this.range.start;
    range.end = this.range.end;
    range.padFront = this.range.padFront;
    range.padBehind = this.range.padBehind;
    return range;
  }

  isBehind() {
    return this.direction === DIRECTION_TYPE.BEHIND;
  }

  isFront() {
    return this.direction === DIRECTION_TYPE.FRONT;
  } // return start index offset


  getOffset(start) {
    return (start < 1 ? 0 : this.getIndexOffset(start)) + this.param.slotHeaderSize;
  }

  updateParam(key, value) {
    if (this.param && Object.keys(this.param).includes(key)) {
      // if uniqueIds change, find out deleted id and remove from size map
      if (key === 'uniqueIds') {
        this.sizes.forEach((v, k) => {
          if (!value.includes(k)) {
            this.sizes.delete(k);
          }
        });
      }

      this.param[key] = value;
    }
  } // save each size map by id


  saveSize(id, size) {
    this.sizes.set(id, size); // we assume size type is fixed at the beginning and remember first size value
    // if there is no size value different from this at next comming saving
    // we think it's a fixed size list, otherwise is dynamic size list

    if (this.calcType === CALC_TYPE.INIT) {
      this.fixedSizeValue = size;
      this.calcType = CALC_TYPE.FIXED;
    } else if (this.calcType === CALC_TYPE.FIXED && this.fixedSizeValue !== size) {
      this.calcType = CALC_TYPE.DYNAMIC; // it's no use at all

      delete this.fixedSizeValue;
    } // calculate the average size only in the first range


    if (this.calcType !== CALC_TYPE.FIXED && typeof this.firstRangeTotalSize !== 'undefined') {
      if (this.sizes.size < Math.min(this.param.keeps, this.param.uniqueIds.length)) {
        this.firstRangeTotalSize = [...this.sizes.values()].reduce((acc, val) => acc + val, 0);
        this.firstRangeAverageSize = Math.round(this.firstRangeTotalSize / this.sizes.size);
      } else {
        // it's done using
        delete this.firstRangeTotalSize;
      }
    }
  }

  getTotalSize() {
    return [...this.sizes.values()].reduce((acc, val) => acc + val, 0);
  } // in some special situation (e.g. length change) we need to update in a row
  // try goiong to render next range by a leading buffer according to current direction


  handleDataSourcesChange() {
    let start = this.range.start;

    if (this.isFront()) {
      start = start - LEADING_BUFFER;
    } else if (this.isBehind()) {
      start = start + LEADING_BUFFER;
    }

    start = Math.max(start, 0);
    this.updateRange(this.range.start, this.getEndByStart(start));
  } // when slot size change, we also need force update


  handleSlotSizeChange() {
    this.handleDataSourcesChange();
  } // calculating range on scroll


  handleScroll(offset) {
    this.direction = offset < this.offset ? DIRECTION_TYPE.FRONT : DIRECTION_TYPE.BEHIND;
    this.offset = offset;

    if (!this.param) {
      return;
    }

    if (this.direction === DIRECTION_TYPE.FRONT) {
      this.handleFront();
    } else if (this.direction === DIRECTION_TYPE.BEHIND) {
      this.handleBehind();
    }
  }

  handleFront() {
    const overs = this.getScrollOvers(); // should not change range if start doesn't exceed overs

    if (overs > this.range.start) {
      return;
    } // move up start by a buffer length, and make sure its safety


    const start = Math.max(overs - this.param.buffer, 0);
    this.checkRange(start, this.getEndByStart(start));
  }

  handleBehind() {
    const overs = this.getScrollOvers(); // range should not change if scroll overs within buffer

    if (overs < this.range.start + this.param.buffer) {
      return;
    }

    this.checkRange(overs, this.getEndByStart(overs));
  } // return the pass overs according to current scroll offset


  getScrollOvers() {
    // if slot header exist, we need subtract its size
    const offset = this.offset - this.param.slotHeaderSize;

    if (offset <= 0) {
      return 0;
    } // if is fixed type, that can be easily


    if (this.isFixedType()) {
      return Math.floor(offset / this.fixedSizeValue);
    }

    let low = 0;
    let middle = 0;
    let middleOffset = 0;
    let high = this.param.uniqueIds.length;

    while (low <= high) {
      // this.__bsearchCalls++
      middle = low + Math.floor((high - low) / 2);
      middleOffset = this.getIndexOffset(middle);

      if (middleOffset === offset) {
        return middle;
      }

      if (middleOffset < offset) {
        low = middle + 1;
      } else if (middleOffset > offset) {
        high = middle - 1;
      }
    }

    return low > 0 ? --low : 0;
  } // return a scroll offset from given index, can efficiency be improved more here?
  // although the call frequency is very high, its only a superposition of numbers


  getIndexOffset(givenIndex) {
    if (!givenIndex) {
      return 0;
    }

    let offset = 0;
    let indexSize = 0;

    for (let index = 0; index < givenIndex; index++) {
      indexSize = this.sizes.get(this.param.uniqueIds[index]);
      offset = offset + (typeof indexSize === 'number' ? indexSize : this.getEstimateSize());
    } // remember last calculate index


    this.lastCalcIndex = Math.max(this.lastCalcIndex, givenIndex - 1);
    this.lastCalcIndex = Math.min(this.lastCalcIndex, this.getLastIndex());
    return offset;
  } // is fixed size type


  isFixedType() {
    return this.calcType === CALC_TYPE.FIXED;
  } // return the real last index


  getLastIndex() {
    return this.param.uniqueIds.length - 1;
  } // in some conditions range is broke, we need correct it
  // and then decide whether need update to next range


  checkRange(start, end) {
    const keeps = this.param.keeps;
    const total = this.param.uniqueIds.length; // datas less than keeps, render all

    if (total <= keeps) {
      start = 0;
      end = this.getLastIndex();
    } else if (end - start < keeps - 1) {
      // if range length is less than keeps, corrent it base on end
      start = end - keeps + 1;
    }

    if (this.range.start !== start) {
      this.updateRange(start, end);
    }
  } // setting to a new range and rerender


  updateRange(start, end) {
    this.range.start = start;
    this.range.end = end;
    this.range.padFront = this.getPadFront();
    this.range.padBehind = this.getPadBehind();
    this.callUpdate(this.getRange());
  } // return end base on start


  getEndByStart(start) {
    const theoryEnd = start + this.param.keeps - 1;
    const truelyEnd = Math.min(theoryEnd, this.getLastIndex());
    return truelyEnd;
  } // return total front offset


  getPadFront() {
    if (this.isFixedType()) {
      return this.fixedSizeValue * this.range.start;
    }

    return this.getIndexOffset(this.range.start);
  } // return total behind offset


  getPadBehind() {
    const end = this.range.end;
    const lastIndex = this.getLastIndex();

    if (this.isFixedType()) {
      return (lastIndex - end) * this.fixedSizeValue;
    } // if it's all calculated, return the exactly offset


    if (this.lastCalcIndex === lastIndex) {
      return this.getIndexOffset(lastIndex) - this.getIndexOffset(end);
    } // if not, use a estimated value


    return (lastIndex - end) * this.getEstimateSize();
  } // get the item estimate size


  getEstimateSize() {
    return this.isFixedType() ? this.fixedSizeValue : this.firstRangeAverageSize || this.param.estimateSize;
  }

}

function ownKeys$s(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$s(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$s(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$s(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const virtualProps = _objectSpread$s(_objectSpread$s({
  dataKey: {
    type: [String, Function],
    required: true
  },
  dataSources: {
    type: Array,
    required: true
  },
  keeps: {
    type: Number,
    default: 30
  },
  extraProps: {
    type: Object
  },
  estimateSize: {
    type: Number,
    default: 50
  },
  observeResize: {
    type: Boolean,
    default: true
  },
  direction: {
    type: String,
    default: 'vertical' // the other value is horizontal

  },
  start: {
    type: Number,
    default: 0
  },
  offset: {
    type: Number,
    default: 0
  },
  topThreshold: {
    type: Number,
    default: 0
  },
  bottomThreshold: {
    type: Number,
    default: 0
  },
  pageMode: {
    type: Boolean,
    default: false
  },
  wrapTag: {
    type: String,
    default: 'div'
  },
  wrapClass: {
    type: String,
    default: ''
  },
  wrapStyle: {
    type: Object
  },
  renderItemList: {
    type: Function
  }
}, COMMON_PROPS$1), {}, {
  height: Number,
  maxHeight: Number
});
const itemProps = {
  index: {
    type: Number
  },
  horizontal: {
    type: Boolean
  },
  source: {
    type: [Object, String, Number]
  },
  uniqueKey: {
    type: [String, Number]
  },
  observeResize: {
    type: Boolean,
    default: true
  }
};

/**
 * item component, we need to know their size change at any time
 */

const FVirtualListItem = defineComponent({
  name: 'FVirtualListItem',
  props: itemProps,

  setup(props, _ref) {
    let {
      attrs
    } = _ref;
    const itemRef = ref(); // tell parent current size identify by unqiue key

    const dispatchSizeChange = () => {
      const shapeKey = props.horizontal ? 'offsetWidth' : 'offsetHeight';
      const s = itemRef.value ? itemRef.value[shapeKey] : 0;
      attrs.onItemResized(props.uniqueKey, s);
    };

    useResize(itemRef, dispatchSizeChange, computed(() => !props.observeResize));
    return {
      itemRef
    };
  },

  render() {
    var _$slots$default;

    const {
      index,
      source,
      $slots
    } = this;
    const vNode = getFirstValidNode((_$slots$default = $slots.default) === null || _$slots$default === void 0 ? void 0 : _$slots$default.call($slots, {
      index,
      source
    }));
    return cloneVNode(vNode, {
      ref: el => {
        if (el) this.itemRef = getElementFromRef(el);
      }
    }, true);
  }

});

var SLOT_TYPE;

(function (SLOT_TYPE) {
  SLOT_TYPE["HEADER"] = "thead";
  SLOT_TYPE["FOOTER"] = "tfoot";
})(SLOT_TYPE || (SLOT_TYPE = {}));

var VirtualList = defineComponent({
  name: 'FVirtualList',
  props: virtualProps,
  emits: [TO_TOP_EVENT, TO_BOTTOM_EVENT, RESIZED_EVENT, 'scroll'],

  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const isHorizontal = props.direction === 'horizontal';
    const directionKey = isHorizontal ? 'scrollLeft' : 'scrollTop';
    const rootRef = ref();
    const shepherdRef = ref();
    const rangeRef = ref(Object.create(null));
    const scrollRef = ref();
    let virtual = null;
    const fullHeight = computed(() => {
      const {
        padBehind
      } = rangeRef.value; // getEstimateSize

      void virtual.sizes.size;

      if (padBehind !== 0) {
        return virtual && virtual.getEstimateSize() * props.dataSources.length;
      }

      return virtual.getTotalSize();
    });

    const getUniqueIdFromDataSources = () => {
      const {
        dataKey
      } = props;
      return props.dataSources.map(dataSource => typeof dataKey === 'function' ? dataKey(dataSource) : dataSource[dataKey]);
    };

    const installVirtual = () => {
      virtual = new Virtual({
        slotHeaderSize: 0,
        slotFooterSize: 0,
        keeps: props.keeps,
        estimateSize: props.estimateSize,
        buffer: Math.round(props.keeps / 3),
        // recommend for a third of keeps
        uniqueIds: getUniqueIdFromDataSources()
      }, range => {
        rangeRef.value = range;
      }); // sync initial range

      rangeRef.value = virtual.getRange();
    };

    installVirtual(); // get item size by id

    const getSize = id => virtual.sizes.get(id); // get the total number of stored (rendered) items


    const getSizes = () => virtual.sizes.size; // return current scroll offset


    const getOffset = () => {
      const root = rootRef.value;
      return root ? Math.ceil(root[directionKey]) : 0;
    }; // return client viewport size


    const getClientSize = () => {
      const key = isHorizontal ? 'clientWidth' : 'clientHeight';
      const root = rootRef.value;
      return root ? Math.ceil(root[key]) : 0;
    }; // return all scroll size


    const getScrollSize = () => {
      const key = isHorizontal ? 'scrollWidth' : 'scrollHeight';
      const root = rootRef.value;
      return root ? Math.ceil(root[key]) : 0;
    }; // set current scroll position to a expectant offset


    const scrollToOffset = offset => {
      const root = rootRef.value;

      if (root) {
        if (isHorizontal) {
          root.scrollBy(offset, 0);
        } else {
          root.scrollBy(0, offset); // OffsetTop
        }
      }
    }; // set current scroll position to bottom


    const scrollToBottom = () => {
      const shepherd = rootRef.value;

      if (shepherd) {
        const offset = shepherd[isHorizontal ? 'scrollWidth' : 'scrollHeight'];
        scrollToOffset(offset); // check if it's really scrolled to the bottom
        // maybe list doesn't render and calculate to last range
        // so we need retry in next event loop until it really at bottom

        const time = setTimeout(() => {
          if (getOffset() + getClientSize() < getScrollSize()) {
            scrollToBottom();
          }

          clearTimeout(time);
        }, 3);
      }
    }; // set current scroll position to a expectant index


    const scrollToIndex = index => {
      // scroll to bottom
      if (index >= props.dataSources.length - 1) {
        scrollToBottom();
      } else {
        const offset = virtual.getOffset(index);
        scrollToOffset(offset);
      }
    }; // reset all state back to initial


    const reset = () => {
      virtual.destroy();
      scrollToOffset(0);
      installVirtual();
    };

    let lastSize = getSizes();
    const updateScrollBar = throttle(() => {
      const nowSize = getSizes();

      if (nowSize !== lastSize) {
        lastSize = nowSize;

        if (scrollRef.value) {
          var _scrollRef$value$upda, _scrollRef$value;

          (_scrollRef$value$upda = (_scrollRef$value = scrollRef.value).update) === null || _scrollRef$value$upda === void 0 ? void 0 : _scrollRef$value$upda.call(_scrollRef$value);
        }
      }
    }, 10); // event called when each item mounted or size changed

    const onItemResized = (id, size) => {
      const sizes = virtual.sizes;
      const oldSize = sizes.get(id);

      if (oldSize !== size) {
        virtual.saveSize(id, size);
        emit(RESIZED_EVENT, id, size);
        updateScrollBar();
      }
    }; // event called when slot mounted or size changed


    const onSlotResized = (type, size, hasInit) => {
      if (slots.header() || slots.footer()) {
        if (type === SLOT_TYPE.HEADER) {
          virtual.updateParam('slotHeaderSize', size);
        } else if (type === SLOT_TYPE.FOOTER) {
          virtual.updateParam('slotFooterSize', size);
        }

        if (hasInit) {
          virtual.handleSlotSizeChange();
        }
      }
    }; // emit event in special position


    const emitEvent = (offset, clientSize, scrollSize, evt) => {
      emit('scroll', evt, virtual.getRange());

      if (virtual.isFront() && !!props.dataSources.length && offset - props.topThreshold <= 0) {
        emit(TO_TOP_EVENT);
      } else if (virtual.isBehind() && offset + clientSize + props.bottomThreshold >= scrollSize) {
        emit(TO_BOTTOM_EVENT);
      }
    };

    const onScroll = evt => {
      const offset = getOffset();
      const clientSize = getClientSize();
      const scrollSize = getScrollSize(); // iOS scroll-spring-back behavior will make direction mistake

      if (offset < 0 || offset + clientSize > scrollSize + 1 || !scrollSize) {
        return;
      }

      virtual.handleScroll(offset);
      emitEvent(offset, clientSize, scrollSize, evt);
    }; // get the real render slots based on range data
    // in-place patch strategy will try to reuse components as possible
    // so those components that are reused will not trigger lifecycle mounted


    const getRenderItems = () => {
      const itemVNodes = [];
      const {
        start,
        end
      } = rangeRef.value;
      const {
        dataSources,
        dataKey
      } = props;

      for (let index = start; index <= end; index++) {
        const dataSource = dataSources[index];

        if (dataSource) {
          const uniqueKey = typeof dataKey === 'function' ? dataKey(dataSource) : dataSource[dataKey];

          if (typeof uniqueKey === 'string' || typeof uniqueKey === 'number') {
            const tempNode = createVNode(FVirtualListItem, {
              key: uniqueKey,
              index,
              horizontal: isHorizontal,
              uniqueKey,
              source: dataSource,
              onItemResized,
              observeResize: props.observeResize
            }, {
              default: slots.default
            });
            itemVNodes.push(tempNode);
          } else {
            console.warn(`Cannot get the data-key '${dataKey}' from data-sources.`);
          }
        } else {
          console.warn(`Cannot get the index '${index}' from data-sources.`);
        }
      }

      return itemVNodes;
    };

    watch(() => props.dataSources, () => {
      virtual.updateParam('uniqueIds', getUniqueIdFromDataSources());
      virtual.handleDataSourcesChange();
    });
    watch(() => props.keeps, newValue => {
      virtual.updateParam('keeps', newValue);
      virtual.handleSlotSizeChange();
    });
    watch(() => props.start, newValue => {
      scrollToIndex(newValue);
    });
    watch(() => props.offset, newValue => {
      scrollToOffset(newValue);
    }); // set back offset when awake from keep-alive

    onActivated(() => {
      scrollToOffset(virtual.offset);
    });
    onMounted(() => {
      // set position
      if (props.start) {
        scrollToIndex(props.start);
      } else if (props.offset) {
        scrollToOffset(props.offset);
      }
    });
    return {
      reset,
      scrollToBottom,
      scrollToIndex,
      scrollToOffset,
      getSize,
      getSizes,
      getOffset,
      getClientSize,
      getScrollSize,
      onScroll,
      getRenderItems,
      onItemResized,
      onSlotResized,
      fullHeight,
      isHorizontal,
      rootRef,
      shepherdRef,
      rangeRef,
      scrollRef
    };
  },

  render() {
    const {
      padFront,
      padBehind
    } = this.rangeRef;
    const {
      isHorizontal,
      wrapTag,
      wrapClass,
      wrapStyle,
      onScroll,
      fullHeight,
      renderItemList,
      shadow,
      height,
      maxHeight
    } = this; // wrap style

    const horizontalStyle = {
      display: 'flex',
      'flex-direction': 'row',
      position: 'absolute',
      bottom: 0,
      top: 0,
      left: `${padFront}px`,
      right: `${padBehind}px`
    };
    const verticalStyle = {
      position: 'absolute',
      left: 0,
      right: 0,
      top: `${padFront}px`,
      bottom: `${padBehind}px`
    };
    const wrapperStyle = Object.assign({}, wrapStyle || {}, isHorizontal ? horizontalStyle : verticalStyle);
    const rootStyle = isHorizontal ? {
      position: 'relative',
      width: `${fullHeight}px`,
      height: '100%'
    } : {
      position: 'relative',
      height: `${fullHeight}px`,
      width: '100%'
    };
    const wrapNode = createVNode(wrapTag, {
      class: wrapClass,
      style: wrapperStyle
    }, renderItemList ? renderItemList(this.getRenderItems()) : this.getRenderItems());
    return createVNode(script$n, {
      "ref": e => {
        this.scrollRef = e;
        this.rootRef = e === null || e === void 0 ? void 0 : e.containerRef;
      },
      "onScroll": onScroll,
      "shadow": shadow,
      "height": height,
      "maxHeight": maxHeight,
      "contentStyle": rootStyle
    }, {
      default: () => [wrapNode]
    });
  }

});

function ownKeys$r(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$r(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$r(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const optionListProps = {
  prefixCls: String,
  containerStyle: {
    type: Object
  },
  options: {
    type: Array,

    default() {
      return [];
    }

  },
  isSelect: {
    type: Function,
    default: noop$1
  },
  onSelect: {
    type: Function,
    default: noop$1
  },
  onHover: {
    type: Function,
    default: noop$1
  },
  isLimit: {
    type: Boolean
  },
  emptyText: String,
  renderOption: Function,
  renderEmpty: Function,
  hoverOptionValue: [String, Number, Object]
};
var OptionList = defineComponent({
  props: optionListProps,
  emits: ['scroll'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const {
      t
    } = useLocale();

    const renderLabel = (option, isSelected, prefixCls) => {
      var _slots;

      if ((_slots = option.slots) !== null && _slots !== void 0 && _slots.default) {
        return option.slots.default(_objectSpread$r(_objectSpread$r({}, option), {}, {
          isSelected
        }));
      }

      if (props.renderOption) {
        return props.renderOption(_objectSpread$r(_objectSpread$r({}, option), {}, {
          isSelected
        }));
      }

      if (option.label) {
        return createVNode(Fragment, null, [createVNode(Ellipsis, {
          "class": `${prefixCls}-label`
        }, {
          default: () => [option.label, option.__cache && createVNode("span", {
            "class": `${prefixCls}-label-tip`
          }, [createTextVNode("- "), t('select.tagOption')])]
        }), isSelected && createVNode(CheckOutlined, {
          "class": `${prefixCls}-checked-icon`
        }, null)]);
      }

      return null;
    };

    const renderOption = option => {
      const value = option.value;
      const isSelected = props.isSelect(value);
      const isHover = props.hoverOptionValue === option.value;
      const prefixCls = `${props.prefixCls}-option`;
      const classList = [prefixCls, isSelected && 'is-checked', isHover && 'is-hover', (option.disabled || !isSelected && props.isLimit) && 'is-disabled'].filter(Boolean);
      return createVNode("div", {
        "class": classList,
        "onClick": () => {
          if (option.disabled) {
            return;
          }

          props.onSelect(value, option);
        },
        "onMouseover": () => {
          if (option.disabled) {
            return;
          }

          props.onHover(option);
        }
      }, [renderLabel(option, isSelected, prefixCls)]);
    };

    const renderDefault = _ref2 => {
      let {
        source
      } = _ref2;
      return renderOption(source);
    };

    return () => props.options.length > 50 ? createVNode(VirtualList, {
      "onScroll": event => {
        emit('scroll', event);
      },
      "dataSources": props.options,
      "dataKey": 'value',
      "estimateSize": 32,
      "keeps": 14,
      "style": props.containerStyle,
      "class": `${props.prefixCls}-dropdown is-max-height`
    }, {
      default: renderDefault
    }) : props.options.length ? createVNode(script$n, {
      "onScroll": event => {
        emit('scroll', event);
      },
      "containerStyle": props.containerStyle,
      "containerClass": `${props.prefixCls}-dropdown`
    }, {
      default: () => [props.options.map(option => renderOption(option))]
    }) : props.renderEmpty ? createVNode("div", {
      "class": [`${props.prefixCls}-dropdown`],
      "style": props.containerStyle
    }, [props.renderEmpty()]) : createVNode("div", {
      "class": [`${props.prefixCls}-dropdown`, `${props.prefixCls}-null`],
      "style": props.containerStyle
    }, [props.emptyText]);
  }

});

const selectProps = {
  modelValue: {
    type: [String, Number, Array, Boolean, Object],

    default() {
      return undefined;
    }

  },
  placeholder: {
    type: String
  },
  disabled: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  multiple: {
    type: Boolean,
    default: false
  },
  multipleLimit: {
    type: Number,
    default: 0
  },
  emptyText: {
    type: String
  },
  appendToContainer: {
    type: Boolean,
    default: true
  },
  getContainer: {
    type: Function
  },
  filterable: {
    type: Boolean,
    default: false
  },
  filter: {
    type: Function
  },
  collapseTags: {
    type: Boolean,
    default: false
  },
  collapseTagsLimit: {
    type: Number,
    default: 1
  },
  options: {
    type: Array,

    default() {
      return [];
    }

  },
  remote: {
    type: Boolean,
    default: false
  },
  valueField: {
    type: String,
    default: 'value'
  },
  labelField: {
    type: String,
    default: 'label'
  },
  tagBordered: {
    type: Boolean,
    default: false
  },
  tag: {
    type: Boolean,
    default: false
  },
  popperClass: [String, Array, Object]
};
extractPropsDefaultValue(selectProps);

function ownKeys$q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$q(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$G = getPrefixCls('select');
var script$k = defineComponent({
  name: 'FSelect',
  components: {
    Popper: FPopper,
    SelectTrigger: script$l,
    OptionList
  },
  props: selectProps,
  emits: [UPDATE_MODEL_EVENT$1, CHANGE_EVENT$1, 'removeTag', 'visibleChange', 'focus', 'blur', 'clear', 'scroll', 'search'],

  setup(props, _ref) {
    let {
      emit,
      attrs
    } = _ref;
    useTheme();
    const {
      validate,
      isError,
      isFormDisabled
    } = useFormAdaptor({
      valueType: computed(() => props.multiple ? 'array' : 'string')
    });
    const innerDisabled = computed(() => props.disabled || isFormDisabled.value);
    const isOpenedRef = ref(false);
    const [currentValue, updateCurrentValue] = props.multiple ? useArrayModel(props, emit) : useNormalModel(props, emit);
    const triggerRef = ref();
    const triggerWidth = ref(0);
    const filterText = ref('');
    const cacheOptions = ref([]);
    watch(isOpenedRef, () => {
      emit('visibleChange', unref(isOpenedRef));

      if (isOpenedRef.value && triggerRef.value) {
        triggerWidth.value = triggerRef.value.$el.offsetWidth;
      }
    });

    const handleChange = () => {
      emit(CHANGE_EVENT$1, unref(currentValue));
      validate(CHANGE_EVENT$1);
    };

    const handleClear = () => {
      const value = props.multiple ? [] : null;

      if (props.multiple ? currentValue.value.length : currentValue.value !== null) {
        updateCurrentValue(value);
        handleChange();
      }

      cacheOptions.value = [];
      emit('clear');
    };

    const {
      t
    } = useLocale();
    const inputPlaceholder = computed(() => props.placeholder || t('select.placeholder'));
    const listEmptyText = computed(() => props.emptyText || t('select.emptyText'));
    const childOptions = reactive([]);

    const addOption = option => {
      if (!childOptions.includes(option)) {
        childOptions.push(option);
      }
    };

    const removeOption = id => {
      const colIndex = childOptions.findIndex(item => item.id === id);

      if (colIndex !== -1) {
        childOptions.splice(colIndex, 1);
      }
    };

    const baseOptions = computed(() => {
      const allOptions = [...childOptions, ...props.options];
      return allOptions.map(option => {
        return _objectSpread$q(_objectSpread$q({}, option), {}, {
          value: option[props.valueField],
          label: option[props.labelField]
        });
      });
    });
    const cacheOptionsForTag = computed(() => {
      if (props.filterable && props.tag) {
        if (filterText.value && baseOptions.value.every(option => {
          return option.label !== filterText.value;
        }) && cacheOptions.value.every(option => {
          return option.value !== filterText.value;
        })) {
          return [{
            value: filterText.value,
            label: filterText.value,
            __cache: true
          }, ...cacheOptions.value];
        }

        return cacheOptions.value;
      }

      return [];
    });
    const allOptions = computed(() => {
      return [...cacheOptionsForTag.value, ...baseOptions.value];
    });
    const filteredOptions = computed(() => {
      if (!props.remote && props.filterable && filterText.value) {
        return allOptions.value.filter(option => {
          if (props.filter) {
            return props.filter(filterText.value, option);
          }

          return String(option.label).includes(filterText.value);
        });
      }

      return allOptions.value;
    });

    const isSelect = value => {
      const selectVal = unref(currentValue);
      const optVal = unref(value);

      if (selectVal === null) {
        return false;
      }

      if (props.multiple) {
        return selectVal.includes(optVal);
      }

      return selectVal === optVal;
    };

    const isLimitRef = computed(() => {
      const selectVal = unref(currentValue);
      return props.multipleLimit > 0 && props.multipleLimit === selectVal.length;
    });

    const onSelect = (value, option) => {
      if (props.disabled || isFormDisabled.value) return;

      if (props.multiple) {
        filterText.value = '';

        if (isSelect(value)) {
          emit('removeTag', value);
        } else {
          if (isLimitRef.value) return;
        }
      } else {
        // 
        setTimeout(() => {
          filterText.value = '';
        }, 400);
        isOpenedRef.value = false;
      }

      if (props.filterable && props.tag) {
        if (props.multiple) {
          if (isSelect(value)) {
            const index = cacheOptions.value.findIndex(option => {
              return option.value === value;
            });

            if (index !== -1) {
              cacheOptions.value.splice(index, 1);
            }
          } else {
            if (option !== null && option !== void 0 && option.__cache) {
              cacheOptions.value = [option, ...cacheOptions.value];
            }
          }
        } else {
          if (option !== null && option !== void 0 && option.__cache) {
            cacheOptions.value = [option];
          } else {
            cacheOptions.value = [];
          }
        }
      }

      updateCurrentValue(unref(value));
      handleChange();
    }; // select-trigger  currentValue 


    const selectedOptionsRef = ref([]);
    watch([currentValue, allOptions], _ref2 => {
      let [newValue, newOptions] = _ref2;

      const getOption = val => {
        let cacheOption;

        if (newOptions && newOptions.length) {
          cacheOption = newOptions.find(option => option.value === val);

          if (cacheOption) {
            return cacheOption;
          }
        }

        cacheOption = selectedOptionsRef.value.find(option => option.value === val);

        if (cacheOption) {
          return cacheOption;
        }

        return val ? {
          value: val,
          label: null
        } : null;
      };

      if (!props.multiple) {
        const option = getOption(newValue);
        selectedOptionsRef.value = option ? [option] : [];
      } else {
        selectedOptionsRef.value = newValue.map(value => {
          return getOption(value);
        }).filter(Boolean);
      }
    }, {
      immediate: true,
      deep: true
    });
    provide(key$1, {
      addOption,
      removeOption
    });

    const focus = e => {
      emit('focus', e);
      validate('focus');
    };

    const blur = e => {
      if (isOpenedRef.value) {
        isOpenedRef.value = false;
      }

      emit('blur', e);
      validate('blur');
    };

    const handleFilterTextChange = (val, extraInfo) => {
      filterText.value = val; // blur  inputText  search

      if (props.remote && !(extraInfo !== null && extraInfo !== void 0 && extraInfo.isClear)) {
        emit('search', val);
      }
    };

    onMounted(() => {
      if (triggerRef.value) {
        triggerWidth.value = triggerRef.value.$el.offsetWidth;
      }
    });
    const dropdownStyle = computed(() => {
      const style = {};

      if (triggerWidth.value) {
        style['min-width'] = `${triggerWidth.value}px`;
      }

      return style;
    });

    const onScroll = e => {
      emit('scroll', e);
    };

    const hoverOptionValue = ref();

    const onHover = option => {
      hoverOptionValue.value = option.value;
    };

    function getFirstOption() {
      const len = filteredOptions.value.length;

      if (len < 1) {
        return;
      }

      let index = 0;

      while (index < len) {
        if (!filteredOptions.value[index].disabled) {
          break;
        }

        index++;
      }

      if (index < len) {
        return filteredOptions.value[index];
      }
    }

    watch(isOpenedRef, () => {
      if (isOpenedRef.value) {
        if (props.multiple) {
          if (currentValue.value.length > 0) {
            hoverOptionValue.value = currentValue.value[0];
          }
        } else if (!isNil(currentValue.value)) {
          hoverOptionValue.value = currentValue.value;
        }

        const option = getFirstOption();

        if (isNil(hoverOptionValue.value) && option) {
          hoverOptionValue.value = option.value;
        }
      } else {
        hoverOptionValue.value = undefined;
      }
    });
    watch(filteredOptions, () => {
      const option = getFirstOption();

      if (isOpenedRef.value && option) {
        hoverOptionValue.value = option.value;
      }
    });

    const onKeyDown = () => {
      if (!isNil(hoverOptionValue.value)) {
        const option = allOptions.value.find(option => {
          return option.value === hoverOptionValue.value;
        });
        onSelect(hoverOptionValue.value, option);
      }
    };

    return {
      prefixCls: prefixCls$G,
      isOpenedRef,
      currentValue,
      handleRemove: onSelect,
      handleClear,
      selectedOptionsRef,
      focus,
      blur,
      handleFilterTextChange,
      triggerRef,
      dropdownStyle,
      isSelect,
      onSelect,
      filteredOptions,
      listEmptyText,
      inputPlaceholder,
      isError,
      innerDisabled,
      onScroll,
      isLimitRef,
      attrs,
      hoverOptionValue,
      onHover,
      onKeyDown
    };
  }

});

function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectTrigger = resolveComponent("SelectTrigger");

  const _component_OptionList = resolveComponent("OptionList");

  const _component_Popper = resolveComponent("Popper");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [createVNode(_component_Popper, {
    modelValue: _ctx.isOpenedRef,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => _ctx.isOpenedRef = $event),
    trigger: "click",
    placement: "bottom-start",
    onlyShowTrigger: _ctx.filterable || _ctx.remote,
    popperClass: [`${_ctx.prefixCls}-popper`, _ctx.popperClass],
    appendToContainer: _ctx.appendToContainer,
    getContainer: _ctx.getContainer,
    offset: 4,
    hideAfter: 0,
    disabled: _ctx.innerDisabled
  }, {
    trigger: withCtx(() => [createVNode(_component_SelectTrigger, {
      ref: "triggerRef",
      selectedOptions: _ctx.selectedOptionsRef,
      disabled: _ctx.innerDisabled,
      clearable: _ctx.clearable,
      isOpened: _ctx.isOpenedRef,
      multiple: _ctx.multiple,
      placeholder: _ctx.inputPlaceholder,
      filterable: _ctx.filterable || _ctx.remote,
      collapseTags: _ctx.collapseTags,
      collapseTagsLimit: _ctx.collapseTagsLimit,
      tagBordered: _ctx.tagBordered,
      class: normalizeClass([{
        'is-error': _ctx.isError
      }, _ctx.attrs.class]),
      style: normalizeStyle(_ctx.attrs.style),
      renderTag: _ctx.$slots.tag,
      onKeydown: withKeys(_ctx.onKeyDown, ["enter"]),
      onRemove: _ctx.onSelect,
      onClear: _ctx.handleClear,
      onFocus: _ctx.focus,
      onBlur: _ctx.blur,
      onInput: _ctx.handleFilterTextChange
    }, null, 8
    /* PROPS */
    , ["selectedOptions", "disabled", "clearable", "isOpened", "multiple", "placeholder", "filterable", "collapseTags", "collapseTagsLimit", "tagBordered", "class", "style", "renderTag", "onKeydown", "onRemove", "onClear", "onFocus", "onBlur", "onInput"])]),
    default: withCtx(() => [createVNode(_component_OptionList, {
      hoverOptionValue: _ctx.hoverOptionValue,
      options: _ctx.filteredOptions,
      prefixCls: _ctx.prefixCls,
      containerStyle: _ctx.dropdownStyle,
      isSelect: _ctx.isSelect,
      onSelect: _ctx.onSelect,
      onHover: _ctx.onHover,
      isLimit: _ctx.isLimitRef,
      emptyText: _ctx.listEmptyText,
      renderOption: _ctx.$slots.option,
      renderEmpty: _ctx.$slots.empty,
      onScroll: _ctx.onScroll,
      onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"]))
    }, null, 8
    /* PROPS */
    , ["hoverOptionValue", "options", "prefixCls", "containerStyle", "isSelect", "onSelect", "onHover", "isLimit", "emptyText", "renderOption", "renderEmpty", "onScroll"]), _ctx.$slots.addon ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-addon`),
      onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {}, ["prevent"]))
    }, [renderSlot(_ctx.$slots, "addon")], 34
    /* CLASS, HYDRATE_EVENTS */
    )) : createCommentVNode("v-if", true)]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["modelValue", "onlyShowTrigger", "popperClass", "appendToContainer", "getContainer", "disabled"]), createElementVNode("div", {
    ref: "hiddenOptions",
    class: normalizeClass(`${_ctx.prefixCls}-hidden-options`)
  }, [renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  )], 2
  /* CLASS */
  );
}

script$k.render = render$i;
script$k.__file = "components/select/select.vue";

function ownKeys$p(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$p(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$p(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$p(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const optionProps = {
  value: {
    type: [String, Number, Boolean, Object]
  },
  label: String,
  disabled: Boolean
};
var FOption$1 = defineComponent({
  name: 'FOption',
  props: optionProps,

  setup(props, ctx) {
    const parent = inject(key$1, null);

    if (!parent) {
      console.warn('[FOption]: FOption  FSelect ');
    }

    const instance = getCurrentInstance();
    const {
      addOption,
      removeOption
    } = parent;
    const optionRef = ref();
    onBeforeMount(() => {
      const option = _objectSpread$p(_objectSpread$p({
        id: instance.uid
      }, toRefs(props)), {}, {
        slots: ctx.slots
      });

      option.label = computed(() => {
        if (props.label) {
          return props.label;
        }

        const el = optionRef.value; //TODO:  text 

        return (el === null || el === void 0 ? void 0 : el.textContent) || '';
      });
      addOption(option);
    });
    onBeforeUnmount(() => {
      removeOption(instance.uid);
    });
    return () => {
      var _ctx$slots$default, _ctx$slots;

      return createVNode("span", {
        "ref": optionRef
      }, [(_ctx$slots$default = (_ctx$slots = ctx.slots).default) === null || _ctx$slots$default === void 0 ? void 0 : _ctx$slots$default.call(_ctx$slots)]);
    };
  }

});

const FSelect = withInstall(script$k, {
  Option: FOption$1
});
const FOption = withNoopInstall(FOption$1);

const prefixCls$F = getPrefixCls('spin');
const spinProps = {
  size: {
    type: String,
    default: 'middle'
  },
  description: {
    type: String
  },
  stroke: {
    type: String
  },
  delay: {
    type: Number,
    default: 0
  },
  show: {
    type: Boolean,
    default: true
  }
};
var Spin = defineComponent({
  name: 'FSpin',
  props: spinProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useTheme();
    const isShow = ref(props.show);
    let showTimer;

    function clearTimers() {
      clearTimeout(showTimer);
    }

    const hide = () => {
      isShow.value = false;
    };

    const show = () => {
      if (props.delay) {
        showTimer = setTimeout(() => {
          isShow.value = true;
        }, props.delay);
      } else {
        isShow.value = true;
      }
    };

    const toggleState = value => {
      clearTimers();

      if (!value) {
        hide();
      } else {
        show();
      }
    };

    watch(() => props.show, toggleState);
    onBeforeUnmount(() => {
      clearTimers();
    });
    const style = computed(() => {
      const o = {};

      if (props.stroke) {
        o.color = props.stroke;
      }

      return o;
    });

    const renderIcon = () => {
      var _slots$icon;

      return ((_slots$icon = slots.icon) === null || _slots$icon === void 0 ? void 0 : _slots$icon.call(slots)) || createVNode(LoadingOutlined, null, null);
    };

    const renderDesc = () => {
      var _slots$description;

      if (!slots.description && !props.description) return null;
      return createVNode("span", {
        "class": `${prefixCls$F}-description`
      }, [((_slots$description = slots.description) === null || _slots$description === void 0 ? void 0 : _slots$description.call(slots)) || props.description]);
    };

    const renderSpin = () => createVNode("div", {
      "class": `${prefixCls$F} is-size-${props.size}`,
      "style": style.value
    }, [renderIcon()]);

    return () => {
      var _slots$default;

      if (!slots.default) {
        return isShow.value ? renderSpin() : null;
      }

      return createVNode("div", {
        "class": `${prefixCls$F}-container ${isShow.value ? 'is-spinning' : ''}`
      }, [createVNode("div", {
        "class": `${prefixCls$F}-content`
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), createVNode("div", {
        "class": `${prefixCls$F}-wrapper`
      }, [renderSpin(), renderDesc()])]);
    };
  }

});

const FSpin = withInstall(Spin);

const PROVIDE_KEY = Symbol('FSteps');
const COMPONENT_NAME$3 = {
  STEPS: 'FSteps',
  STEP: 'FStep'
};
const STATUS = {
  WAIT: 'wait',
  PROCESS: 'process',
  FINISH: 'finish',
  ERROR: 'error'
}; // 

const prefixCls$E = getPrefixCls('steps');
const stepsProps = {
  current: {
    type: Number
  },
  status: {
    type: String,
    default: 'process'
  },
  type: {
    type: String,
    default: 'default'
  },
  vertical: {
    type: Boolean,
    default: false
  },
  initial: {
    type: Number,
    default: 1
  }
};
var Steps = defineComponent({
  name: COMPONENT_NAME$3.STEPS,
  props: stepsProps,

  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    useTheme();
    const parentDomRef = ref();
    const [current, updateCurrent] = useNormalModel(props, emit, {
      prop: 'current'
    });
    const classList = computed(() => [prefixCls$E, `is-${props.type}`, props.vertical && 'is-vertical'].filter(Boolean).join(' '));
    const count = ref(0);

    const onUpdate = () => {
      count.value += 1;
    };

    provide(PROVIDE_KEY, {
      current,
      updateCurrent,
      props,
      parentDomRef,
      count,
      onUpdate
    });
    return () => {
      var _slots$default;

      return createVNode("div", {
        "ref": parentDomRef,
        "class": classList.value
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]);
    };
  }

});

const prefixCls$D = getPrefixCls('step');
const stepProps = {
  description: {
    type: String
  },
  title: {
    type: String
  },
  status: {
    type: String
  }
};
var Step = defineComponent({
  name: COMPONENT_NAME$3.STEP,
  components: {
    CloseOutlined,
    CheckOutlined
  },
  props: stepProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const vm = getCurrentInstance();

    if (!vm || !vm.parent || !vm.parent.type || vm.parent.type.name !== COMPONENT_NAME$3.STEPS) {
      console.warn(`[${COMPONENT_NAME$3.STEP}] must be a child of ${COMPONENT_NAME$3.STEPS}`);
    }

    const parent = inject(PROVIDE_KEY, {
      current: ref(),
      parentDomRef: ref(null),
      props: {
        initial: 1
      },
      count: ref(0),
      onUpdate: noop$1
    });
    const itemDomRef = ref();
    const index = computed(() => {
      // parent.count
      void parent.count.value;
      const parentDom = parent.parentDomRef.value;
      const itemDom = itemDomRef.value;

      if (parentDom && itemDom) {
        return Array.from(parentDom.children).indexOf(itemDom) + parent.props.initial;
      }

      return parent.props.initial - 1;
    });
    const style = computed(() => {
      // parent.count
      void parent.count.value;
      const _style = {};
      const parentDom = parent.parentDomRef.value;

      if (parentDom && !parent.props.vertical) {
        const lastChild = index.value === parentDom.children.length - 1 + parent.props.initial;

        if (lastChild) {
          _style['max-width'] = `${1 / parentDom.children.length * 100}%`;
        }
      }

      return _style;
    });
    const status = computed(() => {
      if (props.status) {
        return props.status;
      }

      const current = isNil(parent.current.value) ? parent.props.initial : parent.current.value;

      if (index.value < current) {
        return STATUS.FINISH;
      }

      if (index.value > current) {
        return STATUS.WAIT;
      }

      return parent.props.status;
    });
    const classList = computed(() => [prefixCls$D, `is-${status.value}`].filter(Boolean).join(' '));

    const renderSymbol = () => {
      let content;

      if (slots.icon) {
        content = createVNode("span", {
          "class": `${prefixCls$D}-icon`
        }, [slots.icon()]);
      } else if (status.value === STATUS.WAIT || status.value === STATUS.PROCESS) {
        content = index.value;
      } else if (status.value === STATUS.FINISH) {
        content = createVNode("span", {
          "class": `${prefixCls$D}-icon`
        }, [createVNode(CheckOutlined, null, null)]);
      } else if (status.value === STATUS.ERROR) {
        content = createVNode("span", {
          "class": `${prefixCls$D}-icon`
        }, [createVNode(CloseOutlined, null, null)]);
      }

      return createVNode("div", {
        "class": `${prefixCls$D}-symbol`
      }, [createVNode("div", {
        "class": `${prefixCls$D}-symbol-wrapper`
      }, [content]), parent.props.vertical && createVNode("div", {
        "class": `${prefixCls$D}-tail`
      }, null)]);
    };

    onMounted(() => {
      parent.onUpdate();
    });
    onUnmounted(() => {
      parent.onUpdate();
    });
    return () => {
      var _slots$title, _slots$description;

      return createVNode("div", {
        "ref": itemDomRef,
        "class": classList.value,
        "style": style.value
      }, [renderSymbol(), createVNode("div", {
        "class": `${prefixCls$D}-content`
      }, [createVNode("div", {
        "class": `${prefixCls$D}-title`
      }, [((_slots$title = slots.title) === null || _slots$title === void 0 ? void 0 : _slots$title.call(slots)) || props.title, !parent.props.vertical && createVNode("div", {
        "class": `${prefixCls$D}-tail`
      }, null)]), (slots.description || props.description) && createVNode("div", {
        "class": `${prefixCls$D}-description`
      }, [((_slots$description = slots.description) === null || _slots$description === void 0 ? void 0 : _slots$description.call(slots)) || props.description])])]);
    };
  }

});

const FSteps = withInstall(Steps, {
  Step
});
const FStep = withNoopInstall(Step);

const prefixCls$C = getPrefixCls('switch');
const switchProps = {
  modelValue: {
    type: [String, Array, Object, Number, Boolean]
  },
  disabled: {
    type: Boolean,
    default: false
  },
  activeValue: {
    type: [String, Array, Object, Number, Boolean],
    default: true
  },
  inactiveValue: {
    type: [String, Array, Object, Number, Boolean],
    default: false
  },
  beforeChange: Function,
  size: {
    type: String,
    default: 'normal'
  }
};
var script$j = defineComponent({
  name: 'FSwitch',
  components: {
    LoadingOutlined
  },
  props: switchProps,

  setup(props, ctx) {
    useTheme();
    const [currentValue, updateCurrentValue] = useNormalModel(props, ctx.emit, {
      prop: 'modelValue',
      isEqual: true
    });
    const {
      validate,
      isFormDisabled
    } = useFormAdaptor();
    onMounted(() => {
      // 
      if (currentValue.value === undefined) {
        // bug https://github.com/vuejs/core/issues/5290
        nextTick(() => {
          updateCurrentValue(props.inactiveValue);
        });
      }
    });
    const loadingRef = ref(false);

    const handleChange = () => {
      ctx.emit(CHANGE_EVENT$1, currentValue.value);
      validate(CHANGE_EVENT$1);
    };

    const activeRef = computed(() => isEqual(currentValue.value, props.activeValue));
    const inactiveRef = computed(() => isEqual(currentValue.value, props.inactiveValue));
    const innerDisabled = computed(() => props.disabled || isFormDisabled.value);

    const toggle = async () => {
      if (innerDisabled.value) return;

      if (isFunction(props.beforeChange)) {
        loadingRef.value = true;

        try {
          const confirm = await props.beforeChange(currentValue.value);
          loadingRef.value = false;

          if (confirm === false) {
            return;
          }
        } catch (e) {
          loadingRef.value = false;
          return;
        }
      }

      updateCurrentValue(activeRef.value ? props.inactiveValue : props.activeValue);
      handleChange();
    };

    const wrapperClass = computed(() => [prefixCls$C, props.size && `${prefixCls$C}-size-${props.size}`, activeRef.value && 'is-checked', innerDisabled.value && 'is-disabled'].filter(Boolean));
    return {
      prefixCls: prefixCls$C,
      wrapperClass,
      toggle,
      activeRef,
      inactiveRef,
      loadingRef
    };
  }

});

function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LoadingOutlined = resolveComponent("LoadingOutlined");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.wrapperClass),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.toggle && _ctx.toggle(...arguments);
    })
  }, [createElementVNode("span", {
    class: normalizeClass(`${_ctx.prefixCls}-inner`)
  }, [_ctx.activeRef ? renderSlot(_ctx.$slots, "active", {
    key: 0
  }) : createCommentVNode("v-if", true), _ctx.inactiveRef ? renderSlot(_ctx.$slots, "inactive", {
    key: 1
  }) : createCommentVNode("v-if", true)], 2
  /* CLASS */
  ), _ctx.loadingRef ? (openBlock(), createBlock(_component_LoadingOutlined, {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-loading`)
  }, null, 8
  /* PROPS */
  , ["class"])) : createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$j.render = render$h;
script$j.__file = "components/switch/switch.vue";

const FSwitch = withInstall(script$j);

const TABLE_NAME = 'FTable';
const TABLE_COLUMN_NAME = 'FTableColumn';
const provideKey$2 = Symbol('FTable');

function ownKeys$o(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$o(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$o(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$o(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const getRowKey = _ref => {
  let {
    row,
    rowKey
  } = _ref;

  if (rowKey) {
    let res;

    if (typeof rowKey === 'string') {
      if (rowKey.indexOf('.') < 0) {
        res = row[rowKey];
      } else {
        try {
          const key = rowKey.split('.');
          let current = row;

          for (let i = 0; i < key.length; i++) {
            current = current[key[i]];
          }

          res = current;
        } catch (error) {
          console.error(`[${TABLE_NAME}]: reading rowKey from row data failed`, error);
          throw error;
        }
      }
    } else if (typeof rowKey === 'function') {
      res = rowKey(row);
    }

    if (typeof res !== 'string' && typeof res !== 'number') {
      console.warn(`[${TABLE_NAME}]: rowKey ${res} must be number or string`);
    }

    return res;
  }

  return row;
};

const handleFixedColumns = arr => {
  // fixed
  const fixLeftIndex = arr.findIndex(column => column.props.fixed === true || column.props.fixed === 'left');

  if (fixLeftIndex !== -1) {
    const fixLeftColumn = arr[fixLeftIndex];
    fixLeftColumn.fixLeft = true;
    arr.splice(fixLeftIndex, 1);
    arr.unshift(fixLeftColumn);
  }

  const fixRightIndex = arr.findIndex(column => column.props.fixed === 'right');

  if (fixRightIndex !== -1) {
    const fixRightColumn = arr[fixRightIndex];
    fixRightColumn.fixRight = true;
    arr.splice(fixRightIndex, 1);
    arr.push(fixRightColumn);
  }

  return arr;
};
/**
 *   rowSpancolSpan level
 * @param {} originColumns
 * @returns
 */


function getHeaderRows(originColumns) {
  const rows = []; // copy getHeaderRows

  const cols = handleFixedColumns(originColumns.map(column => _objectSpread$o({}, column)));
  let isChildren = [];
  cols.forEach(column => {
    column.children = cols.filter(col => col.parentId === column.id);
    isChildren = isChildren.concat(column.children.map(col => col.id));
  });
  const treeCols = cols.filter(column => !isChildren.includes(column.id));
  let maxLevel = 1;

  const traverse = (column, parent) => {
    column.level = parent ? parent.level + 1 : 1;
    maxLevel = Math.max(column.level, maxLevel);

    if (column.children && column.children.length > 0) {
      let colSpan = 0;
      column.children.forEach(subColumn => {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan || 1;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };

  treeCols.forEach(column => {
    traverse(column);
  });
  cols.forEach(column => {
    if (column.children.length === 0) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
    }

    if (!rows[column.level - 1]) {
      rows[column.level - 1] = [];
    }

    rows[column.level - 1].push(column);
  });
  return rows;
}
/**
 * 
 * @param {*} originColumns
 * @returns
 */

function getColumns(originColumns) {
  const arr = originColumns.filter(col => !originColumns.some(c => c.parentId === col.id));
  return handleFixedColumns(arr);
}
const getCellValue = (row, column) => {
  var _column$props;

  if (!row) {
    // eslint-disable-next-line no-undefined
    return undefined;
  }

  return row[column === null || column === void 0 ? void 0 : (_column$props = column.props) === null || _column$props === void 0 ? void 0 : _column$props.prop];
};

function useColumn() {
  const originColumns = reactive([]);

  const addColumn = column => {
    originColumns.push(column);
  };

  const removeColumn = id => {
    const colIndex = originColumns.findIndex(item => item.id === id);

    if (colIndex !== -1) {
      originColumns.splice(colIndex, 1);
    }
  };

  const visibleColumns = computed(() => originColumns.filter(column => column.props.visible)); // 

  const columns = computed(() => getColumns(visibleColumns.value)); // Rows

  const headerRows = computed(() => getHeaderRows(visibleColumns.value));
  const hasFixedColumn = computed(() => columns.value.every(column => {
    return !column.fixLeft && !column.fixRight;
  }));
  return {
    addColumn,
    removeColumn,
    headerRows,
    columns,
    hasFixedColumn
  };
}

function ownKeys$n(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$n(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$n(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$n(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function useTableEvent(ctx) {
  const handleCellClick = (params, event) => {
    ctx.emit('cellClick', _objectSpread$n(_objectSpread$n({}, params), {}, {
      event
    }));
  };

  const handleHeaderClick = (params, event) => {
    ctx.emit('headerClick', _objectSpread$n(_objectSpread$n({}, params), {}, {
      event
    }));
  };

  const handleRowClick = (params, event) => {
    ctx.emit('rowClick', _objectSpread$n(_objectSpread$n({}, params), {}, {
      event
    }));
  };

  return {
    handleCellClick,
    handleHeaderClick,
    handleRowClick
  };
}

var useTableSelect = (_ref => {
  let {
    props,
    ctx,
    showData,
    columns,
    getRowKey
  } = _ref;
  // 
  const selectionColumn = computed(() => {
    const arr = columns.value.filter(column => column.props.type === 'selection');

    if (arr.length > 1) {
      console.warn(`[${TABLE_NAME}]: type=selection `);
    }

    return arr[0];
  });
  watch(selectionColumn, () => {
    if (selectionColumn.value && !props.rowKey) {
      console.warn(`[${TABLE_NAME}]:  selection rowKey!`);
    }
  }); //  &&  

  const selectableData = computed(() => showData.value.filter((row, rowIndex) => {
    var _selectionColumn$valu, _selectionColumn$valu2;

    if (!selectionColumn.value) return false;

    if (isFunction((_selectionColumn$valu = selectionColumn.value) === null || _selectionColumn$valu === void 0 ? void 0 : (_selectionColumn$valu2 = _selectionColumn$valu.props) === null || _selectionColumn$valu2 === void 0 ? void 0 : _selectionColumn$valu2.selectable)) {
      return selectionColumn.value.props.selectable({
        row,
        rowIndex
      });
    }

    return true;
  }));
  const [currentCheckedKeys] = useNormalModel(props, ctx.emit, {
    prop: 'checkedKeys'
  });
  const isAllSelected = computed(() => {
    return selectableData.value.length > 0 && selectableData.value.every(_row => {
      const _rowKey = getRowKey({
        row: _row
      });

      return currentCheckedKeys.value.includes(_rowKey);
    });
  });
  const isCurrentDataAnySelected = computed(() => {
    return selectableData.value.some(_row => {
      const _rowKey = getRowKey({
        row: _row
      });

      return currentCheckedKeys.value.includes(_rowKey);
    });
  });
  watch(currentCheckedKeys, () => {
    ctx.emit('selectionChange', currentCheckedKeys.value);
  }, {
    deep: true
  });

  const isSelectDisabled = _ref2 => {
    let {
      row
    } = _ref2;
    if (!selectionColumn.value) return false;
    return !selectableData.value.includes(row);
  };

  const isSelected = _ref3 => {
    let {
      row
    } = _ref3;

    const _rowKey = getRowKey({
      row
    });

    return currentCheckedKeys.value.includes(_rowKey);
  };

  const handleSelect = _ref4 => {
    let {
      row
    } = _ref4;
    if (isSelectDisabled({
      row
    })) return;
    const rowKey = getRowKey({
      row
    });
    const selectionList = currentCheckedKeys.value;
    const index = selectionList.indexOf(rowKey);

    if (index !== -1) {
      selectionList.splice(index, 1);
      ctx.emit('select', {
        selection: selectionList,
        row,
        checked: false
      });
    } else {
      selectionList.push(rowKey);
      ctx.emit('select', {
        selection: selectionList,
        row,
        checked: true
      });
    }
  };

  function splice(row) {
    const rowKey = getRowKey({
      row
    });
    const selectionList = currentCheckedKeys.value;
    const index = selectionList.indexOf(rowKey);

    if (index !== -1) {
      selectionList.splice(index, 1);
    }
  }

  function push(row) {
    const rowKey = getRowKey({
      row
    });
    const selectionList = currentCheckedKeys.value;
    const index = selectionList.indexOf(rowKey);

    if (index === -1) {
      selectionList.push(rowKey);
    }
  }

  const handleSelectAll = () => {
    if (isAllSelected.value) {
      selectableData.value.forEach(splice);
    } else {
      selectableData.value.forEach(push);
    }

    ctx.emit('selectAll', {
      selection: currentCheckedKeys.value,
      checked: !isAllSelected.value
    });
  };

  const clearSelect = () => {
    currentCheckedKeys.value.length = 0;
  };

  return {
    isSelectDisabled,
    isSelected,
    isAllSelected,
    isCurrentDataAnySelected,
    handleSelect,
    handleSelectAll,
    clearSelect
  };
});

var useTableExpand = (_ref => {
  let {
    props,
    ctx,
    columns,
    getRowKey
  } = _ref;
  // 
  const expandColumn = computed(() => {
    const arr = columns.value.filter(column => column.props.type === 'expand');

    if (arr.length > 1) {
      console.warn(`[${TABLE_NAME}]: type=expand `);
    }

    return arr[0];
  });
  watch(expandColumn, () => {
    if (expandColumn.value && !props.rowKey) {
      console.warn(`[${TABLE_NAME}]:  expand rowKey!`);
    }
  });
  const [currentExpandedKeys] = useNormalModel(props, ctx.emit, {
    prop: 'expandedKeys'
  });

  const isExpandOpened = _ref2 => {
    let {
      row
    } = _ref2;
    const rowKey = getRowKey({
      row
    });
    return currentExpandedKeys.value.includes(rowKey);
  };

  const toggleRowExpend = _ref3 => {
    let {
      row
    } = _ref3;
    const rowKey = getRowKey({
      row
    });
    const expandOpenedList = currentExpandedKeys.value;
    const index = expandOpenedList.indexOf(rowKey);

    if (index !== -1) {
      expandOpenedList.splice(index, 1);
    } else {
      expandOpenedList.push(rowKey);
    }

    return index === -1;
  };

  const handleExpand = _ref4 => {
    let {
      row
    } = _ref4;
    const expanded = toggleRowExpend({
      row
    });
    ctx.emit('expandChange', {
      row,
      expanded
    });
  };

  return {
    expandColumn,
    isExpandOpened,
    toggleRowExpend,
    handleExpand
  };
});

/**
 * 
 * 80widthwidth
 */
function useTableLayout(_ref) {
  let {
    props,
    wrapperRef,
    headerWrapperRef,
    bodyWrapperRef,
    columns,
    showData
  } = _ref;
  const bodyWidth = ref(0);
  const widthList = ref({});
  const isScrollX = ref(false);
  const isScrollY = ref(false);
  const headerHeight = ref(0);
  const bodyHeight = ref(0);
  const initRef = ref(false);

  const handlerHeight = () => {
    //  bodyWrapperHeight = 0nexttick
    nextTick(() => {
      // table
      const $wrapper = wrapperRef.value;
      const $bodyWrapper = bodyWrapperRef.value;

      if ($wrapper && $bodyWrapper && props.height) {
        const $headerWrapper = props.showHeader ? headerWrapperRef.value : {
          offsetHeight: 0
        };
        const headerWrapperHeight = $headerWrapper.offsetHeight; // wrapperRefborder-bottom

        const remainBodyHeight = props.height - headerWrapperHeight - 1;
        bodyHeight.value = remainBodyHeight;
        const bodyWrapperHeight = $bodyWrapper.offsetHeight;

        if (remainBodyHeight < bodyWrapperHeight) {
          isScrollY.value = true;
        }

        headerHeight.value = headerWrapperHeight;
      }
    });
  };

  const handlerWidth = () => {
    if (wrapperRef.value) {
      const $wrapper = wrapperRef.value;
      const _wrapperWidth = $wrapper.offsetWidth;
      const wrapperWidth = props.bordered ? _wrapperWidth - 2 : _wrapperWidth;
      let bodyMinWidth = 0;
      const min = 80;
      const newWidthList = {};
      columns.value.forEach(column => {
        const widthObj = {
          id: column.id
        };
        const width = column.props.width;
        const minWidth = column.props.minWidth;

        if (width) {
          // 
          bodyMinWidth += width;
          widthObj.width = width;
        } else if (minWidth) {
          // minWidth
          bodyMinWidth += minWidth;
          widthObj.minWidth = minWidth;
        } else if (column.props.type === 'selection' || column.props.type === 'expand') {
          // 80
          bodyMinWidth += min;
          widthObj.width = min;
        } else {
          bodyMinWidth += min;
        }

        newWidthList[column.id] = widthObj;
      });

      if (bodyMinWidth < wrapperWidth) {
        isScrollX.value = false;
        bodyWidth.value = wrapperWidth;
      } else {
        isScrollX.value = true;
        bodyWidth.value = bodyMinWidth;
      } // 


      if (!isEqual(newWidthList, widthList.value)) {
        widthList.value = newWidthList;
      }

      nextTick(() => {
        initRef.value = true;
      });
    }
  };

  const watchResizeDisableRef = ref(false);
  onDeactivated(() => {
    watchResizeDisableRef.value = true;
  });
  onActivated(() => {
    watchResizeDisableRef.value = false;
  }); // Table

  useResize(wrapperRef, handlerWidth, watchResizeDisableRef);
  watch([columns, () => props.bordered, wrapperRef], handlerWidth); // tableheight
  // nextTickwidth

  nextTick(() => {
    watch([widthList, () => props.height, () => props.showHeader, wrapperRef, bodyWrapperRef, headerWrapperRef, () => showData.value.length], () => {
      // 
      nextTick(handlerHeight);
    }, {
      immediate: true
    });
  });
  return {
    widthList,
    headerHeight,
    bodyWidth,
    bodyHeight,
    isScrollX,
    isScrollY,
    initRef
  };
}

function ownKeys$m(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$m(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$m(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$m(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$B = getPrefixCls('table');
var useTableStyle = (_ref => {
  let {
    props,
    columns,
    expandColumn,
    isExpandOpened,
    showData
  } = _ref;
  const wrapperRef = ref(null);
  const headerWrapperRef = ref(null);
  const bodyWrapperRef = ref(null);
  const scrollbarRef = ref(null);
  const wrapperClass = computed(() => [prefixCls$B, props.bordered && 'is-bordered', props.size && `is-size-${props.size}`].filter(Boolean).join(' '));
  const layout = useTableLayout({
    wrapperRef,
    headerWrapperRef,
    bodyWrapperRef,
    props,
    columns,
    showData
  });
  const scrollState = reactive({
    x: 'left'
  });
  const headerWrapperClass = computed(() => {
    const arr = [`${prefixCls$B}-header-wrapper`];

    if (scrollState.x) {
      arr.push(`is-scrolling-x-${scrollState.x}`);
    }

    return arr;
  });
  const bodyWrapperClass = computed(() => {
    const arr = [`${prefixCls$B}-body-wrapper`];

    if (scrollState.x) {
      arr.push(`is-scrolling-x-${scrollState.x}`);
    }

    return arr;
  });
  const bodyWrapperStyle = computed(() => {
    const style = {};

    if (layout.isScrollY.value) {
      style.height = `${layout.bodyHeight.value}px`;
    }

    return style;
  });
  const headerStyle = computed(() => {
    const style = {
      width: `${layout.bodyWidth.value}px`
    };
    return style;
  });
  const bodyStyle = computed(() => {
    const style = {
      width: `${layout.bodyWidth.value}px`
    };
    return style;
  });

  const getRowClassName = _ref2 => {
    let {
      row,
      rowIndex
    } = _ref2;
    const defaultClass = [`${prefixCls$B}-row`];
    const rowClassName = props.rowClassName;

    if (expandColumn.value) {
      defaultClass.push(isExpandOpened({
        row
      }) && ' is-opened');
    }

    defaultClass.push(typeof rowClassName === 'function' ? rowClassName({
      row,
      rowIndex
    }) : rowClassName);
    return defaultClass;
  };

  const getRowStyle = _ref3 => {
    let {
      row,
      rowIndex
    } = _ref3;
    const rowStyle = props.rowStyle;

    if (isPlainObject(rowStyle)) {
      return rowStyle;
    }

    if (isFunction(rowStyle)) {
      return rowStyle({
        row,
        rowIndex
      });
    }
  };

  const getCellClass = _ref4 => {
    let {
      column
    } = _ref4;
    const arr = [`${prefixCls$B}-cell`, column.id];

    if (layout.isScrollX.value && column.fixLeft) {
      arr.push(`${prefixCls$B}-fixed-left`);
    }

    if (layout.isScrollX.value && column.fixRight) {
      arr.push(`${prefixCls$B}-fixed-right`);
    }

    return arr;
  };

  const getCustomCellClass = _ref5 => {
    let {
      row,
      column,
      rowIndex,
      columnIndex
    } = _ref5;
    const colClassName = column.props.colClassName;
    const cellValue = getCellValue(row, column);
    return [typeof colClassName === 'function' ? colClassName({
      row,
      column,
      rowIndex,
      columnIndex,
      cellValue
    }) : colClassName];
  };

  const getCustomCellStyle = _ref6 => {
    let {
      row,
      column,
      rowIndex,
      columnIndex
    } = _ref6;
    const cellValue = getCellValue(row, column);
    const colStyle = column.props.colStyle;
    const align = column.props.align;
    const alignStyle = {
      'text-align': !row && column.colSpan > 1 ? 'center' : align
    };
    let extraStyle = {}; // row  colStyle

    if (row) {
      if (isPlainObject(colStyle)) {
        extraStyle = colStyle;
      }

      if (isFunction(colStyle)) {
        extraStyle = colStyle({
          row,
          column,
          rowIndex,
          columnIndex,
          cellValue
        });
      }
    }

    return _objectSpread$m(_objectSpread$m({}, alignStyle), extraStyle);
  };

  const getCellSpan = _ref7 => {
    let {
      row,
      column,
      rowIndex,
      columnIndex
    } = _ref7;
    let rowspan = '1';
    let colspan = '1';

    if (isFunction(props.spanMethod)) {
      const result = props.spanMethod({
        row,
        column,
        rowIndex,
        columnIndex
      });

      if (isPlainObject(result)) {
        rowspan = result.rowspan;
        colspan = result.colspan;
      }
    }

    return {
      rowspan,
      colspan
    };
  }; // table


  const syncPosition = throttle(e => {
    const $bodyWrapper = e.target;
    if (!$bodyWrapper) return;
    const {
      scrollLeft,
      offsetWidth,
      scrollWidth
    } = $bodyWrapper;
    const $headerWrapper = headerWrapperRef.value;

    if ($headerWrapper) {
      $headerWrapper.scrollLeft = scrollLeft;
    }

    const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;

    if (scrollLeft >= maxScrollLeftPosition) {
      scrollState.x = 'right';
    } else if (scrollLeft === 0) {
      scrollState.x = 'left';
    } else {
      scrollState.x = 'middle';
    }
  }, 10);

  const handleHeaderMousewheel = e => {
    const {
      deltaX,
      deltaY
    } = e;

    if (Math.abs(deltaX) >= Math.abs(deltaY)) {
      e.preventDefault();

      if (scrollbarRef.value) {
        scrollbarRef.value.containerRef.scrollLeft += deltaX;
      }
    }
  };

  return {
    prefixCls: prefixCls$B,
    wrapperRef,
    headerWrapperRef,
    bodyWrapperRef,
    layout,
    wrapperClass,
    bodyWrapperStyle,
    headerStyle,
    bodyStyle,
    getCellSpan,
    getRowClassName,
    getRowStyle,
    getCellClass,
    getCustomCellClass,
    getCustomCellStyle,
    syncPosition,
    handleHeaderMousewheel,
    headerWrapperClass,
    bodyWrapperClass,
    scrollbarRef
  };
});

var useTableDrag = (_ref => {
  let {
    props,
    ctx
  } = _ref;

  const onDragstart = (event, item, index) => {
    ctx.emit('dragstart', event, item, index);
  };

  const onDragend = (event, item, index) => {
    ctx.emit('dragend', event, item, index);
  };

  return {
    onDragstart,
    onDragend,
    beforeDragend: props.beforeDragend
  };
});

var useTableSort = (_ref => {
  let {
    ctx,
    columns
  } = _ref;
  const sortState = reactive({});

  const handleRowDataBySort = (data, param) => {
    const {
      prop,
      order,
      sorter
    } = param;

    if (order === 'ascend') {
      return data.sort((a, b) => {
        let res = 0;

        if (typeof sorter === 'function') {
          try {
            res = sorter(a, b) ? 1 : -1;
          } catch (e) {}
        }

        if (sorter === 'default') {
          res = a[prop] > b[prop] ? 1 : -1;
        }

        return res;
      });
    }

    if (order === 'descend') {
      return data.sort((a, b) => {
        let res = 0;

        if (typeof sorter === 'function') {
          try {
            res = sorter(a, b) ? -1 : 1;
          } catch (e) {}
        }

        if (sorter === 'default') {
          res = a[prop] > b[prop] ? -1 : 1;
        }

        return res;
      });
    }

    return data;
  };

  const handleClickSortHeader = _ref2 => {
    let {
      column
    } = _ref2;
    if (!column.props.sortable) return;

    if (sortState.prop !== column.props.prop) {
      const order = column.props.sortDirections[0];
      Object.assign(sortState, {
        prop: column.props.prop,
        order: order,
        sorter: column.props.sorter
      });
    } else {
      const index = column.props.sortDirections.indexOf(sortState.order);
      const order = column.props.sortDirections[index + 1];
      Object.assign(sortState, {
        order: order !== null && order !== void 0 ? order : false,
        sorter: column.props.sorter
      });
    }

    ctx.emit('sortChange', readonly(sortState));
  };

  const sort = (prop, order) => {
    var _column$props;

    const column = columns.value.find(col => {
      return col.props.prop === prop;
    });
    if (!column.props.sortable) return;
    Object.assign(sortState, {
      prop,
      order,
      sorter: column === null || column === void 0 ? void 0 : (_column$props = column.props) === null || _column$props === void 0 ? void 0 : _column$props.sorter
    });
    ctx.emit('sortChange', readonly(sortState));
  };

  const clearSorter = () => {
    Object.assign(sortState, {
      prop: undefined,
      order: undefined,
      sorter: undefined
    });
    ctx.emit('sortChange', readonly(sortState));
  };

  return {
    sortState,
    handleClickSortHeader,
    sort,
    clearSorter,
    handleRowDataBySort
  };
});

function ownKeys$l(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$l(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$l(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$l(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
let tableIdSeed = 1;
var useTable = ((props, ctx) => {
  const tableId = `f-table_${tableIdSeed++}`;
  const columnState = useColumn(); // 

  const showData = ref([]);
  const sortState = useTableSort({
    ctx,
    columns: columnState.columns
  });
  watch([() => props.data, sortState.sortState], () => {
    if (isArray$1(props.data)) {
      showData.value = sortState.handleRowDataBySort(props.data.slice(0), sortState.sortState);
    } else {
      console.warn(`[${TABLE_NAME}]: data must be array`);
      showData.value = [];
    }
  }, {
    immediate: true,
    deep: true
  }); // key

  const getRowKey$1 = _ref => {
    let {
      row
    } = _ref;
    return getRowKey({
      row,
      rowKey: props.rowKey
    });
  };

  const eventState = useTableEvent(ctx);
  const expandState = useTableExpand({
    props,
    ctx,
    columns: columnState.columns,
    getRowKey: getRowKey$1
  });
  const styleState = useTableStyle({
    props,
    columns: columnState.columns,
    expandColumn: expandState.expandColumn,
    isExpandOpened: expandState.isExpandOpened,
    showData
  });
  const selectState = useTableSelect({
    props,
    ctx,
    showData,
    getRowKey: getRowKey$1,
    columns: columnState.columns
  });
  const dragState = useTableDrag({
    props,
    ctx
  });

  const state = _objectSpread$l(_objectSpread$l(_objectSpread$l(_objectSpread$l(_objectSpread$l(_objectSpread$l(_objectSpread$l({
    rootProps: props,
    rootCtx: ctx,
    getRowKey: getRowKey$1,
    getCellValue,
    tableId,
    showData
  }, columnState), eventState), expandState), styleState), selectState), dragState), sortState);

  provide(provideKey$2, state);
  return state;
});

var Colgroup = defineComponent({
  props: {
    columns: {
      type: Array,
      required: true
    }
  },

  setup(props) {
    const renderColgroup = columns => createVNode("colgroup", null, [columns.map(column => createVNode("col", {
      "key": column.id,
      "style": [column.width && {
        width: `${column.width}px`
      }, column.minWidth && {
        width: `${column.minWidth}px`
      }]
    }, null))]);

    return () => renderColgroup(props.columns);
  }

});

var Header = defineComponent({
  setup() {
    const {
      headerRows,
      handleHeaderClick,
      getCellClass,
      getCustomCellStyle,
      isAllSelected,
      isCurrentDataAnySelected,
      handleSelectAll,
      handleClickSortHeader,
      prefixCls,
      sortState
    } = inject(provideKey$2);

    const renderHeader = _ref => {
      var _column$slots$header, _column$slots, _column$slots$header2, _column$props;

      let {
        column,
        columnIndex
      } = _ref;
      return (_column$slots$header = column === null || column === void 0 ? void 0 : (_column$slots = column.slots) === null || _column$slots === void 0 ? void 0 : (_column$slots$header2 = _column$slots.header) === null || _column$slots$header2 === void 0 ? void 0 : _column$slots$header2.call(_column$slots, {
        column,
        columnIndex
      })) !== null && _column$slots$header !== void 0 ? _column$slots$header : column === null || column === void 0 ? void 0 : (_column$props = column.props) === null || _column$props === void 0 ? void 0 : _column$props.label;
    };

    const renderThList = row => row.map((column, columnIndex) => {
      var _column$props$sortDir, _column$props$sortDir2;

      return createVNode("th", {
        "key": column.id,
        "colspan": column.colSpan,
        "rowspan": column.rowSpan,
        "class": [`${prefixCls}-th`, column.props.sortable && `${prefixCls}-th-sortable`, ...getCellClass({
          column
        })],
        "style": getCustomCellStyle({
          column
        }),
        "onClick": $event => {
          handleHeaderClick({
            column
          }, $event);
          handleClickSortHeader({
            column
          });
        }
      }, [column.props.type === 'default' && createVNode(Fragment, null, [renderHeader({
        column,
        columnIndex
      }), column.props.sortable && createVNode("span", {
        "class": `${prefixCls}-sorter`
      }, [((_column$props$sortDir = column.props.sortDirections) === null || _column$props$sortDir === void 0 ? void 0 : _column$props$sortDir.includes('ascend')) && createVNode("span", {
        "class": [`${prefixCls}-sorter-up`, sortState.prop === column.props.prop && sortState.order === 'ascend' && 'is-active']
      }, null), ((_column$props$sortDir2 = column.props.sortDirections) === null || _column$props$sortDir2 === void 0 ? void 0 : _column$props$sortDir2.includes('descend')) && createVNode("span", {
        "class": [`${prefixCls}-sorter-down`, sortState.prop === column.props.prop && sortState.order === 'descend' && 'is-active']
      }, null)])]), column.props.type === 'selection' && createVNode("div", {
        "class": `${prefixCls}-center`
      }, [createVNode(script$C, {
        "modelValue": isAllSelected.value,
        "indeterminate": !isAllSelected.value && isCurrentDataAnySelected.value,
        "onClick": handleSelectAll
      }, null)])]);
    }).filter(Boolean);

    const renderTrList = () => headerRows.value.map((row, rowIndex) => createVNode("tr", {
      "class": `${prefixCls}-row`,
      "key": rowIndex
    }, [renderThList(row)]));

    return () => createVNode("thead", null, [renderTrList()]);
  }

});

var HeaderTable = defineComponent({
  props: {
    columns: {
      type: Array,
      required: true
    }
  },

  setup(props) {
    const {
      prefixCls,
      headerWrapperRef,
      headerWrapperClass,
      headerStyle,
      handleHeaderMousewheel
    } = inject(provideKey$2);
    useEventListener(headerWrapperRef, 'wheel', handleHeaderMousewheel, {
      passive: false
    });
    return () => {
      return createVNode("div", {
        "ref": el => {
          headerWrapperRef.value = el;
        },
        "class": headerWrapperClass.value
      }, [createVNode("table", {
        "class": `${prefixCls}-header`,
        "style": headerStyle.value,
        "cellspacing": "0",
        "cellpadding": "0"
      }, [createVNode(Colgroup, {
        "columns": props.columns
      }, null), createVNode(Header, null, null)])]);
    };
  }

});

const cellProps = {
  row: {
    type: Object,
    required: true
  },
  rowIndex: Number,
  column: {
    type: Object,
    required: true
  },
  columnIndex: Number,
  cellValue: [String, Number, Date, Boolean, Array, Object, Function, Symbol]
};
var Cell = defineComponent({
  name: 'FTableCell',
  props: cellProps,

  setup(props) {
    const {
      prefixCls
    } = inject(provideKey$2);
    return () => {
      var _column$slots, _column$props$formatt, _column$props, _column$props$formatt2;

      const {
        row,
        column,
        cellValue
      } = props;

      if (column.props.action) {
        let actions = [];

        if (isPlainObject(column.props.action)) {
          actions = [column.props.action];
        }

        if (isArray$1(column.props.action)) {
          actions = column.props.action;
        }

        actions = actions.filter(action => action.label && isFunction(action.func));
        return createVNode("div", {
          "class": `${prefixCls}-action`
        }, [actions.map(action => createVNode(FButton$1, {
          "class": `${prefixCls}-action-item`,
          "type": "link",
          "onClick": () => {
            action.func(row);
          }
        }, {
          default: () => [action.label]
        }))]);
      }

      const hasEllipsis = !isNil(column.props.ellipsis) && column.props.ellipsis !== false;
      const ellipsisProps = isPlainObject(column.props.ellipsis) ? column.props.ellipsis : {};

      if (column !== null && column !== void 0 && (_column$slots = column.slots) !== null && _column$slots !== void 0 && _column$slots.default) {
        return hasEllipsis ? createVNode(Ellipsis, ellipsisProps, {
          default: () => [column.slots.default(props)]
        }) : createVNode(Fragment, null, [column.slots.default(props)]);
      }

      const result = (_column$props$formatt = column === null || column === void 0 ? void 0 : (_column$props = column.props) === null || _column$props === void 0 ? void 0 : (_column$props$formatt2 = _column$props.formatter) === null || _column$props$formatt2 === void 0 ? void 0 : _column$props$formatt2.call(_column$props, props)) !== null && _column$props$formatt !== void 0 ? _column$props$formatt : cellValue;
      Object.assign(ellipsisProps, {
        content: result
      });
      return hasEllipsis ? createVNode(Ellipsis, ellipsisProps, null) : createVNode(Fragment, null, [createTextVNode(" "), result, createTextVNode(" ")]);
    };
  }

});

var Td = defineComponent({
  name: 'FTableBodyTd',
  props: {
    row: {
      type: Object,
      required: true
    },
    rowIndex: Number,
    column: {
      type: Object,
      required: true
    },
    columnIndex: Number,
    onClick: Function
  },

  setup(props) {
    const {
      prefixCls,
      getCellSpan,
      getCellClass,
      getCustomCellClass,
      getCustomCellStyle,
      isSelected,
      isSelectDisabled,
      handleSelect,
      handleExpand,
      getCellValue
    } = inject(provideKey$2);
    return () => {
      const {
        row,
        column,
        rowIndex,
        columnIndex
      } = props;
      const {
        rowspan,
        colspan
      } = getCellSpan(props);

      if (!rowspan || !colspan) {
        return null;
      }

      return createVNode("td", {
        "rowspan": rowspan,
        "colspan": colspan,
        "style": getCustomCellStyle({
          row,
          column,
          rowIndex,
          columnIndex
        }),
        "class": [`${prefixCls}-td`, ...getCellClass({
          column
        }), ...getCustomCellClass({
          row,
          column,
          rowIndex,
          columnIndex
        })],
        "onClick": props.onClick
      }, [column.props.type === 'default' && createVNode(Cell, {
        "row": row,
        "rowIndex": rowIndex,
        "column": column,
        "columnIndex": columnIndex,
        "cellValue": getCellValue(row, column)
      }, null), column.props.type === 'selection' && createVNode("div", {
        "class": `${prefixCls}-center`
      }, [createVNode(script$C, {
        "modelValue": isSelected({
          row
        }),
        "disabled": isSelectDisabled({
          row
        }),
        "onClick": () => {
          handleSelect({
            row
          });
        }
      }, null)]), column.props.type === 'expand' && createVNode("div", {
        "class": `${prefixCls}-center`
      }, [createVNode(CaretDownOutlined, {
        "class": `${prefixCls}-expand-icon`,
        "onClick": () => {
          handleExpand({
            row
          });
        }
      }, null)])]);
    };
  }

});

var ExpandTr = defineComponent({
  name: 'FTableExpand',
  props: {
    row: {
      type: Object,
      required: true
    },
    column: {
      type: Object,
      required: true
    },
    rowIndex: Number,
    length: Number
  },

  setup(props) {
    const {
      prefixCls
    } = inject(provideKey$2);
    return () => {
      var _column$slots;

      const {
        row,
        rowIndex,
        column,
        length
      } = props;

      if (column !== null && column !== void 0 && (_column$slots = column.slots) !== null && _column$slots !== void 0 && _column$slots.default) {
        return createVNode("tr", {
          "class": `${prefixCls}-row`
        }, [createVNode("td", {
          "colspan": length,
          "class": `${prefixCls}-td ${prefixCls}-cell ${prefixCls}-expanded-cell`
        }, [column.slots.default({
          row,
          rowIndex,
          column
        })])]);
      }

      return null;
    };
  }

});

function ownKeys$k(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$k(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$k(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$k(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var Tr = defineComponent({
  components: {
    ExpandTr,
    Td
  },
  props: {
    row: {
      type: Object
    },
    rowIndex: {
      type: Number
    },
    columns: {
      type: Array,
      required: true
    },
    expanded: {
      type: Boolean,
      default: true
    }
  },

  setup(props) {
    const {
      handleRowClick,
      getRowStyle,
      getRowClassName,
      expandColumn,
      isExpandOpened,
      handleCellClick,
      getCellValue
    } = inject(provideKey$2);

    const renderTdList = (row, rowIndex) => props.columns.map((column, columnIndex) => createVNode(Td, {
      "key": column.id,
      "row": row,
      "rowIndex": rowIndex,
      "column": column,
      "columnIndex": columnIndex,
      "onClick": $event => {
        handleCellClick({
          row,
          column,
          cellValue: getCellValue(row, column)
        }, $event);
      }
    }, null));

    const renderTr = () => {
      const {
        row,
        rowIndex
      } = props;
      return createVNode("tr", {
        "class": getRowClassName({
          row,
          rowIndex
        }),
        "style": _objectSpread$k({}, getRowStyle({
          row,
          rowIndex
        })),
        "onClick": $event => {
          handleRowClick({
            row,
            rowIndex
          }, $event);
        }
      }, [renderTdList(row, rowIndex)]);
    };

    return () => {
      const {
        row,
        rowIndex,
        expanded
      } = props;

      if (!expanded) {
        return renderTr();
      }

      return createVNode(Fragment, null, [renderTr(), expandColumn.value && isExpandOpened({
        row
      }) && createVNode(ExpandTr, {
        "row": row,
        "column": expandColumn.value,
        "rowIndex": rowIndex,
        "length": props.columns.length
      }, null)]);
    };
  }

});

var NoData = defineComponent({
  setup() {
    const {
      prefixCls,
      columns,
      rootProps,
      rootCtx
    } = inject(provideKey$2);
    return () => {
      var _rootCtx$slots$empty, _rootCtx$slots;

      return createVNode("tbody", null, [createVNode("tr", {
        "class": `${prefixCls}-row`
      }, [createVNode("td", {
        "colspan": columns.value.length,
        "class": `${prefixCls}-td ${prefixCls}-cell ${prefixCls}-no-data`
      }, [((_rootCtx$slots$empty = (_rootCtx$slots = rootCtx.slots).empty) === null || _rootCtx$slots$empty === void 0 ? void 0 : _rootCtx$slots$empty.call(_rootCtx$slots)) || rootProps.emptyText])])]);
    };
  }

});

var BodyTable = defineComponent({
  props: {
    composed: {
      type: Boolean,
      default: false
    },
    columns: {
      type: Array,
      required: true
    }
  },

  setup(props) {
    const {
      layout,
      prefixCls,
      bodyWrapperRef,
      bodyWrapperClass,
      bodyWrapperStyle,
      bodyStyle,
      rootProps,
      showData,
      getRowKey,
      syncPosition,
      scrollbarRef,
      hasFixedColumn,
      onDragstart,
      onDragend,
      beforeDragend
    } = inject(provideKey$2);

    const renderBodyTrList = () => showData.value.map((row, rowIndex) => createVNode(Tr, {
      "row": row,
      "rowIndex": rowIndex,
      "columns": props.columns,
      "key": getRowKey({
        row
      }) || rowIndex
    }, null));

    const slots = {
      default: _ref => {
        let {
          item,
          index
        } = _ref;
        return createVNode(Tr, {
          "row": item,
          "rowIndex": index,
          "columns": props.columns,
          "expanded": false,
          "key": getRowKey({
            row: item
          }) || index
        }, null);
      }
    };

    const renderBody = () => {
      if (showData.value.length === 0) {
        return createVNode(NoData, null, null);
      }

      if (rootProps.draggable) {
        return createVNode(Draggable, {
          "tag": "tbody",
          "modelValue": showData.value,
          "onUpdate:modelValue": $event => showData.value = $event,
          "beforeDragend": beforeDragend,
          "onDragstart": onDragstart,
          "onDragend": onDragend
        }, slots);
      }

      return createVNode("tbody", null, [renderBodyTrList()]);
    };

    const renderTable = () => {
      return createVNode("table", {
        "class": `${prefixCls}-body`,
        "style": [bodyStyle.value, {
          'table-layout': props.composed ? 'fixed' : rootProps.layout
        }],
        "cellspacing": "0",
        "cellpadding": "0"
      }, [createVNode(Colgroup, {
        "columns": props.columns
      }, null), !props.composed && rootProps.showHeader && createVNode(Header, null, null), renderBody()]);
    };

    const onScroll = e => {
      if (layout.isScrollX.value || layout.isScrollY.value) {
        syncPosition(e);
      }
    };

    return () => {
      if (layout.isScrollX.value || layout.isScrollY.value) {
        return createVNode(script$n, {
          "ref": el => {
            if (el) {
              scrollbarRef.value = el;
              bodyWrapperRef.value = el.$el;
            }
          },
          "class": bodyWrapperClass.value,
          "style": bodyWrapperStyle.value,
          "horizontalRatioStyle": {
            zIndex: 3
          },
          "verticalRatioStyle": {
            zIndex: 3
          },
          "shadowStyle": {
            zIndex: 3
          },
          "shadow": {
            x: hasFixedColumn.value,
            y: true
          },
          "onScroll": onScroll
        }, {
          default: () => [renderTable()]
        });
      }

      return createVNode("div", {
        "ref": el => {
          bodyWrapperRef.value = el;
        },
        "class": bodyWrapperClass.value,
        "style": bodyWrapperStyle.value
      }, [renderTable()]);
    };
  }

});

var VirtualTable = defineComponent({
  props: {
    columns: {
      type: Array,
      required: true
    }
  },

  setup(props) {
    const {
      showData,
      rootProps,
      layout,
      prefixCls,
      bodyWrapperRef,
      bodyWrapperClass,
      bodyStyle,
      syncPosition,
      scrollbarRef,
      hasFixedColumn
    } = inject(provideKey$2);

    const renderDefault = _ref => {
      let {
        source,
        index
      } = _ref;
      return createVNode(Tr, {
        "expanded": false,
        "row": source,
        "rowIndex": index,
        "columns": props.columns
      }, null);
    };

    const renderItemList = itemVNodes => {
      return [createVNode(Colgroup, {
        columns: props.columns
      }), createVNode('tbody', {}, itemVNodes.length ? itemVNodes : [createVNode(Tr, {
        "columns": props.columns
      }, null)])];
    };

    const onScroll = e => {
      if (layout.isScrollX.value || layout.isScrollY.value) {
        syncPosition(e);
      }
    };

    return () => {
      return createVNode(VirtualList, {
        "ref": el => {
          if (el) {
            scrollbarRef.value = el.scrollRef;
            bodyWrapperRef.value = el.$el;
          }
        },
        "shadow": {
          x: hasFixedColumn.value,
          y: true
        },
        "horizontalRatioStyle": {
          zIndex: 3
        },
        "verticalRatioStyle": {
          zIndex: 3
        },
        "shadowStyle": {
          zIndex: 3
        },
        "onScroll": onScroll,
        "dataSources": showData.value,
        "dataKey": rootProps.rowKey,
        "estimateSize": 54,
        "keeps": 20,
        "class": bodyWrapperClass.value,
        "maxHeight": layout.bodyHeight.value,
        "wrapTag": 'table',
        "wrapClass": `${prefixCls}-body`,
        "wrapStyle": bodyStyle.value,
        "renderItemList": renderItemList
      }, {
        default: renderDefault
      });
    };
  }

});

function ownKeys$j(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$j(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$j(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$j(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const tableProps = {
  data: {
    type: Array,
    default: () => []
  },
  rowKey: [Function, String],
  bordered: {
    type: Boolean,
    default: false
  },
  showHeader: {
    type: Boolean,
    default: true
  },
  emptyText: {
    type: String,
    default: ''
  },
  size: {
    type: String,
    default: 'middle'
  },
  spanMethod: Function,
  rowClassName: [Function, String, Array, Object],
  rowStyle: [Function, Object],
  height: Number,
  virtualScroll: {
    type: Boolean,
    default: false
  },
  layout: {
    type: String,
    default: 'fixed'
  },
  draggable: {
    type: Boolean,
    default: false
  },
  beforeDragend: Function,
  checkedKeys: {
    type: Array,

    default() {
      return [];
    }

  },
  expandedKeys: {
    type: Array,

    default() {
      return [];
    }

  }
};
var Table = defineComponent({
  name: TABLE_NAME,
  props: tableProps,
  emits: ['cellClick', 'expandChange', 'headerClick', 'rowClick', 'select', 'selectAll', 'selectionChange', 'sortChange', 'dragstart', 'dragend', 'update:checkedKeys', 'update:expandedKeys'],

  setup(props, ctx) {
    var _ctx$expose;

    useTheme();
    const {
      handleSelect,
      handleSelectAll,
      clearSelect,
      wrapperRef,
      wrapperClass,
      layout,
      columns,
      rootProps,
      toggleRowExpend,
      sort,
      clearSorter,
      showData
    } = useTable(props, ctx);
    (_ctx$expose = ctx.expose) === null || _ctx$expose === void 0 ? void 0 : _ctx$expose.call(ctx, {
      toggleRowSelection: handleSelect,
      toggleAllSelection: handleSelectAll,
      clearSelection: clearSelect,
      toggleRowExpend,
      sort,
      clearSorter
    }); // columns

    const columnsRef = computed(() => {
      const widthListValue = layout.widthList.value;
      return columns.value.map(column => {
        var _column$id, _column$id2;

        return _objectSpread$j(_objectSpread$j({}, column), {}, {
          width: (_column$id = widthListValue[column.id]) === null || _column$id === void 0 ? void 0 : _column$id.width,
          minWidth: (_column$id2 = widthListValue[column.id]) === null || _column$id2 === void 0 ? void 0 : _column$id2.minWidth
        });
      });
    }); // table

    const composed = computed(() => {
      return !isUndefined(rootProps.height);
    });
    watch(() => props.virtualScroll, () => {
      if (props.virtualScroll && !props.rowKey) {
        console.warn(`[${TABLE_NAME}]: rowKey!`);
      }
    }, {
      immediate: true
    });

    const render = () => {
      if (!layout.initRef.value) {
        return;
      }

      return createVNode(Fragment, null, [composed.value && rootProps.showHeader && createVNode(HeaderTable, {
        "columns": columnsRef.value
      }, null), rootProps.virtualScroll && showData.value.length ? createVNode(VirtualTable, {
        "columns": columnsRef.value
      }, null) : createVNode(BodyTable, {
        "composed": composed.value,
        "columns": columnsRef.value
      }, null)]);
    };

    return () => {
      var _ctx$slots$default, _ctx$slots;

      return createVNode("div", {
        "ref": wrapperRef,
        "class": wrapperClass.value
      }, [createVNode("div", {
        "ref": "hiddenColumns",
        "class": "hidden-columns"
      }, [(_ctx$slots$default = (_ctx$slots = ctx.slots).default) === null || _ctx$slots$default === void 0 ? void 0 : _ctx$slots$default.call(_ctx$slots)]), render()]);
    };
  }

});

const columnProps = {
  label: String,
  prop: String,
  type: {
    type: String,
    default: 'default'
  },
  align: {
    type: String,
    default: 'left'
  },
  width: Number,
  minWidth: Number,
  colClassName: [Function, String, Array, Object],
  colStyle: [Function, Object],
  fixed: {
    type: [Boolean, String]
  },
  formatter: Function,
  resizable: {
    type: Boolean,
    default: false
  },
  sortable: {
    type: Boolean,
    default: false
  },
  sortDirections: {
    type: Array,
    default: ['descend', 'ascend']
  },
  sortOrder: {
    type: [String, Boolean],
    default: false
  },
  sorter: {
    type: [Function, String],
    default: 'default'
  },
  selectable: Function,
  action: [Object, Array],
  ellipsis: {
    type: [Boolean, Object],
    default: false
  },
  visible: {
    type: Boolean,
    default: true
  }
};
var Column = defineComponent({
  name: TABLE_COLUMN_NAME,
  props: columnProps,

  setup(props, ctx) {
    const table = inject(provideKey$2, null);

    if (!table) {
      return console.error(`[${TABLE_COLUMN_NAME}]: ${TABLE_COLUMN_NAME}  ${TABLE_NAME} `);
    }

    const instance = getCurrentInstance();
    const parentInstance = instance.parent;
    const {
      addColumn,
      removeColumn
    } = table;
    onBeforeMount(() => {
      addColumn({
        id: instance.uid,
        props,
        slots: ctx.slots,
        parentId: parentInstance.uid || null
      });
    });
    onBeforeUnmount(() => {
      removeColumn(instance.uid);
    });
  },

  render() {
    let children = [];

    try {
      var _this$$slots$default, _this$$slots;

      const renderDefault = (_this$$slots$default = (_this$$slots = this.$slots).default) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots, {
        row: {},
        rowIndex: -1,
        column: {},
        columnIndex: -1,
        cellValue: null
      });

      if (renderDefault instanceof Array) {
        renderDefault.forEach(childNode => {
          var _childNode$type;

          if (((_childNode$type = childNode.type) === null || _childNode$type === void 0 ? void 0 : _childNode$type.name) === TABLE_COLUMN_NAME || childNode.shapeFlag !== 36) {
            children.push(childNode);
          } else if (childNode.type === Fragment && childNode.children instanceof Array) {
            children.push(...childNode.children);
          }
        });
      }
    } catch (_unused) {
      children = [];
    }

    return h('div', children);
  }

});

const FTable = withInstall(Table, {
  Column
});
const FTableColumn = withNoopInstall(Column);

var useScrollX = (targetRef => {
  function handleWheelEvent(event) {
    const currentTarget = event.currentTarget;
    if (!currentTarget) return;
    const preventYWheel = currentTarget.offsetWidth < currentTarget.scrollWidth;
    if (!preventYWheel || event.deltaY === 0) return;
    currentTarget.scrollLeft += event.deltaY + event.deltaX;
    event.preventDefault();
  }

  function scrollTo(options) {
    var _targetRef$value;

    (_targetRef$value = targetRef.value) === null || _targetRef$value === void 0 ? void 0 : _targetRef$value.scrollTo(options);
  }

  onMounted(() => {
    targetRef.value.addEventListener('wheel', handleWheelEvent);
  });
  onBeforeUnmount(() => {
    targetRef.value.removeEventListener('wheel', handleWheelEvent);
  });
  return {
    scrollTo
  };
});

const tabProps = {
  key: [String, Number, Symbol],
  value: {
    type: [String, Number],
    required: true
  },
  name: [String, Number],
  disabled: Boolean,
  closable: {
    type: Boolean,
    default: null
  },
  displayDirective: {
    type: String,
    default: 'if'
  }
};
/**
 * TabBar
 */

function computeTabBarStyle(tabEl) {
  let pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  const style = {
    width: '0px',
    height: '0px',
    transform: ''
  };
  if (!tabEl || tabEl.children.length <= 0) return style;
  const firstRect = tabEl.parentElement.children[0].getBoundingClientRect();
  const currRect = tabEl.children[0].getBoundingClientRect();

  switch (pos) {
    case 'left':
    case 'right':
      style.width = '2px';
      style.height = `${currRect.height}px`;
      style.transform = `translate(0px, ${currRect.top - firstRect.top}px)`;
      break;

    case 'top':
    case 'bottom':
      style.width = `${currRect.width}px`;
      style.height = '2px';
      style.transform = `translate(${currRect.left - firstRect.left}px, 0px)`;
      break;
  }

  return style;
}

const prefixCls$A = getPrefixCls('tabs');
var FTab = defineComponent({
  props: tabProps,

  setup(props, ctx) {
    const {
      valueRef,
      tabsLength,
      closableRef,
      isCard,
      handleTabClick,
      handleClose,
      closeModeRef,
      setDefaultValue
    } = inject(TABS_INJECTION_KEY);
    const mergeClosable = computed(() => {
      if (!isCard.value) return;
      return typeof props.closable === 'boolean' ? props.closable : closableRef.value;
    });
    setDefaultValue(props.value);

    function handleClick() {
      if (props.disabled) return;
      handleTabClick(props.value);
    }

    function handleCloseClick(event) {
      event.stopPropagation();
      handleClose(props.value);
    }

    tabsLength.value = tabsLength.value + 1;
    onBeforeUnmount(() => {
      tabsLength.value = tabsLength.value - 1;
    });
    return () => {
      const defaultSlot = ctx.slots.default;
      return createVNode("div", {
        "key": props.value,
        "onClick": handleClick,
        "class": {
          [`${prefixCls$A}-tab`]: true,
          [`${prefixCls$A}-tab-card`]: isCard.value,
          [`${prefixCls$A}-tab-active`]: valueRef.value === props.value,
          [`${prefixCls$A}-tab-disabled`]: props.disabled,
          hover: closeModeRef.value === 'hover'
        }
      }, [createVNode("div", {
        "class": `${prefixCls$A}-tab-label`
      }, [defaultSlot ? defaultSlot() : props.name]), mergeClosable.value && createVNode("div", {
        "class": `${prefixCls$A}-tab-close`
      }, [createVNode(CloseCircleFilled, {
        "onClick": handleCloseClick
      }, null)])]);
    };
  }

});

const prefixCls$z = getPrefixCls('tabs');
const ADD_EVENT = 'add';

function mapTabPane() {
  let tabPaneVNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let tabValue = arguments.length > 1 ? arguments[1] : undefined;
  let tabPaneLazyCache = arguments.length > 2 ? arguments[2] : undefined;
  const children = [];
  tabPaneVNodes.forEach(vNode => {
    const {
      value,
      'display-directive': _displayDirective,
      displayDirective
    } = vNode.props;
    if (!vNode.key) vNode.key = value;
    if (!vNode.props.key) vNode.props.key = value;
    const show = value === tabValue;
    const directive = _displayDirective || displayDirective;

    if (directive === 'show') {
      children.push(withDirectives(vNode, [[vShow, show]]));
    } else if (directive === 'show:lazy' && (tabPaneLazyCache[value] || show)) {
      tabPaneLazyCache[value] = true;
      children.push(withDirectives(vNode, [[vShow, show]]));
    } else if (show) {
      children.push(vNode);
    }
  });
  return children;
}

var Tabs = defineComponent({
  name: 'FTabs',
  props: {
    modelValue: [String, Number],
    position: {
      type: String,
      default: 'top'
    },
    type: {
      type: String,
      default: 'line'
    },
    closable: {
      type: Boolean,
      default: false
    },
    closeMode: {
      type: String,
      default: 'visible'
    },
    addable: {
      type: Boolean,
      default: false
    },
    transition: {
      type: [String, Boolean],
      default: true
    }
  },
  emits: [UPDATE_MODEL_EVENT$1, CHANGE_EVENT$1, CLOSE_EVENT, ADD_EVENT],

  setup(props, ctx) {
    useTheme();
    const tabPaneLazyCache = {};
    const tabRefs = ref([]);
    const isScroll = ref(false);
    const [currentValue, updateCurrentValue] = useNormalModel(props, ctx.emit);
    const tabsLength = ref(0);
    const isCard = computed(() => props.type === 'card');
    const position = computed(() => isCard.value ? 'top' : props.position);
    const showBeforeScrollBar = ref(false);
    const showAfterScrollBar = ref(false);
    const tabNavRef = ref(null);
    onMounted(() => {
      if (!tabNavRef.value) return;
      useScrollX(tabNavRef);
    });
    const barStyle = ref({});

    function setTabRefs(el, index) {
      if (el) tabRefs.value[index] = el;
    }

    function handleTabClick(key) {
      updateCurrentValue(key);
      ctx.emit(CHANGE_EVENT$1, key);
    }

    function handleAddClick(event) {
      ctx.emit(ADD_EVENT, event);
    }

    function handleClose(key) {
      ctx.emit(CLOSE_EVENT, key);
    }

    function handleTabNavScroll(event) {
      event === null || event === void 0 ? void 0 : event.preventDefault();
      if (!tabNavRef.value) return;
      if (!isScroll.value) return;
      const {
        scrollWidth,
        scrollHeight,
        scrollLeft,
        scrollTop,
        offsetWidth,
        offsetHeight
      } = tabNavRef.value;
      showBeforeScrollBar.value = scrollLeft > 0 || scrollTop > 0;
      showAfterScrollBar.value = scrollLeft + offsetWidth < scrollWidth || scrollTop + offsetHeight < scrollHeight;
    }

    function autoScrollTab(el) {
      if (!tabNavRef.value || !el) return;
      if (!isScroll.value) return;
      const {
        scrollLeft,
        scrollTop,
        offsetWidth,
        offsetHeight
      } = tabNavRef.value;

      if (['top', 'bottom'].includes(props.position) && (scrollLeft + offsetWidth < el.offsetLeft + el.offsetWidth || el.offsetLeft < scrollLeft)) {
        tabNavRef.value.scrollTo({
          left: el.offsetLeft - offsetWidth + el.offsetWidth
        });
      } else if (['left', 'right'].includes(props.position) && (scrollTop + offsetHeight < el.offsetTop + el.offsetHeight || el.offsetTop < scrollTop)) {
        tabNavRef.value.scrollTo({
          top: el.offsetTop - offsetHeight + el.offsetHeight
        });
      }

      handleTabNavScroll();
    } // Tab


    const setDefaultValue = value => {
      if (!currentValue.value && currentValue.value !== 0) {
        updateCurrentValue(value);
      }
    };

    provide(TABS_INJECTION_KEY, {
      valueRef: currentValue,
      closableRef: toRef(props, 'closable'),
      closeModeRef: toRef(props, 'closeMode'),
      isCard,
      tabsLength,
      handleTabClick,
      handleClose,
      setDefaultValue
    });
    watch(() => [currentValue.value, position.value], () => {
      nextTick(() => {
        const tab = tabRefs.value.find(item => item.value === currentValue.value);

        if (!isCard.value) {
          barStyle.value = computeTabBarStyle(tab === null || tab === void 0 ? void 0 : tab.$el, position.value);
        }

        autoScrollTab(tab === null || tab === void 0 ? void 0 : tab.$el);
      });
    }, {
      immediate: true
    });
    watch(tabsLength, () => {
      nextTick(() => {
        if (!tabNavRef.value) return;
        const {
          scrollWidth,
          offsetWidth,
          scrollHeight,
          offsetHeight
        } = tabNavRef.value;

        if (scrollWidth > offsetWidth || scrollHeight > offsetHeight) {
          isScroll.value = true;
        }
      });
    });
    return () => {
      const children = ctx.slots.default && flatten(ctx.slots.default()).filter(vNode => vNode.type.name === 'FTabPane');
      return createVNode("div", {
        "class": {
          [`${prefixCls$z}`]: true,
          [`${prefixCls$z}-${position.value}`]: true,
          [`${prefixCls$z}-card`]: isCard.value
        }
      }, [createVNode("div", {
        "class": `${prefixCls$z}-nav`
      }, [ctx.slots.prefix && createVNode("div", {
        "class": `${prefixCls$z}-nav-prefix`
      }, [ctx.slots.prefix()]), createVNode("div", {
        "class": {
          [`${prefixCls$z}-nav-wrapper`]: true,
          [`${prefixCls$z}-nav-wrapper--before`]: showBeforeScrollBar.value,
          [`${prefixCls$z}-nav-wrapper--after`]: showAfterScrollBar.value
        }
      }, [createVNode("div", {
        "class": `${prefixCls$z}-nav-scroll`,
        "onScroll": handleTabNavScroll,
        "ref": tabNavRef
      }, [children.map((vNode, index) => {
        var _vNode$children;

        const tabSlot = (_vNode$children = vNode.children) === null || _vNode$children === void 0 ? void 0 : _vNode$children.tab;
        return createVNode(Fragment, null, [index > 0 && isCard.value && createVNode("div", {
          "class": `${prefixCls$z}-tab-pad`
        }, null), createVNode(FTab, mergeProps(vNode.props, {
          "ref": el => setTabRefs(el, index)
        }), {
          default: tabSlot
        })]);
      }), !isCard.value && createVNode("div", {
        "class": `${prefixCls$z}-nav-bar`,
        "style": barStyle.value
      }, null)])]), isCard.value && props.addable && createVNode(Fragment, null, [createVNode("div", {
        "class": `${prefixCls$z}-tab-pad`
      }, null), createVNode("div", {
        "onClick": handleAddClick,
        "class": `${prefixCls$z}-tab ${prefixCls$z}-tab-card addable`
      }, [createVNode(PlusOutlined, null, null)])]), ctx.slots.suffix ? createVNode("div", {
        "class": `${prefixCls$z}-nav-suffix`
      }, [ctx.slots.suffix()]) : isCard.value && createVNode("div", {
        "class": `${prefixCls$z}-tab-pad--last`
      }, null)]), createVNode("div", {
        "class": `${prefixCls$z}-tab-pane-wrapper`
      }, [createVNode(TransitionGroup, {
        "name": props.transition ? props.transition === true ? `${prefixCls$z}-slide-fade` : props.transition : null
      }, {
        default: () => [mapTabPane(children, currentValue.value, tabPaneLazyCache)]
      })])]);
    };
  }

});

const prefixCls$y = getPrefixCls('tabs');
var script$i = defineComponent({
  name: 'FTabPane',
  props: tabProps,

  setup() {
    const FTab = inject(TABS_INJECTION_KEY, null);

    if (!FTab) {
      return console.error('[FTabPane]: FTabPane  FTabs ');
    }

    return {
      prefixCls: prefixCls$y
    };
  }

});

function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-tab-pane`)
  }, [renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$i.render = render$g;
script$i.__file = "components/tabs/tab-pane.vue";

const FTabs = withInstall(Tabs, {
  TabPane: script$i
});
const FTabPane = withNoopInstall(script$i);

const FTag = withInstall(script$m);

const prefixCls$x = getPrefixCls('time-picker');
const pickerItemProps = {
  visible: Boolean,
  value: {
    type: String,
    default: ''
  },
  focus: {
    type: Number,
    default: -1
  },
  times: {
    type: Array,

    default() {
      return [];
    }

  },
  visibleCount: {
    type: Number,
    default: 8
  }
};
var script$h = defineComponent({
  components: {
    FScrollbar: script$n
  },
  props: pickerItemProps,
  emits: ['change'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const rootRefEl = ref();
    const itemHeight = 24;
    const scrollbarRef = ref();
    const selectedIndex = computed(() => {
      if (props.value) {
        return props.times.findIndex(item => item.value === props.value);
      }

      return -1;
    });

    const scrollToSelected = duration => {
      // move to selected ite
      const rootDom = rootRefEl.value;

      if (!rootDom) {
        return;
      }

      let index = selectedIndex.value;

      if (index < 0) {
        index = 0;
      }

      const to = rootDom.children[index].offsetTop;
      const firstTop = rootDom.children[0].offsetTop;
      scrollbarRef.value.setScrollTop(to - firstTop, duration);
    };

    watch(selectedIndex, () => {
      nextTick(() => {
        scrollToSelected(120);
      });
    });
    watch(() => props.visible, () => {
      if (props.visible) {
        nextTick(() => {
          // scrollbarRef.value.update();
          scrollToSelected(0);
        });
      }
    });
    const paddingBottom = computed(() => (props.visibleCount - 1) * itemHeight);

    const scrollToView = duration => {
      const index = props.focus;
      const rootDom = rootRefEl.value;

      if (!rootDom || index < 0) {
        return;
      }

      const scrollTop = rootDom.scrollTop;
      const offsetTop = rootDom.children[index].offsetTop;
      const difference = offsetTop - scrollTop;

      if (difference < 0) {
        scrollbarRef.value.setScrollTop(offsetTop, duration);
      } else if (difference > paddingBottom.value) {
        scrollbarRef.value.setScrollTop(scrollTop + (difference - paddingBottom.value), duration);
      }
    };

    watch(() => props.focus, () => {
      nextTick(() => {
        scrollToView(0);
      });
    });

    const selectedTime = e => {
      if (!e.target) return;
      const key = e.target.getAttribute('data-key');
      const option = props.times.find(item => item.value === key);

      if (option && !option.disabled) {
        emit('change', option);
      }
    };

    onMounted(() => {
      nextTick(() => {
        scrollToSelected(0);
      });
    });
    const visibleHeight = computed(() => props.visibleCount * itemHeight);
    const style = computed(() => ({
      'padding-bottom': `${paddingBottom.value}px`
    }));
    return {
      visibleHeight,
      style,
      scrollbarRef,
      prefixCls: prefixCls$x,
      rootRefEl,
      selectedIndex,
      selectedTime
    };
  }

});

const _hoisted_1$7 = ["data-key"];
function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FScrollbar = resolveComponent("FScrollbar");

  return openBlock(), createBlock(_component_FScrollbar, {
    ref: "scrollbarRef",
    height: _ctx.visibleHeight,
    noresize: ""
  }, {
    default: withCtx(() => [createElementVNode("ul", {
      ref: "rootRefEl",
      class: normalizeClass(`${_ctx.prefixCls}-content-item`),
      style: normalizeStyle(_ctx.style),
      onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"])),
      onClick: _cache[1] || (_cache[1] = withModifiers(function () {
        return _ctx.selectedTime && _ctx.selectedTime(...arguments);
      }, ["stop"]))
    }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.times, (item, index) => {
      return openBlock(), createElementBlock("li", {
        key: item.value,
        "data-key": item.value,
        class: normalizeClass({
          [`${_ctx.prefixCls}-content-item-child`]: true,
          'is-disabled': item.disabled,
          'is-active': item.value === _ctx.value,
          'is-focus': _ctx.focus === index
        })
      }, toDisplayString(item.value), 11
      /* TEXT, CLASS, PROPS */
      , _hoisted_1$7);
    }), 128
    /* KEYED_FRAGMENT */
    ))], 38
    /* CLASS, STYLE, HYDRATE_EVENTS */
    )]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["height"]);
}

script$h.render = render$f;
script$h.__file = "components/time-picker/picker-item.vue";

function ownKeys$i(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$i(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$i(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$i(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$w = getPrefixCls('time-picker');

function formatTime(total, step, disable) {
  let format = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  const formatData = [];

  for (let i = 0; i < total; i += step) {
    let value;

    if (format) {
      value = `${i}`.padStart(2, '0');
    } else {
      value = `${i}`;
    }

    formatData.push({
      disabled: disable && disable(Number(value)),
      value
    });
  }

  return formatData;
}

const timeSelectProps = {
  visible: {
    type: Boolean,
    default: false
  },
  modelValue: {
    type: String,
    default: ''
  },
  format: {
    type: String,
    default: 'HH:mm:ss'
  },
  hourStep: {
    type: Number,
    default: 1
  },
  minuteStep: {
    type: Number,
    default: 1
  },
  secondStep: {
    type: Number,
    default: 1
  },
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  },
  visibleCount: {
    type: Number,
    default: 8
  }
};
var script$g = defineComponent({
  components: {
    PickerItem: script$h
  },
  props: timeSelectProps,
  emits: ['update:modelValue', 'change'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const focusKey = reactive({
      1: -1,
      2: -1,
      4: -1
    });
    const initialSelectedTime = {
      hour: null,
      minute: null,
      seconds: null
    };
    const selectedTime = reactive(_objectSpread$i({}, initialSelectedTime));

    const formatSingleTime = timeFormat => props.format.indexOf(timeFormat) !== -1 ? '00' : '0';

    const parseTime = () => {
      if (!props.modelValue) {
        Object.assign(selectedTime, initialSelectedTime);
        return;
      }

      const splitTime = props.modelValue.split(':');

      if (/H/.test(props.format)) {
        selectedTime.hour = splitTime.shift() || formatSingleTime('HH');
      }

      if (/m/.test(props.format)) {
        selectedTime.minute = splitTime.shift() || formatSingleTime('mm');
      }

      if (/s/.test(props.format)) {
        selectedTime.seconds = splitTime.shift() || formatSingleTime('ss');
      }
    };

    const setSelectedTimeDefault = () => {
      if (/H/.test(props.format) && !selectedTime.hour) {
        selectedTime.hour = formatSingleTime('HH');
      }

      if (/m/.test(props.format) && !selectedTime.minute) {
        selectedTime.minute = formatSingleTime('mm');
      }

      if (/s/.test(props.format) && !selectedTime.seconds) {
        selectedTime.seconds = formatSingleTime('ss');
      }
    };

    const canSelectHours = computed(() => {
      if (props.format.indexOf('H') !== -1) {
        return formatTime(24, props.hourStep, h => props.disabledHours && props.disabledHours(h), /HH/.test(props.format));
      }

      return null;
    });

    const changeSelectedHour = option => {
      selectedTime.hour = option.value;
      setSelectedTimeDefault();
    };

    const canSelectMinutes = computed(() => {
      if (props.format.indexOf('m') !== -1) {
        return formatTime(60, props.minuteStep, m => props.disabledMinutes && props.disabledMinutes(Number(selectedTime.hour), m), /mm/.test(props.format));
      }

      return null;
    });

    const changeSelectedMinute = option => {
      selectedTime.minute = option.value;
      setSelectedTimeDefault();
    };

    const canSelectSeconds = computed(() => {
      if (props.format.indexOf('s') !== -1) {
        return formatTime(60, props.secondStep, s => props.disabledSeconds && props.disabledSeconds(Number(selectedTime.hour), Number(selectedTime.minute), s), /ss/.test(props.format));
      }

      return null;
    });

    const changeSelectedSeconds = option => {
      selectedTime.seconds = option.value;
      setSelectedTimeDefault();
    };

    const timeString = computed(() => {
      let currentTime = '';
      const {
        hour,
        minute,
        seconds
      } = selectedTime;

      if (!(hour || minute || seconds)) {
        return currentTime;
      }

      if (/H/.test(props.format)) {
        currentTime += hour;
      }

      if (/m/.test(props.format)) {
        currentTime += currentTime.length > 0 ? `:${minute}` : minute;
      }

      if (/s/.test(props.format)) {
        currentTime += currentTime.length > 0 ? `:${seconds}` : seconds;
      }

      return currentTime;
    });
    watch(timeString, () => {
      emit('update:modelValue', timeString.value);
      emit('change', timeString.value);
    });
    watch(() => props.modelValue, () => {
      if (timeString.value !== props.modelValue) {
        parseTime();
      }
    }, {
      immediate: true
    });
    return {
      prefixCls: prefixCls$w,
      canSelectHours,
      canSelectMinutes,
      canSelectSeconds,
      changeSelectedHour,
      changeSelectedMinute,
      changeSelectedSeconds,
      focusKey,
      selectedTime
    };
  }

});

function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_picker_item = resolveComponent("picker-item");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(`${_ctx.prefixCls}-content`),
    tabindex: "0"
  }, [_ctx.canSelectHours ? (openBlock(), createBlock(_component_picker_item, {
    key: 0,
    visible: _ctx.visible,
    times: _ctx.canSelectHours,
    value: _ctx.selectedTime.hour,
    focus: _ctx.focusKey['1'],
    class: normalizeClass(`${_ctx.prefixCls}-content-cell`),
    visibleCount: _ctx.visibleCount,
    onChange: _ctx.changeSelectedHour
  }, null, 8
  /* PROPS */
  , ["visible", "times", "value", "focus", "class", "visibleCount", "onChange"])) : createCommentVNode("v-if", true), _ctx.canSelectMinutes ? (openBlock(), createBlock(_component_picker_item, {
    key: 1,
    visible: _ctx.visible,
    times: _ctx.canSelectMinutes,
    value: _ctx.selectedTime.minute,
    focus: _ctx.focusKey['2'],
    class: normalizeClass(`${_ctx.prefixCls}-content-cell`),
    visibleCount: _ctx.visibleCount,
    onChange: _ctx.changeSelectedMinute
  }, null, 8
  /* PROPS */
  , ["visible", "times", "value", "focus", "class", "visibleCount", "onChange"])) : createCommentVNode("v-if", true), _ctx.canSelectSeconds ? (openBlock(), createBlock(_component_picker_item, {
    key: 2,
    visible: _ctx.visible,
    times: _ctx.canSelectSeconds,
    value: _ctx.selectedTime.seconds,
    focus: _ctx.focusKey['4'],
    class: normalizeClass(`${_ctx.prefixCls}-content-cell`),
    visibleCount: _ctx.visibleCount,
    onChange: _ctx.changeSelectedSeconds
  }, null, 8
  /* PROPS */
  , ["visible", "times", "value", "focus", "class", "visibleCount", "onChange"])) : createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$g.render = render$e;
script$g.__file = "components/time-picker/time-select.vue";

const prefixCls$v = getPrefixCls('time-picker'); // TODO  12 

function formatTimeCell(data) {
  return `${data}`.padStart(2, '0');
}

const getCurrentTime = format => {
  const date = new Date();
  return [format.indexOf('H') !== -1 && formatTimeCell(date.getHours()), format.indexOf('m') !== -1 && formatTimeCell(date.getMinutes()), format.indexOf('s') !== -1 && formatTimeCell(date.getSeconds())].filter(Boolean).join(':');
};

function validator(val, cellFormat, max) {
  if (!val) return false;

  if (val.length > 3 || !/^\d{1,2}$/.test(val) || Number(val) > max || val.length < cellFormat.length) {
    return false;
  }

  return true;
}

function validateTime(data, format) {
  const times = data.split(':');
  const cellFormats = format.split(':');

  if (times.length !== cellFormats.length) {
    return false;
  }

  for (let i = 0; i < cellFormats.length; ++i) {
    const cellFormat = cellFormats[i];

    if (/[Hh]/.test(cellFormat)) {
      if (!validator(times.shift(), cellFormat, 23)) return false;
    } else {
      if (!validator(times.shift(), cellFormat, 59)) return false;
    }
  }

  return true;
}

const timePickerProps = {
  modelValue: {
    type: [String, Array],
    default: ''
  },
  open: {
    type: Boolean,
    default: false
  },
  appendToContainer: {
    type: Boolean,
    default: true
  },
  getContainer: {
    type: Function
  },
  placeholder: {
    type: String,
    default: ''
  },
  // FEATURE 
  isRange: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: true
  },
  format: {
    type: String,
    default: 'HH:mm:ss'
  },
  hourStep: {
    type: Number,
    default: 1
  },
  minuteStep: {
    type: Number,
    default: 1
  },
  secondStep: {
    type: Number,
    default: 1
  },
  disabledHours: Function,
  disabledMinutes: Function,
  disabledSeconds: Function,
  control: {
    type: Boolean,
    default: true
  },
  showSuffix: {
    type: Boolean,
    default: true
  },
  inputClass: {
    type: [String, Object, Array]
  }
};

function useOpen(props, emit) {
  const [isOpened, updateCurrentValue] = useNormalModel(props, emit, {
    prop: 'open'
  });

  const closePopper = () => {
    updateCurrentValue(false);
  };

  return {
    isOpened,
    closePopper
  };
}

var script$f = defineComponent({
  name: 'FTimePicker',
  components: {
    TimeSelect: script$g,
    InputInner: script$y,
    Popper: FPopper,
    ClockCircleOutlined,
    FButton
  },
  props: timePickerProps,
  emits: [UPDATE_MODEL_EVENT$1, 'update:open', 'change', 'blur', 'focus'],

  setup(props, _ref) {
    let {
      emit,
      slots,
      attrs
    } = _ref;
    useTheme();
    const {
      validate,
      isError,
      isFormDisabled
    } = useFormAdaptor({
      forbidChildValidate: true
    });
    const innerDisabled = computed(() => props.disabled || isFormDisabled.value);
    const [currentValue, updateCurrentValue] = useNormalModel(props, emit);
    const {
      isOpened,
      closePopper
    } = useOpen(props, emit);
    const classes = computed(() => [prefixCls$v, (isFormDisabled.value || props.disabled) && 'is-disabled', props.inputClass].filter(Boolean));
    const showControl = computed(() => props.control || slots.addon);
    const tempValue = ref();
    const {
      t
    } = useLocale();
    const inputPlaceholder = computed(() => props.placeholder || t('timePicker.placeholder'));
    const activeTime = ref();

    const changeTime = val => {
      tempValue.value = '';
      activeTime.value = val;
    };

    const setCurrentValue = val => {
      if (val !== currentValue.value) {
        tempValue.value = '';
        updateCurrentValue(val);
        emit('change', val);
        validate('change');
        activeTime.value = val;
      }
    };

    const clear = () => {
      setCurrentValue('');
    };

    watch(isOpened, () => {
      if (!isOpened.value && activeTime.value) {
        setCurrentValue(activeTime.value);
      }
    });

    const handleInput = val => {
      tempValue.value = val;

      if (validateTime(val, props.format)) {
        setCurrentValue(val);
      }
    };

    const setCurrentTime = () => {
      setCurrentValue(getCurrentTime(props.format));
      closePopper();
    };

    const confirmChangeTime = () => {
      closePopper();
    };

    const displayValue = computed(() => {
      if (props.isRange) {
        return currentValue.value || [];
      }

      return tempValue.value || activeTime.value || currentValue.value || '';
    });

    const handleBlur = event => {
      closePopper();
      emit('blur', event);
      validate('blur'); // 

      tempValue.value = null;
    };

    return {
      prefixCls: prefixCls$v,
      isError,
      innerDisabled,
      classes,
      displayValue,
      isOpened,
      currentValue,
      tempValue,
      handleInput,
      handleBlur,
      clear,
      changeTime,
      showControl,
      setCurrentTime,
      confirmChangeTime,
      activeTime,
      inputPlaceholder,
      t,
      attrs
    };
  }

});

function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ClockCircleOutlined = resolveComponent("ClockCircleOutlined");

  const _component_InputInner = resolveComponent("InputInner");

  const _component_TimeSelect = resolveComponent("TimeSelect");

  const _component_FButton = resolveComponent("FButton");

  const _component_Popper = resolveComponent("Popper");

  return openBlock(), createBlock(_component_Popper, {
    modelValue: _ctx.isOpened,
    "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => _ctx.isOpened = $event),
    trigger: "click",
    placement: "bottom-start",
    popperClass: `${_ctx.prefixCls}-popper`,
    disabled: _ctx.innerDisabled,
    appendToContainer: _ctx.appendToContainer,
    getContainer: _ctx.getContainer,
    hideAfter: 0,
    offset: 4,
    onlyShowTrigger: ""
  }, {
    trigger: withCtx(() => [!_ctx.isRange ? (openBlock(), createBlock(_component_InputInner, {
      key: 0,
      class: normalizeClass([_ctx.attrs.class, _ctx.classes]),
      style: normalizeStyle(_ctx.attrs.style),
      modelValue: _ctx.displayValue,
      placeholder: _ctx.inputPlaceholder,
      disabled: _ctx.innerDisabled,
      clearable: _ctx.clearable,
      innerIsError: _ctx.isError,
      onClear: _ctx.clear,
      onInput: _ctx.handleInput,
      onFocus: _cache[0] || (_cache[0] = event => _ctx.$emit('focus', event)),
      onBlur: _ctx.handleBlur
    }, createSlots({
      _: 2
      /* DYNAMIC */

    }, [_ctx.showSuffix ? {
      name: "suffix",
      fn: withCtx(() => [createVNode(_component_ClockCircleOutlined)]),
      key: "0"
    } : undefined]), 1032
    /* PROPS, DYNAMIC_SLOTS */
    , ["class", "style", "modelValue", "placeholder", "disabled", "clearable", "innerIsError", "onClear", "onInput", "onBlur"])) : createCommentVNode("v-if", true)]),
    default: withCtx(() => [createElementVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-dropdown`),
      onMousedown: _cache[3] || (_cache[3] = withModifiers(() => {}, ["prevent"]))
    }, [createVNode(_component_TimeSelect, {
      visible: _ctx.isOpened,
      modelValue: _ctx.currentValue,
      format: _ctx.format,
      "hour-step": _ctx.hourStep,
      "minute-step": _ctx.minuteStep,
      "second-step": _ctx.secondStep,
      "disabled-hours": _ctx.disabledHours,
      "disabled-minutes": _ctx.disabledMinutes,
      "disabled-seconds": _ctx.disabledSeconds,
      onChange: _ctx.changeTime
    }, null, 8
    /* PROPS */
    , ["visible", "modelValue", "format", "hour-step", "minute-step", "second-step", "disabled-hours", "disabled-minutes", "disabled-seconds", "onChange"]), _ctx.showControl ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-addon`)
    }, [renderSlot(_ctx.$slots, "addon", {
      activeTime: _ctx.activeTime
    }, () => [createElementVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-addon-inner`)
    }, [createVNode(_component_FButton, {
      type: "link",
      size: "small",
      onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {}, ["prevent"])),
      onClick: _ctx.setCurrentTime
    }, {
      default: withCtx(() => [createTextVNode(toDisplayString(_ctx.t('timePicker.now')), 1
      /* TEXT */
      )]),
      _: 1
      /* STABLE */

    }, 8
    /* PROPS */
    , ["onClick"]), createVNode(_component_FButton, {
      type: "primary",
      size: "small",
      onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {}, ["prevent"])),
      onClick: _ctx.confirmChangeTime
    }, {
      default: withCtx(() => [createTextVNode(toDisplayString(_ctx.t('timePicker.confirm')), 1
      /* TEXT */
      )]),
      _: 1
      /* STABLE */

    }, 8
    /* PROPS */
    , ["onClick"])], 2
    /* CLASS */
    )])], 2
    /* CLASS */
    )) : createCommentVNode("v-if", true)], 34
    /* CLASS, HYDRATE_EVENTS */
    )]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["modelValue", "popperClass", "disabled", "appendToContainer", "getContainer"]);
}

script$f.render = render$d;
script$f.__file = "components/time-picker/time-picker.vue";

const FTimePicker = withInstall(script$f);

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || typeof value === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Now `isValid` doesn't throw an exception
 *   if the first argument is not an instance of Date.
 *   Instead, argument is converted beforehand using `toDate`.
 *
 *   Examples:
 *
 *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
 *   |---------------------------|---------------|---------------|
 *   | `new Date()`              | `true`        | `true`        |
 *   | `new Date('2016-01-01')`  | `true`        | `true`        |
 *   | `new Date('')`            | `false`       | `false`       |
 *   | `new Date(1488370835081)` | `true`        | `true`        |
 *   | `new Date(NaN)`           | `false`       | `false`       |
 *   | `'2016-01-01'`            | `TypeError`   | `false`       |
 *   | `''`                      | `TypeError`   | `false`       |
 *   | `1488370835081`           | `TypeError`   | `true`        |
 *   | `NaN`                     | `TypeError`   | `false`       |
 *
 *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
 *   that try to coerce arguments to the expected type
 *   (which is also the case with other *date-fns* functions).
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);

  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

/**
 * @name endOfMonth
 * @category Month Helpers
 * @summary Return the end of a month for the given date.
 *
 * @description
 * Return the end of a month for the given date.
 * The result will be in the local timezone.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the end of a month
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The end of a month for 2 September 2014 11:55:00:
 * const result = endOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 30 2014 23:59:59.999
 */

function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function (token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

var formatDistance$1 = formatDistance;

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO: Remove String()

    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};
var formatLong$1 = formatLong;

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function (token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

var formatRelative$1 = formatRelative;

function buildLocalizeFn(args) {
  return function (dirtyIndex, dirtyOptions) {
    var options = dirtyOptions || {};
    var context = options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function (dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function (quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};
var localize$1 = localize;

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function (value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function (index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};
var match$1 = match;

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */

var locale = {
  code: 'en-US',
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, dirtyOptions);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
// See issue: https://github.com/date-fns/date-fns/issues/376

function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? '-' : '';
  var output = Math.abs(number).toString();

  while (output.length < targetLength) {
    output = '0' + output;
  }

  return sign + output;
}

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* |                                |
 * |  d  | Day of month                   |  D  |                                |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  m  | Minute                         |  M  | Month                          |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  y  | Year (abs)                     |  Y  |                                |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 */

var formatters$2 = {
  // Year
  y: function (date, token) {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
  },
  // Month
  M: function (date, token) {
    var month = date.getUTCMonth();
    return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function (date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function (date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return dayPeriodEnumValue.toUpperCase();

      case 'aaa':
        return dayPeriodEnumValue;

      case 'aaaaa':
        return dayPeriodEnumValue[0];

      case 'aaaa':
      default:
        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
    }
  },
  // Hour [1-12]
  h: function (date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function (date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function (date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function (date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function (date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var formatters$3 = formatters$2;

var dayPeriodEnum = {
  am: 'am',
  pm: 'pm',
  midnight: 'midnight',
  noon: 'noon',
  morning: 'morning',
  afternoon: 'afternoon',
  evening: 'evening',
  night: 'night'
};
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
 * |  p! | Long localized time            |  P! | Long localized date            |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 * - `P` is long localized date format
 * - `p` is long localized time format
 */

var formatters = {
  // Era
  G: function (date, token, localize) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;

    switch (token) {
      // AD, BC
      case 'G':
      case 'GG':
      case 'GGG':
        return localize.era(era, {
          width: 'abbreviated'
        });
      // A, B

      case 'GGGGG':
        return localize.era(era, {
          width: 'narrow'
        });
      // Anno Domini, Before Christ

      case 'GGGG':
      default:
        return localize.era(era, {
          width: 'wide'
        });
    }
  },
  // Year
  y: function (date, token, localize) {
    // Ordinal number
    if (token === 'yo') {
      var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize.ordinalNumber(year, {
        unit: 'year'
      });
    }

    return formatters$3.y(date, token);
  },
  // Local week-numbering year
  Y: function (date, token, localize, options) {
    var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

    if (token === 'YY') {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    } // Ordinal number


    if (token === 'Yo') {
      return localize.ordinalNumber(weekYear, {
        unit: 'year'
      });
    } // Padding


    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function (date, token) {
    var isoWeekYear = getUTCISOWeekYear(date); // Padding

    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function (date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'Q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'QQ':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'Qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'QQQ':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'QQQQQ':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'formatting'
        });
      // 1st quarter, 2nd quarter, ...

      case 'QQQQ':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone quarter
  q: function (date, token, localize) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

    switch (token) {
      // 1, 2, 3, 4
      case 'q':
        return String(quarter);
      // 01, 02, 03, 04

      case 'qq':
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th

      case 'qo':
        return localize.ordinalNumber(quarter, {
          unit: 'quarter'
        });
      // Q1, Q2, Q3, Q4

      case 'qqq':
        return localize.quarter(quarter, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)

      case 'qqqqq':
        return localize.quarter(quarter, {
          width: 'narrow',
          context: 'standalone'
        });
      // 1st quarter, 2nd quarter, ...

      case 'qqqq':
      default:
        return localize.quarter(quarter, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Month
  M: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      case 'M':
      case 'MM':
        return formatters$3.M(date, token);
      // 1st, 2nd, ..., 12th

      case 'Mo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'MMM':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // J, F, ..., D

      case 'MMMMM':
        return localize.month(month, {
          width: 'narrow',
          context: 'formatting'
        });
      // January, February, ..., December

      case 'MMMM':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone month
  L: function (date, token, localize) {
    var month = date.getUTCMonth();

    switch (token) {
      // 1, 2, ..., 12
      case 'L':
        return String(month + 1);
      // 01, 02, ..., 12

      case 'LL':
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th

      case 'Lo':
        return localize.ordinalNumber(month + 1, {
          unit: 'month'
        });
      // Jan, Feb, ..., Dec

      case 'LLL':
        return localize.month(month, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // J, F, ..., D

      case 'LLLLL':
        return localize.month(month, {
          width: 'narrow',
          context: 'standalone'
        });
      // January, February, ..., December

      case 'LLLL':
      default:
        return localize.month(month, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // Local week of year
  w: function (date, token, localize, options) {
    var week = getUTCWeek(date, options);

    if (token === 'wo') {
      return localize.ordinalNumber(week, {
        unit: 'week'
      });
    }

    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function (date, token, localize) {
    var isoWeek = getUTCISOWeek(date);

    if (token === 'Io') {
      return localize.ordinalNumber(isoWeek, {
        unit: 'week'
      });
    }

    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function (date, token, localize) {
    if (token === 'do') {
      return localize.ordinalNumber(date.getUTCDate(), {
        unit: 'date'
      });
    }

    return formatters$3.d(date, token);
  },
  // Day of year
  D: function (date, token, localize) {
    var dayOfYear = getUTCDayOfYear(date);

    if (token === 'Do') {
      return localize.ordinalNumber(dayOfYear, {
        unit: 'dayOfYear'
      });
    }

    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();

    switch (token) {
      // Tue
      case 'E':
      case 'EE':
      case 'EEE':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'EEEEE':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'EEEEEE':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'EEEE':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Local day of week
  e: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case 'e':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'ee':
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th

      case 'eo':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'eee':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'eeeee':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'eeeeee':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'eeee':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Stand-alone local day of week
  c: function (date, token, localize, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

    switch (token) {
      // Numerical value (same as in `e`)
      case 'c':
        return String(localDayOfWeek);
      // Padded numerical value

      case 'cc':
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th

      case 'co':
        return localize.ordinalNumber(localDayOfWeek, {
          unit: 'day'
        });

      case 'ccc':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'standalone'
        });
      // T

      case 'ccccc':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'standalone'
        });
      // Tu

      case 'cccccc':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'standalone'
        });
      // Tuesday

      case 'cccc':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'standalone'
        });
    }
  },
  // ISO day of week
  i: function (date, token, localize) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

    switch (token) {
      // 2
      case 'i':
        return String(isoDayOfWeek);
      // 02

      case 'ii':
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd

      case 'io':
        return localize.ordinalNumber(isoDayOfWeek, {
          unit: 'day'
        });
      // Tue

      case 'iii':
        return localize.day(dayOfWeek, {
          width: 'abbreviated',
          context: 'formatting'
        });
      // T

      case 'iiiii':
        return localize.day(dayOfWeek, {
          width: 'narrow',
          context: 'formatting'
        });
      // Tu

      case 'iiiiii':
        return localize.day(dayOfWeek, {
          width: 'short',
          context: 'formatting'
        });
      // Tuesday

      case 'iiii':
      default:
        return localize.day(dayOfWeek, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM or PM
  a: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

    switch (token) {
      case 'a':
      case 'aa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'aaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'aaaaa':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'aaaa':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // AM, PM, midnight, noon
  b: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
    }

    switch (token) {
      case 'b':
      case 'bb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'bbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        }).toLowerCase();

      case 'bbbbb':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'bbbb':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function (date, token, localize) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;

    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }

    switch (token) {
      case 'B':
      case 'BB':
      case 'BBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'abbreviated',
          context: 'formatting'
        });

      case 'BBBBB':
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'narrow',
          context: 'formatting'
        });

      case 'BBBB':
      default:
        return localize.dayPeriod(dayPeriodEnumValue, {
          width: 'wide',
          context: 'formatting'
        });
    }
  },
  // Hour [1-12]
  h: function (date, token, localize) {
    if (token === 'ho') {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return formatters$3.h(date, token);
  },
  // Hour [0-23]
  H: function (date, token, localize) {
    if (token === 'Ho') {
      return localize.ordinalNumber(date.getUTCHours(), {
        unit: 'hour'
      });
    }

    return formatters$3.H(date, token);
  },
  // Hour [0-11]
  K: function (date, token, localize) {
    var hours = date.getUTCHours() % 12;

    if (token === 'Ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function (date, token, localize) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;

    if (token === 'ko') {
      return localize.ordinalNumber(hours, {
        unit: 'hour'
      });
    }

    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function (date, token, localize) {
    if (token === 'mo') {
      return localize.ordinalNumber(date.getUTCMinutes(), {
        unit: 'minute'
      });
    }

    return formatters$3.m(date, token);
  },
  // Second
  s: function (date, token, localize) {
    if (token === 'so') {
      return localize.ordinalNumber(date.getUTCSeconds(), {
        unit: 'second'
      });
    }

    return formatters$3.s(date, token);
  },
  // Fraction of second
  S: function (date, token) {
    return formatters$3.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    if (timezoneOffset === 0) {
      return 'Z';
    }

    switch (token) {
      // Hours and optional minutes
      case 'X':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`

      case 'XXXX':
      case 'XX':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`

      case 'XXXXX':
      case 'XXX': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Hours and optional minutes
      case 'x':
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`

      case 'xxxx':
      case 'xx':
        // Hours and minutes without `:` delimiter
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`

      case 'xxxxx':
      case 'xxx': // Hours and minutes with `:` delimiter

      default:
        return formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (GMT)
  O: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'O':
      case 'OO':
      case 'OOO':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'OOOO':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Timezone (specific non-location)
  z: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();

    switch (token) {
      // Short
      case 'z':
      case 'zz':
      case 'zzz':
        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
      // Long

      case 'zzzz':
      default:
        return 'GMT' + formatTimezone(timezoneOffset, ':');
    }
  },
  // Seconds timestamp
  t: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1000);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function (date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};

function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;

  if (minutes === 0) {
    return sign + String(hours);
  }

  var delimiter = dirtyDelimiter || '';
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}

function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? '-' : '+';
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }

  return formatTimezone(offset, dirtyDelimiter);
}

function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || '';
  var sign = offset > 0 ? '-' : '+';
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}

var formatters$1 = formatters;

function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
}

function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
}

function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
}

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
  }
}

// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
/**
 * @name format
 * @category Common Helpers
 * @summary Format the date.
 *
 * @description
 * Return the formatted date string in the given format. The result may vary by locale.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 * (see the last example)
 *
 * Format of the string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 7 below the table).
 *
 * Accepted patterns:
 * | Unit                            | Pattern | Result examples                   | Notes |
 * |---------------------------------|---------|-----------------------------------|-------|
 * | Era                             | G..GGG  | AD, BC                            |       |
 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 | GGGGG   | A, B                              |       |
 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
 * |                                 | yyyyy   | ...                               | 3,5   |
 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
 * |                                 | YYYYY   | ...                               | 3,5   |
 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
 * |                                 | RRRRR   | ...                               | 3,5,7 |
 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
 * |                                 | uuuuu   | ...                               | 3,5   |
 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | QQ      | 01, 02, 03, 04                    |       |
 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
 * |                                 | qq      | 01, 02, 03, 04                    |       |
 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | MM      | 01, 02, ..., 12                   |       |
 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 | MMMM    | January, February, ..., December  | 2     |
 * |                                 | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
 * |                                 | LL      | 01, 02, ..., 12                   |       |
 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 | LLLL    | January, February, ..., December  | 2     |
 * |                                 | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
 * |                                 | II      | 01, 02, ..., 53                   | 7     |
 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
 * |                                 | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 | DDDD    | ...                               | 3     |
 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | ee      | 02, 03, ..., 01                   |       |
 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
 * |                                 | cc      | 02, 03, ..., 01                   |       |
 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          | a..aa   | AM, PM                            |       |
 * |                                 | aaa     | am, pm                            |       |
 * |                                 | aaaa    | a.m., p.m.                        | 2     |
 * |                                 | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
 * |                                 | bbb     | am, pm, noon, midnight            |       |
 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          | m       | 0, 1, ..., 59                     |       |
 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | mm      | 00, 01, ..., 59                   |       |
 * | Second                          | s       | 0, 1, ..., 59                     |       |
 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
 * |                                 | ss      | 00, 01, ..., 59                   |       |
 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
 * |                                 | SS      | 00, 01, ..., 99                   |       |
 * |                                 | SSS     | 000, 001, ..., 999                |       |
 * |                                 | SSSS    | ...                               | 3     |
 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
 * |                                 | XX      | -0800, +0530, Z                   |       |
 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
 * |                                 | xx      | -0800, +0530, +0000               |       |
 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
 * | Seconds timestamp               | t       | 512969520                         | 7     |
 * |                                 | tt      | ...                               | 3,7   |
 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
 * |                                 | TT      | ...                               | 3,7   |
 * | Long localized date             | P       | 04/29/1453                        | 7     |
 * |                                 | PP      | Apr 29, 1453                      | 7     |
 * |                                 | PPP     | April 29th, 1453                  | 7     |
 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
 * | Long localized time             | p       | 12:00 AM                          | 7     |
 * |                                 | pp      | 12:00:00 AM                       | 7     |
 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
 *    the output will be the same as default pattern for this unit, usually
 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
 *    are marked with "2" in the last column of the table.
 *
 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
 *
 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
 *
 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
 *    The output will be padded with zeros to match the length of the pattern.
 *
 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
 *
 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 5. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` always returns the last two digits of a year,
 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
 *
 *    | Year | `yy` | `uu` |
 *    |------|------|------|
 *    | 1    |   01 |   01 |
 *    | 14   |   14 |   14 |
 *    | 376  |   76 |  376 |
 *    | 1453 |   53 | 1453 |
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
 *
 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
 *    so right now these tokens fall back to GMT timezones.
 *
 * 7. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `t`: seconds timestamp
 *    - `T`: milliseconds timestamp
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - The second argument is now required for the sake of explicitness.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   format(new Date(2016, 0, 1))
 *
 *   // v2.0.0 onward
 *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
 *   ```
 *
 * - New format string API for `format` function
 *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
 *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
 *
 * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
 *
 * @param {Date|Number} date - the original date
 * @param {String} format - the string of tokens
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {String} the formatted date string
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `date` must not be Invalid Date
 * @throws {RangeError} `options.locale` must contain `localize` property
 * @throws {RangeError} `options.locale` must contain `formatLong` property
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Represent 11 February 2014 in middle-endian format:
 * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
 * //=> '02/11/2014'
 *
 * @example
 * // Represent 2 July 2014 in Esperanto:
 * import { eoLocale } from 'date-fns/locale/eo'
 * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
 *   locale: eoLocale
 * })
 * //=> '2-a de julio 2014'
 *
 * @example
 * // Escape string by single quote characters:
 * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
 * //=> "3 o'clock"
 */

function format$1(dirtyDate, dirtyFormatStr, dirtyOptions) {
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var options = dirtyOptions || {};
  var locale = options.locale || defaultLocale;
  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (!locale.localize) {
    throw new RangeError('locale must contain localize property');
  }

  if (!locale.formatLong) {
    throw new RangeError('locale must contain formatLong property');
  }

  var originalDate = toDate(dirtyDate);

  if (!isValid(originalDate)) {
    throw new RangeError('Invalid time value');
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong, formatterOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp$1).map(function (substring) {
    // Replace two single quote characters with one single quote character
    if (substring === "''") {
      return "'";
    }

    var firstCharacter = substring[0];

    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }

    var formatter = formatters$1[firstCharacter];

    if (formatter) {
      if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }

      if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, dirtyDate);
      }

      return formatter(utcDate, substring, locale.localize, formatterOptions);
    }

    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
    }

    return substring;
  }).join('');
  return result;
}

function cleanEscapedString$1(input) {
  return input.match(escapedStringRegExp$1)[1].replace(doubleQuoteRegExp$1, "'");
}

function assign(target, dirtyObject) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }

  dirtyObject = dirtyObject || {};

  for (var property in dirtyObject) {
    if (Object.prototype.hasOwnProperty.call(dirtyObject, property)) {
      target[property] = dirtyObject[property];
    }
  }

  return target;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCDay(dirtyDate, dirtyDay, dirtyOptions) {
  requiredArgs(2, arguments);
  var options = dirtyOptions || {};
  var locale = options.locale;
  var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// See issue: https://github.com/date-fns/date-fns/issues/376

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var MILLISECONDS_IN_SECOND = 1000;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function parseNumericPattern(pattern, string, valueCallback) {
  var matchResult = string.match(pattern);

  if (!matchResult) {
    return null;
  }

  var value = parseInt(matchResult[0], 10);
  return {
    value: valueCallback ? valueCallback(value) : value,
    rest: string.slice(matchResult[0].length)
  };
}

function parseTimezonePattern(pattern, string) {
  var matchResult = string.match(pattern);

  if (!matchResult) {
    return null;
  } // Input is 'Z'


  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: string.slice(1)
    };
  }

  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * MILLISECONDS_IN_SECOND),
    rest: string.slice(matchResult[0].length)
  };
}

function parseAnyDigitsSigned(string, valueCallback) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, string, valueCallback);
}

function parseNDigits(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, string, valueCallback);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, string, valueCallback);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, string, valueCallback);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, string, valueCallback);

    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), string, valueCallback);
  }
}

function parseNDigitsSigned(n, string, valueCallback) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, string, valueCallback);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, string, valueCallback);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, string, valueCallback);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, string, valueCallback);

    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), string, valueCallback);
  }
}

function dayPeriodEnumToHours(enumValue) {
  switch (enumValue) {
    case 'morning':
      return 4;

    case 'evening':
      return 17;

    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;

    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}

function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;

  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // User for validation

function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */


var parsers = {
  // Era
  G: {
    priority: 140,
    parse: function (string, token, match, _options) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(string, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(string, {
            width: 'wide'
          }) || match.era(string, {
            width: 'abbreviated'
          }) || match.era(string, {
            width: 'narrow'
          });
      }
    },
    set: function (date, flags, value, _options) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['R', 'u', 't', 'T']
  },
  // Year
  y: {
    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
    // |----------|-------|----|-------|-------|-------|
    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
    priority: 130,
    parse: function (string, token, match, _options) {
      var valueCallback = function (year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };

      switch (token) {
        case 'y':
          return parseNDigits(4, string, valueCallback);

        case 'yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });

        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function (_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function (date, flags, value, _options) {
      var currentYear = date.getUTCFullYear();

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  // Local week-numbering year
  Y: {
    priority: 130,
    parse: function (string, token, match, _options) {
      var valueCallback = function (year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };

      switch (token) {
        case 'Y':
          return parseNDigits(4, string, valueCallback);

        case 'Yo':
          return match.ordinalNumber(string, {
            unit: 'year',
            valueCallback: valueCallback
          });

        default:
          return parseNDigits(token.length, string, valueCallback);
      }
    },
    validate: function (_date, value, _options) {
      return value.isTwoDigitYear || value.year > 0;
    },
    set: function (date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  // ISO week-numbering year
  R: {
    priority: 130,
    parse: function (string, token, _match, _options) {
      if (token === 'R') {
        return parseNDigitsSigned(4, string);
      }

      return parseNDigitsSigned(token.length, string);
    },
    set: function (_date, _flags, value, _options) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    },
    incompatibleTokens: ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  // Extended year
  u: {
    priority: 130,
    parse: function (string, token, _match, _options) {
      if (token === 'u') {
        return parseNDigitsSigned(4, string);
      }

      return parseNDigitsSigned(token.length, string);
    },
    set: function (date, _flags, value, _options) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']
  },
  // Quarter
  Q: {
    priority: 120,
    parse: function (string, token, match, _options) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, string);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Stand-alone quarter
  q: {
    priority: 120,
    parse: function (string, token, match, _options) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, string);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(string, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 4;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Month
  M: {
    priority: 110,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return parseNDigits(2, string, valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Stand-alone month
  L: {
    priority: 110,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return parseNumericPattern(numericPatterns.month, string, valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return parseNDigits(2, string, valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return match.ordinalNumber(string, {
            unit: 'month',
            valueCallback: valueCallback
          });
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Local week of year
  w: {
    priority: 100,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, string);

        case 'wo':
          return match.ordinalNumber(string, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function (date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']
  },
  // ISO week of year
  I: {
    priority: 100,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, string);

        case 'Io':
          return match.ordinalNumber(string, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 53;
    },
    set: function (date, _flags, value, options) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value, options), options);
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']
  },
  // Day of the month
  d: {
    priority: 90,
    subPriority: 1,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, string);

        case 'do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();

      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']
  },
  // Day of year
  D: {
    priority: 90,
    subPriority: 1,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, string);

        case 'Do':
          return match.ordinalNumber(string, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (date, value, _options) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);

      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']
  },
  // Day of week
  E: {
    priority: 90,
    parse: function (string, token, match, _options) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['D', 'i', 'e', 'c', 't', 'T']
  },
  // Local day of week
  e: {
    priority: 90,
    parse: function (string, token, match, options) {
      var valueCallback = function (value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return parseNDigits(token.length, string, valueCallback);
        // 3rd

        case 'eo':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        // Tue

        case 'eee':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(string, {
            width: 'short',
            context: 'formatting'
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']
  },
  // Stand-alone local day of week
  c: {
    priority: 90,
    parse: function (string, token, match, options) {
      var valueCallback = function (value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return parseNDigits(token.length, string, valueCallback);
        // 3rd

        case 'co':
          return match.ordinalNumber(string, {
            unit: 'day',
            valueCallback: valueCallback
          });
        // Tue

        case 'ccc':
          return match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(string, {
            width: 'short',
            context: 'standalone'
          }) || match.day(string, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 6;
    },
    set: function (date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']
  },
  // ISO day of week
  i: {
    priority: 90,
    parse: function (string, token, match, _options) {
      var valueCallback = function (value) {
        if (value === 0) {
          return 7;
        }

        return value;
      };

      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, string);
        // 2nd

        case 'io':
          return match.ordinalNumber(string, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // T

        case 'iiiii':
          return match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // Tu

        case 'iiiiii':
          return match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
        // Tuesday

        case 'iiii':
        default:
          return match.day(string, {
            width: 'wide',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'abbreviated',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'short',
            context: 'formatting',
            valueCallback: valueCallback
          }) || match.day(string, {
            width: 'narrow',
            context: 'formatting',
            valueCallback: valueCallback
          });
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 7;
    },
    set: function (date, _flags, value, options) {
      date = setUTCISODay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']
  },
  // AM or PM
  a: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaaa':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['b', 'B', 'H', 'k', 't', 'T']
  },
  // AM, PM, midnight
  b: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbbb':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'B', 'H', 'k', 't', 'T']
  },
  // in the morning, in the afternoon, in the evening, at night
  B: {
    priority: 80,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBBB':
          return match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return match.dayPeriod(string, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(string, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 't', 'T']
  },
  // Hour [1-12]
  h: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, string);

        case 'ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 12;
    },
    set: function (date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    },
    incompatibleTokens: ['H', 'K', 'k', 't', 'T']
  },
  // Hour [0-23]
  H: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, string);

        case 'Ho':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 23;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'K', 'k', 't', 'T']
  },
  // Hour [0-11]
  K: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, string);

        case 'Ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 11;
    },
    set: function (date, _flags, value, _options) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    },
    incompatibleTokens: ['h', 'H', 'k', 't', 'T']
  },
  // Hour [1-24]
  k: {
    priority: 70,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, string);

        case 'ko':
          return match.ordinalNumber(string, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 1 && value <= 24;
    },
    set: function (date, _flags, value, _options) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    },
    incompatibleTokens: ['a', 'b', 'h', 'H', 'K', 't', 'T']
  },
  // Minute
  m: {
    priority: 60,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, string);

        case 'mo':
          return match.ordinalNumber(string, {
            unit: 'minute'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Second
  s: {
    priority: 50,
    parse: function (string, token, match, _options) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, string);

        case 'so':
          return match.ordinalNumber(string, {
            unit: 'second'
          });

        default:
          return parseNDigits(token.length, string);
      }
    },
    validate: function (_date, value, _options) {
      return value >= 0 && value <= 59;
    },
    set: function (date, _flags, value, _options) {
      date.setUTCSeconds(value, 0);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Fraction of second
  S: {
    priority: 30,
    parse: function (string, token, _match, _options) {
      var valueCallback = function (value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };

      return parseNDigits(token.length, string, valueCallback);
    },
    set: function (date, _flags, value, _options) {
      date.setUTCMilliseconds(value);
      return date;
    },
    incompatibleTokens: ['t', 'T']
  },
  // Timezone (ISO-8601. +00:00 is `'Z'`)
  X: {
    priority: 10,
    parse: function (string, token, _match, _options) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, string);

        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function (date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'x']
  },
  // Timezone (ISO-8601)
  x: {
    priority: 10,
    parse: function (string, token, _match, _options) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, string);

        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, string);

        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, string);

        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, string);

        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, string);
      }
    },
    set: function (date, flags, value, _options) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    },
    incompatibleTokens: ['t', 'T', 'X']
  },
  // Seconds timestamp
  t: {
    priority: 40,
    parse: function (string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function (_date, _flags, value, _options) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  },
  // Milliseconds timestamp
  T: {
    priority: 20,
    parse: function (string, _token, _match, _options) {
      return parseAnyDigitsSigned(string);
    },
    set: function (_date, _flags, value, _options) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    },
    incompatibleTokens: '*'
  }
};
var parsers$1 = parsers;

var TIMEZONE_UNIT_PRIORITY = 10; // This RegExp consists of three parts separated by `|`:
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://git.io/fxCyr
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * ### v2.0.0 breaking changes:
 *
 * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
 *
 * - Old `parse` was renamed to `toDate`.
 *   Now `parse` is a new function which parses a string using a provided format.
 *
 *   ```javascript
 *   // Before v2.0.0
 *   parse('2016-01-01')
 *
 *   // v2.0.0 onward (toDate no longer accepts a string)
 *   toDate(1392098430000) // Unix to timestamp
 *   toDate(new Date(2014, 1, 11, 11, 30, 30)) // Cloning the date
 *   parse('2016-01-01', 'yyyy-MM-dd', new Date())
 *   ```
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://git.io/fxCyr
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://git.io/fxCyr
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, dirtyOptions) {
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var options = dirtyOptions || {};
  var locale = options.locale || defaultLocale;

  if (!locale.match) {
    throw new RangeError('locale must contain match property');
  }

  var localeFirstWeekContainsDate = locale.options && locale.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var localeWeekStartsOn = locale.options && locale.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale
  }; // If timezone isn't specified, it will be set to the system timezone

  var setters = [{
    priority: TIMEZONE_UNIT_PRIORITY,
    subPriority: -1,
    set: dateToSystemTimezone,
    index: 0
  }];
  var i;
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter === 'p' || firstCharacter === 'P') {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale.formatLong, subFnOptions);
    }

    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];

  for (i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }

    if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      throwProtectedError(token, formatString, dirtyDateString);
    }

    var firstCharacter = token[0];
    var parser = parsers$1[firstCharacter];

    if (parser) {
      var incompatibleTokens = parser.incompatibleTokens;

      if (Array.isArray(incompatibleTokens)) {
        var incompatibleToken = void 0;

        for (var _i = 0; _i < usedTokens.length; _i++) {
          var usedToken = usedTokens[_i].token;

          if (incompatibleTokens.indexOf(usedToken) !== -1 || usedToken === firstCharacter) {
            incompatibleToken = usedTokens[_i];
            break;
          }
        }

        if (incompatibleToken) {
          throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
        }
      } else if (parser.incompatibleTokens === '*' && usedTokens.length) {
        throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
      }

      usedTokens.push({
        token: firstCharacter,
        fullToken: token
      });
      var parseResult = parser.parse(dateString, token, locale.match, subFnOptions);

      if (!parseResult) {
        return new Date(NaN);
      }

      setters.push({
        priority: parser.priority,
        subPriority: parser.subPriority || 0,
        set: parser.set,
        validate: parser.validate,
        value: parseResult.value,
        index: setters.length
      });
      dateString = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      } // Replace two single quote characters with one single quote character


      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      } // Cut token from string, or, if string doesn't match the token, return Invalid Date


      if (dateString.indexOf(token) === 0) {
        dateString = dateString.slice(token.length);
      } else {
        return new Date(NaN);
      }
    }
  } // Check if the remaining input contains something other than whitespace


  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);

  if (isNaN(date)) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/37


  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};

  for (i = 0; i < uniquePrioritySetters.length; i++) {
    var setter = uniquePrioritySetters[i];

    if (setter.validate && !setter.validate(utcDate, setter.value, subFnOptions)) {
      return new Date(NaN);
    }

    var result = setter.set(utcDate, flags, setter.value, subFnOptions); // Result is tuple (date, flags)

    if (result[0]) {
      utcDate = result[0];
      assign(flags, result[1]); // Result is date
    } else {
      utcDate = result;
    }
  }

  return utcDate;
}

function dateToSystemTimezone(date, flags) {
  if (flags.timestampIsSet) {
    return date;
  }

  var convertedDate = new Date(0);
  convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
  convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
  return convertedDate;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

const RANGE_POSITION = {
  LEFT: 'left',
  RIGHT: 'right'
};
let SELECTED_STATUS;

(function (SELECTED_STATUS) {
  SELECTED_STATUS[SELECTED_STATUS["EMPTY"] = 0] = "EMPTY";
  SELECTED_STATUS[SELECTED_STATUS["ONE"] = 1] = "ONE";
  SELECTED_STATUS[SELECTED_STATUS["TWO"] = 2] = "TWO";
})(SELECTED_STATUS || (SELECTED_STATUS = {}));

const YEAR_COUNT = 16;
const COMMON_PROPS = {
  modelValue: {
    type: [Array, Number]
  },
  format: String,
  type: {
    type: String,
    default: 'date'
  },
  minDate: {
    type: Date
  },
  maxDate: {
    type: Date
  },
  disabledDate: {
    type: Function,
    default: () => false
  },
  disabledTime: {
    type: Function,
    default: () => false
  },
  hourStep: Number,
  minuteStep: Number,
  secondStep: Number,
  defaultTime: [String, Array]
};
const RANGE_PROPS = {
  maxRange: {
    // 7D 1M 2Y
    type: String
  }
};

function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$h(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$h(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
// TODO 
function strictParse(string, pattern, backup) {
  const result = parse(string, pattern, backup);
  if (!isValid(result)) return result;else if (format$1(result, pattern) === string) return result;else return new Date(NaN);
}
const isEmptyValue$1 = val => {
  if (!val) return true;

  if (Array.isArray(val)) {
    return val.length === 0;
  }

  return false;
}; // FEATURE  date-fns 

function timeFormat(date) {
  let format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'yyyy-MM-dd';
  if (!date) return null;

  if (isNumber(date)) {
    date = new Date(date);
  }

  const year = date.getFullYear();
  const month = date.getMonth();
  const day = date.getDate();
  const hours24 = date.getHours();
  const hours = hours24 % 12 === 0 ? 12 : hours24 % 12;
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();

  const dd = t => `0${t}`.slice(-2);

  const map = {
    yyyy: year,
    MM: dd(month + 1),
    MMMM: `${month + 1}`,
    M: month + 1,
    dd: dd(day),
    d: day,
    HH: dd(hours24),
    H: hours24,
    hh: dd(hours),
    h: hours,
    mm: dd(minutes),
    m: minutes,
    ss: dd(seconds),
    s: seconds,
    S: milliseconds,
    Q: `Q${Math.floor(month / 3) + 1}`
  };
  return format.replace(/y+|M+|d+|H+|h+|m+|s+|S+|Q/g, str => String(map[str]));
}
const contrastDate = function (date1, date2) {
  let format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'yyyy-MM-dd HH:mm:ss';
  const t1 = timeFormat(date1, format);
  const t2 = timeFormat(date2, format);
  if (t1 > t2) return 1;
  if (t1 === t2) return 0;
  return -1;
};
const parseDate = date => {
  const vDate = new Date(date || Date.now());
  return {
    year: vDate.getFullYear(),
    month: vDate.getMonth(),
    day: vDate.getDate(),
    hour: vDate.getHours(),
    minute: vDate.getMinutes(),
    second: vDate.getSeconds()
  };
};
const pickTime = dateObj => {
  return {
    hour: dateObj.hour,
    minute: dateObj.minute,
    second: dateObj.second
  };
};
function dateObjToDate(date) {
  var _date$month, _date$day2, _date$hour2, _date$minute2, _date$second2;

  let isFullMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!date) return null; // 

  const month = (_date$month = date.month) !== null && _date$month !== void 0 ? _date$month : date.quarter ? (date.quarter - 1) * 3 : null;

  if (isFullMax) {
    var _date$month2, _date$day, _date$hour, _date$minute, _date$second;

    const month = (_date$month2 = date.month) !== null && _date$month2 !== void 0 ? _date$month2 : 11;
    const maxDay = new Date(date.year, month + 1, 0).getDate();
    return new Date(date.year, month !== null && month !== void 0 ? month : 11, (_date$day = date.day) !== null && _date$day !== void 0 ? _date$day : maxDay, (_date$hour = date.hour) !== null && _date$hour !== void 0 ? _date$hour : 23, (_date$minute = date.minute) !== null && _date$minute !== void 0 ? _date$minute : 59, (_date$second = date.second) !== null && _date$second !== void 0 ? _date$second : 59, 999);
  }

  return new Date(date.year, month !== null && month !== void 0 ? month : 0, (_date$day2 = date.day) !== null && _date$day2 !== void 0 ? _date$day2 : 1, (_date$hour2 = date.hour) !== null && _date$hour2 !== void 0 ? _date$hour2 : 0, (_date$minute2 = date.minute) !== null && _date$minute2 !== void 0 ? _date$minute2 : 0, (_date$second2 = date.second) !== null && _date$second2 !== void 0 ? _date$second2 : 0, 0);
}
function transformDateToTimestamp(date) {
  let isFullMax = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!date) return null;
  return dateObjToDate(date, isFullMax).getTime();
}
const getTimestampFromFormat = (date, format, isFullMax) => {
  date = date || new Date();
  const dateObj = {
    year: date.getFullYear()
  };

  if (/M/.test(format)) {
    dateObj.month = date.getMonth();
  }

  if (/d/.test(format)) {
    dateObj.day = date.getDate();
  }

  if (/H/.test(format)) {
    dateObj.hour = date.getHours();
  }

  if (/m/.test(format)) {
    dateObj.minute = date.getMinutes();
  }

  if (/s/.test(format)) {
    dateObj.second = date.getSeconds();
  }

  if (/Q/.test(format)) {
    dateObj.quarter = Math.floor(date.getMonth() / 3) + 1;
  }

  return transformDateToTimestamp(dateObj, isFullMax);
};
const transformTimeToDate = timeStr => {
  if (!/^\d{1,2}:\d{1,2}:\d{1,2}$/.test(timeStr)) {
    console.warn(`[fes-date-picker] defaultTime format expect: HH:mm:ssnow is ${timeStr}`);
    timeStr = '00:00:00';
  }

  const times = timeStr.split(':');
  return {
    hour: Number(times[0]),
    minute: Number(times[1]),
    second: Number(times[2])
  };
};
const fillDate = _ref => {
  let {
    dateObj,
    format,
    defaultTime,
    rangePosition
  } = _ref;

  const newDateObj = _objectSpread$h({}, dateObj); // FEATURE 


  if (!/d/.test(format)) {
    if (rangePosition === RANGE_POSITION.LEFT) {
      newDateObj.day = 1;
    } else {
      const date = dateObjToDate(dateObj);
      newDateObj.day = endOfMonth(date).getDate();
    }
  }

  return _objectSpread$h(_objectSpread$h({}, newDateObj), getDefaultTime(defaultTime, rangePosition));
};
const getDefaultTime = (defaultTime, rangePosition, hasTime) => {
  const time = {};

  if (typeof defaultTime === 'string') {
    Object.assign(time, transformTimeToDate(defaultTime));
  } else if (Array.isArray(defaultTime)) {
    if (rangePosition === RANGE_POSITION.LEFT) {
      Object.assign(time, transformTimeToDate(defaultTime[0]));
    } else {
      Object.assign(time, transformTimeToDate(defaultTime[1]));
    }
  } else if (!rangePosition && hasTime) {
    const date = new Date();
    time.hour = date.getHours();
    time.minute = date.getMinutes();
    time.second = date.getSeconds();
  } else if (rangePosition === RANGE_POSITION.RIGHT) {
    time.hour = 23;
    time.minute = 59;
    time.second = 59;
  } else {
    time.hour = 0;
    time.minute = 0;
    time.second = 0;
  }

  return time;
};
const isBeyondRangeTime = option => {
  if (!option.flagDate || !option.maxRange) return false; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

  const arr = option.maxRange.match(/(\d*)([MDY])/);
  const length = Number(arr[1]);
  const type = arr[2];
  let minDate;
  let maxDate;

  if (type === 'D') {
    // FEATURE:  unicode token (https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table) d
    minDate = new Date(option.flagDate);
    maxDate = new Date(option.flagDate);
    minDate.setDate(minDate.getDate() - length + 1);
    maxDate.setDate(maxDate.getDate() + length - 1);
  } else if (type === 'M') {
    // DEPRECATED  M  Y 
    minDate = new Date(option.flagDate);
    maxDate = new Date(option.flagDate);
    minDate.setMonth(minDate.getMonth() - length, maxDate.getDate() + 1);
    maxDate.setMonth(maxDate.getMonth() + length, maxDate.getDate() - 1);
  } else if (type === 'Y') {
    // FEATURE:  unicode token  y
    minDate = new Date(option.flagDate.getFullYear() + length, 0);
    maxDate = new Date(option.flagDate.getFullYear() - length, 0);
  }

  if (!(minDate || maxDate)) {
    return false;
  }

  return contrastDate(option.currentDate, minDate, option.format) === -1 || contrastDate(option.currentDate, maxDate, option.format) === 1;
};

const PickerType = {
  date: 'date',
  datetime: 'datetime',
  datemultiple: 'datemultiple',
  daterange: 'daterange',
  datetimerange: 'datetimerange',
  datemonthrange: 'datemonthrange',
  year: 'year',
  month: 'month',
  quarter: 'quarter'
};
class DatePicker {
  constructor() {
    _defineProperty(this, "name", PickerType.date);

    _defineProperty(this, "confirmLang", 'datePicker.now');

    _defineProperty(this, "placeholderLang", 'datePicker.selectDate');

    _defineProperty(this, "format", 'yyyy-MM-dd');

    _defineProperty(this, "isRange", false);

    _defineProperty(this, "hasTime", false);
  }

  getDateFromStr(val) {
    return new Date(val);
  }

}
class DateMultiplePicker {
  constructor() {
    _defineProperty(this, "name", PickerType.datemultiple);

    _defineProperty(this, "confirmLang", '');

    _defineProperty(this, "placeholderLang", 'datePicker.selectDate');

    _defineProperty(this, "format", 'yyyy-MM-dd');

    _defineProperty(this, "isRange", false);

    _defineProperty(this, "hasTime", false);
  }

  getDateFromStr(val) {
    return new Date(val);
  }

}
class DateTimePicker {
  constructor() {
    _defineProperty(this, "name", PickerType.datetime);

    _defineProperty(this, "confirmLang", 'datePicker.today');

    _defineProperty(this, "placeholderLang", 'datePicker.selectDateTime');

    _defineProperty(this, "format", 'yyyy-MM-dd HH:mm:ss');

    _defineProperty(this, "isRange", false);

    _defineProperty(this, "hasTime", true);
  }

  getDateFromStr(val) {
    return new Date(val);
  }

}

class DateRange {
  getLeftActiveDate(rightActiveDate) {
    const endDate = new Date(rightActiveDate);
    return endDate.setMonth(endDate.getMonth() - 1, 1);
  }

  getRightActiveDate(leftActiveDate) {
    const endDate = new Date(leftActiveDate);
    return endDate.setMonth(endDate.getMonth() + 1, 1);
  }

  isInSamePanel(left, right) {
    const leftDate = parseDate(left);
    const rightDate = parseDate(right);
    return leftDate.year === rightDate.year && leftDate.month === rightDate.month;
  }

  getRangeSelectedDate(date, preDate) {
    return Object.assign(date, pickTime(preDate));
  }

}

class DateRangePicker extends DateRange {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", PickerType.daterange);

    _defineProperty(this, "confirmLang", '');

    _defineProperty(this, "placeholderLang", ['datePicker.selectStartDate', 'datePicker.selectEndDate']);

    _defineProperty(this, "format", 'yyyy-MM-dd');

    _defineProperty(this, "isRange", true);

    _defineProperty(this, "hasTime", false);
  }

  getDateFromStr(val) {
    return new Date(val);
  }

}
class DateTimeRangePicker extends DateRange {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", PickerType.datetimerange);

    _defineProperty(this, "confirmLang", '');

    _defineProperty(this, "placeholderLang", ['datePicker.selectStartDateTime', 'datePicker.selectEndDateTime']);

    _defineProperty(this, "format", 'yyyy-MM-dd HH:mm:ss');

    _defineProperty(this, "isRange", true);

    _defineProperty(this, "hasTime", true);
  }

  getDateFromStr(val) {
    return new Date(val);
  }

}
class DateMonthRangePicker {
  constructor() {
    _defineProperty(this, "name", PickerType.datemonthrange);

    _defineProperty(this, "confirmLang", '');

    _defineProperty(this, "placeholderLang", ['datePicker.selectStartDateMonth', 'datePicker.selectEndDateMonth']);

    _defineProperty(this, "format", 'yyyy-MM');

    _defineProperty(this, "isRange", true);

    _defineProperty(this, "hasTime", false);
  }

  getDateFromStr(val) {
    return new Date(val);
  }

  getLeftActiveDate(rightActiveDate) {
    const endDate = new Date(rightActiveDate);
    return endDate.setFullYear(endDate.getFullYear() - 1, 0, 1);
  }

  getRightActiveDate(leftActiveDate) {
    const endDate = new Date(leftActiveDate);
    return endDate.setFullYear(endDate.getFullYear() + 1, 0, 1);
  }

  isInSamePanel(left, right) {
    const leftDate = parseDate(left);
    const rightDate = parseDate(right);
    return leftDate.year === rightDate.year;
  }

  getRangeSelectedDate(date, preDate) {
    return Object.assign(date, {
      day: preDate.day
    }, pickTime(preDate));
  }

}
class YearPicker {
  constructor() {
    _defineProperty(this, "name", PickerType.year);

    _defineProperty(this, "confirmLang", 'datePicker.currentYear');

    _defineProperty(this, "placeholderLang", 'datePicker.selectYear');

    _defineProperty(this, "format", 'yyyy');

    _defineProperty(this, "isRange", false);

    _defineProperty(this, "hasTime", false);
  }

  getDateFromStr(val) {
    return new Date(val);
  }

}
class MonthPicker {
  constructor() {
    _defineProperty(this, "name", PickerType.month);

    _defineProperty(this, "confirmLang", 'datePicker.currentMonth');

    _defineProperty(this, "placeholderLang", 'datePicker.selectMonth');

    _defineProperty(this, "format", 'yyyy-MM');

    _defineProperty(this, "isRange", false);

    _defineProperty(this, "hasTime", false);
  }

  getDateFromStr(val) {
    return new Date(val);
  }

}
class QuarterPicker {
  constructor() {
    _defineProperty(this, "name", PickerType.quarter);

    _defineProperty(this, "confirmLang", 'datePicker.currentQuarter');

    _defineProperty(this, "placeholderLang", 'datePicker.selectQuarter');

    _defineProperty(this, "format", 'yyyy-QQQ');

    _defineProperty(this, "isRange", false);

    _defineProperty(this, "hasTime", false);
  }

  getDateFromStr(val) {
    const [year, quarter] = val.match(/\d+/g);
    return new Date(Number(year), (Number(quarter) - 1) * 3);
  }

}
function pickerFactory(type) {
  switch (type) {
    case PickerType.date:
      return new DatePicker();

    case PickerType.datetime:
      return new DateTimePicker();

    case PickerType.datemultiple:
      return new DateMultiplePicker();

    case PickerType.daterange:
      return new DateRangePicker();

    case PickerType.datetimerange:
      return new DateTimeRangePicker();

    case PickerType.datemonthrange:
      return new DateMonthRangePicker();

    case PickerType.year:
      return new YearPicker();

    case PickerType.month:
      return new MonthPicker();

    case PickerType.quarter:
      return new QuarterPicker();

    default:
      return new DatePicker();
  }
}

function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$g(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$g(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$u = getPrefixCls('calendar');
const WEEK_NAMES = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
const useCurrentDate = (props, emit) => {
  const currentDate = reactive(parseDate(props.activeDate));
  const [innerActiveDate, updateActiveDate] = useNormalModel(props, emit, {
    prop: 'activeDate'
  });

  const updateCurrentDate = date => {
    Object.assign(currentDate, date);
    updateActiveDate(transformDateToTimestamp(currentDate));
  };

  watch(innerActiveDate, () => {
    Object.assign(currentDate, parseDate(innerActiveDate.value));
  });
  watch(() => props.modelValue, () => {
    var _props$modelValue;

    if (((_props$modelValue = props.modelValue) === null || _props$modelValue === void 0 ? void 0 : _props$modelValue.length) === 1 && !props.rangePosition) {
      updateCurrentDate(parseDate(props.modelValue[0]));
    }
  });
  return {
    currentDate,
    updateCurrentDate
  };
};
const useSelectedDates = (props, emit, picker) => {
  const selectedDates = ref([]);

  const updateRangeSelectedDates = (date, index) => {
    if (index === 0 && transformDateToTimestamp(date) > transformDateToTimestamp(selectedDates.value[1]) || index === 1 && transformDateToTimestamp(date) < transformDateToTimestamp(selectedDates.value[0])) {
      selectedDates.value = [date, _objectSpread$g({}, date)];
    } else {
      selectedDates.value.splice(index, 1, date);
    }
  };

  const updateSelectedDates = function (date, index) {
    let option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const newDate = Object.assign({}, selectedDates.value[index], date);

    if (picker.value.isRange && (option.isTime || option.isDateInput) && props.selectedStatus === SELECTED_STATUS.TWO) {
      updateRangeSelectedDates(newDate, index);
    } else if (picker.value.isRange && (!selectedDates.value.length || props.selectedStatus === SELECTED_STATUS.TWO)) {
      const anotherDate = fillDate({
        dateObj: newDate,
        format: picker.value.format,
        defaultTime: props.defaultTime,
        rangePosition: props.rangePosition === RANGE_POSITION.LEFT ? RANGE_POSITION.RIGHT : RANGE_POSITION.LEFT
      });

      if (props.rangePosition === RANGE_POSITION.LEFT) {
        selectedDates.value = [newDate, anotherDate];
      } else {
        selectedDates.value = [anotherDate, newDate];
      }

      emit('selectedDay');
    } else if (picker.value.name === PickerType.datemultiple) {
      const selectedDateIndex = selectedDates.value.findIndex(item => {
        return item.year === newDate.year && item.month === newDate.month && item.day === newDate.day;
      });

      if (selectedDateIndex !== -1) {
        selectedDates.value.splice(selectedDateIndex, 1);
      } else {
        selectedDates.value.push(newDate);
      }
    } else if (!picker.value.isRange) {
      selectedDates.value = [newDate];
    } else {
      // 
      if (transformDateToTimestamp(selectedDates.value[0]) > transformDateToTimestamp(newDate)) {
        selectedDates.value.splice(0, 1, picker.value.getRangeSelectedDate(newDate, selectedDates.value[0]));
      } else {
        selectedDates.value.splice(1, 1, picker.value.getRangeSelectedDate(newDate, selectedDates.value[1]));
      }

      emit('selectedDay');
    }

    if (picker.value.isRange) {
      emit('change', [transformDateToTimestamp(selectedDates.value[0]), transformDateToTimestamp(selectedDates.value[1], true)]);
    } else if (picker.value.name === PickerType.datemultiple) {
      emit('change', selectedDates.value.map(item => {
        return transformDateToTimestamp(item);
      }));
    } else {
      emit('change', [transformDateToTimestamp(selectedDates.value[0])]);
    }
  };

  watch(() => props.modelValue, () => {
    const dates = props.modelValue || [];
    selectedDates.value = dates.map(item => item ? parseDate(item) : null);
  }, {
    immediate: true
  });
  return {
    selectedDates,
    updateSelectedDates
  };
};
function useYear(_ref) {
  let {
    props,
    selectedDates,
    updateSelectedDates,
    activeIndex,
    currentDate,
    updateCurrentDate
  } = _ref;
  const isYearSelect = ref(false); // 

  watchEffect(() => {
    if (props.type === PickerType.year) {
      isYearSelect.value = true;
    }
  });

  const selectYear = year => {
    updateCurrentDate({
      year
    });
    updateSelectedDates({
      year
    }, activeIndex.value);
  };

  const yearStart = computed(() => currentDate.year - currentDate.year % YEAR_COUNT);
  const yearEnd = computed(() => yearStart.value + YEAR_COUNT);
  const years = computed(() => {
    const arr = [];
    let start = yearStart.value;

    while (arr.length < 16) {
      arr.push(start++);
    }

    return arr;
  });

  const disabled = year => {
    const date = new Date(year, 0);
    return props.disabledDate && props.disabledDate(date, 'yyyy');
  };

  const isSelectedYear = year => {
    if (props.type === PickerType.year) {
      return !!selectedDates.value.find(item => (item === null || item === void 0 ? void 0 : item.year) === year);
    }

    return false;
  };

  const yearCls = year => [`${prefixCls$u}-date`, disabled(year) && `${prefixCls$u}-date-disabled`, isSelectedYear(year) && `${prefixCls$u}-date-selected`, year === new Date().getFullYear() && [`${prefixCls$u}-date-now`]];

  return {
    years,
    yearStart,
    yearEnd,
    selectYear,
    isYearSelect,
    yearCls
  };
}
function useCommonRange(_ref2) {
  let {
    props,
    selectedDates,
    picker
  } = _ref2;
  const startDate = computed(() => selectedDates.value[0] && new Date(transformDateToTimestamp(selectedDates.value[0])));
  const endDate = computed(() => selectedDates.value[1] && new Date(transformDateToTimestamp(selectedDates.value[1]))); // 

  const inRangeDate = (date, format) => {
    if (picker.value.isRange && startDate.value && endDate.value) {
      return contrastDate(date, startDate.value, format) === 1 && contrastDate(date, endDate.value, format) === -1;
    }

    return false;
  };

  const completeRangeSelected = computed(() => props.selectedStatus === SELECTED_STATUS.TWO);
  return {
    completeRangeSelected,
    inRangeDate
  };
}
function useMonth(_ref3) {
  let {
    props,
    selectedDates,
    updateSelectedDates,
    activeIndex,
    currentDate,
    updateCurrentDate,
    picker
  } = _ref3;
  // 
  const format = 'yyyy-MM';
  const isMonthSelect = computed(() => {
    return props.type === PickerType.month || props.type === PickerType.datemonthrange;
  });

  const selectMonth = month => {
    updateSelectedDates({
      year: currentDate.year,
      month,
      day: props.rangePosition === RANGE_POSITION.LEFT ? 1 : endOfMonth(new Date(currentDate.year, month, 1)).getDate()
    }, activeIndex.value);
  };

  const monthToNext = () => {
    if (currentDate.month < 11) {
      updateCurrentDate({
        year: currentDate.year,
        month: currentDate.month + 1
      });
    } else {
      updateCurrentDate({
        year: currentDate.year + 1,
        month: 0
      });
    }
  };

  const monthToPre = () => {
    if (currentDate.month > 0) {
      updateCurrentDate({
        year: currentDate.year,
        month: currentDate.month - 1
      });
    } else {
      updateCurrentDate({
        month: 11,
        year: currentDate.year - 1
      });
    }
  };

  const disabled = month => {
    const date = new Date(currentDate.year, month);
    return props.disabledDate && props.disabledDate(date, format);
  };

  const isSelectedMonth = month => {
    if (isMonthSelect.value) {
      return selectedDates.value.findIndex(item => item && item.year === currentDate.year && item.month === month);
    }

    return -1;
  };

  const {
    completeRangeSelected,
    inRangeDate
  } = useCommonRange({
    props,
    selectedDates,
    picker
  });

  const monthCls = month => {
    const selectedIndex = isSelectedMonth(month);
    const date = new Date(currentDate.year, month);
    return {
      [`${prefixCls$u}-date`]: true,
      [`${prefixCls$u}-date-disabled`]: disabled(month),
      [`${prefixCls$u}-date-selected`]: selectedIndex !== -1,
      'is-start': picker.value.isRange && completeRangeSelected.value && selectedIndex === 0,
      'is-end': picker.value.isRange && completeRangeSelected.value && selectedIndex === 1,
      [`${prefixCls$u}-date-now`]: timeFormat(new Date(currentDate.year, month), format) === timeFormat(new Date(), format),
      [`${prefixCls$u}-date-on`]: inRangeDate(date, format)
    };
  };

  return {
    isMonthSelect,
    selectMonth,
    monthToNext,
    monthToPre,
    monthCls
  };
}
function useDay(_ref4) {
  let {
    props,
    selectedDates,
    currentDate,
    picker
  } = _ref4;
  const {
    t
  } = useLocale(); // TODO  

  const weekFirstDay = ref(1); // 

  const weekNames = computed(() => {
    const weekFirstDayValue = weekFirstDay.value;
    return WEEK_NAMES.concat(WEEK_NAMES).slice(weekFirstDayValue, weekFirstDayValue + 7).map(_ => t(`datePicker.weeks.${_}`));
  });
  const isDaySelect = computed(() => [PickerType.date, PickerType.datetime, PickerType.daterange, PickerType.datetimerange, PickerType.datemultiple].some(type => props.type === type));
  const days = computed(() => {
    const daysTemp = [];
    const {
      year,
      month
    } = currentDate;
    const time = new Date(year, month, 1);
    const weekFirstDayValue = weekFirstDay.value;
    time.setDate(0); // switch to the last day of last month

    let lastDay = time.getDate();
    const week = time.getDay() || 7;
    let count = weekFirstDayValue <= week ? week - weekFirstDayValue + 1 : week + (7 - weekFirstDayValue + 1);

    while (count > 0 && count < 7) {
      daysTemp.push({
        day: lastDay - count + 1,
        year: month > 0 ? year : year - 1,
        month: month > 0 ? month - 1 : 11,
        pre: true
      });
      count--;
    }

    time.setMonth(time.getMonth() + 2, 0); // switch to the last day of the current month

    lastDay = time.getDate();
    let i = 1;

    for (i = 1; i <= lastDay; i++) {
      daysTemp.push({
        day: i,
        year,
        month
      });
    }

    for (i = 1; daysTemp.length < 42; i++) {
      daysTemp.push({
        day: i,
        year: month < 11 ? year : year + 1,
        month: month < 11 ? month + 1 : 0,
        next: true
      });
    }

    return daysTemp;
  });

  const isSelected = (selectedDate, dayItem) => dayItem.year === (selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.year) && dayItem.month === (selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.month) && dayItem.month === currentDate.month && dayItem.day === (selectedDate === null || selectedDate === void 0 ? void 0 : selectedDate.day);

  const findSelectedIndex = dayItem => selectedDates.value.findIndex(selectedDate => isSelected(selectedDate, dayItem));

  const {
    completeRangeSelected,
    inRangeDate
  } = useCommonRange({
    props,
    selectedDates,
    picker
  });

  const dayCls = item => {
    const format = 'yyyy-MM-dd';
    const {
      year,
      month
    } = item;
    const date = new Date(year, month, item.day);
    const selectedIndex = findSelectedIndex(item);
    return {
      [`${prefixCls$u}-date-out`]: item.pre || item.next,
      [`${prefixCls$u}-date`]: true,
      [`${prefixCls$u}-date-disabled`]: props.disabledDate && props.disabledDate(date, format),
      [`${prefixCls$u}-date-selected`]: selectedIndex !== -1,
      'is-start': picker.value.isRange && completeRangeSelected.value && selectedIndex === 0,
      'is-end': picker.value.isRange && completeRangeSelected.value && selectedIndex === 1,
      [`${prefixCls$u}-date-now`]: timeFormat(date, format) === timeFormat(new Date(), format),
      [`${prefixCls$u}-date-on`]: inRangeDate(date, format) && date.getMonth() === currentDate.month
    };
  };

  return {
    days,
    isDaySelect,
    weekNames,
    dayCls
  };
}
const useQuarter = (props, selectedDates, updateSelectedDates, activeIndex, currentDate) => {
  const isQuarterSelect = computed(() => props.type === PickerType.quarter);
  const quarterList = [{
    name: 'Q1',
    value: 1
  }, {
    name: 'Q2',
    value: 2
  }, {
    name: 'Q3',
    value: 3
  }, {
    name: 'Q4',
    value: 4
  }];

  const selectQuarter = item => {
    updateSelectedDates({
      year: currentDate.year,
      month: (item.value - 1) * 3
    }, activeIndex.value);
  };

  const isSelected = item => !!selectedDates.value.find(selectedDate => selectedDate && selectedDate.year === currentDate.year && item.value === selectedDate.month / 3 + 1);

  const isNow = item => {
    const now = parseDate();
    return now.year === currentDate.year && Math.floor(now.month / 3) + 1 === item.value;
  };

  const quarterCls = item => ({
    [`${prefixCls$u}-date`]: true,
    [`${prefixCls$u}-date-selected`]: isSelected(item),
    [`${prefixCls$u}-date-now`]: isNow(item)
  });

  return {
    isQuarterSelect,
    quarterList,
    selectQuarter,
    quarterCls
  };
};

const transformDateToTime = selectedDate => {
  if (!selectedDate) return '';
  const times = [];

  if (!isNil(selectedDate.hour)) {
    times.push(`${selectedDate.hour}`.padStart(2, '0'));
  }

  if (!isNil(selectedDate.minute)) {
    times.push(`${selectedDate.minute}`.padStart(2, '0'));
  }

  if (!isNil(selectedDate.second)) {
    times.push(`${selectedDate.second}`.padStart(2, '0'));
  }

  return times.join(':');
};

const useTime = _ref5 => {
  let {
    props,
    selectedDates,
    updateSelectedDates,
    activeIndex,
    picker
  } = _ref5;
  const currentTime = ref('');
  watch([selectedDates], () => {
    currentTime.value = transformDateToTime(selectedDates.value[activeIndex.value]);
  }, {
    immediate: true,
    deep: true
  });

  const changeTime = time => {
    if (time) {
      var _selectedDates$value$;

      const selectedDate = _objectSpread$g(_objectSpread$g({}, selectedDates.value[activeIndex.value]), transformTimeToDate(time));

      if (!((_selectedDates$value$ = selectedDates.value[activeIndex.value]) !== null && _selectedDates$value$ !== void 0 && _selectedDates$value$.year)) {
        const date = new Date();
        Object.assign(selectedDate, {
          year: date.getFullYear(),
          month: date.getMonth(),
          day: date.getDate()
        });
      }

      updateSelectedDates(selectedDate, activeIndex.value, {
        isTime: true
      });
    }
  };

  const innerDisabledTime = computed(() => {
    if (!props.disabledTime) return null;

    if (picker.value.isRange) {
      return props.disabledTime(new Date(transformDateToTimestamp(selectedDates.value[activeIndex.value])), props.rangePosition, selectedDates.value.map(val => {
        return new Date(transformDateToTimestamp(val));
      }));
    }

    return props.disabledTime(new Date(transformDateToTimestamp(selectedDates.value[0])));
  });
  return {
    currentTime,
    changeTime,
    innerDisabledTime
  };
};

function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$f(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$t = getPrefixCls('calendar');
const MONTHS_NAMES = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];

const calendarProps = _objectSpread$f(_objectSpread$f({}, COMMON_PROPS), {}, {
  rangePosition: {
    type: String
  },
  modelValue: Array,
  activeDate: Number,
  selectedStatus: Number,
  disabledDate: {
    type: Function
  }
});

function useDateInput(_ref) {
  let {
    props,
    selectedDates,
    updateSelectedDates,
    updateCurrentDate,
    picker
  } = _ref;
  const inputDate = ref();
  let cacheValidInputDate = '';
  const currentIndex = computed(() => {
    if (picker.value.isRange && props.rangePosition === RANGE_POSITION.RIGHT) {
      return 1;
    }

    return 0;
  });

  const getDateStr = i => {
    return selectedDates.value[i] ? format$1(transformDateToTimestamp(selectedDates.value[i]), 'yyyy-MM-dd') : '';
  };

  watch(selectedDates, () => {
    cacheValidInputDate = getDateStr(currentIndex.value);
    inputDate.value = cacheValidInputDate;
  }, {
    immediate: true
  });

  const handleDateInput = val => {
    var _props$disabledDate;

    inputDate.value = val;
    const date = strictParse(val, 'yyyy-MM-dd', new Date());
    const anotherDate = selectedDates.value[(currentIndex.value + 1) % 2];

    if (isValid(date) && !((_props$disabledDate = props.disabledDate) !== null && _props$disabledDate !== void 0 && _props$disabledDate.call(props, date, 'yyyy-MM-dd', anotherDate && new Date(transformDateToTimestamp(anotherDate))))) {
      const dateObj = parseDate(date);
      cacheValidInputDate = val; //  current date

      if (anotherDate && !(anotherDate.year === dateObj.year && anotherDate.month === dateObj.month)) {
        updateCurrentDate(dateObj);
      }

      updateSelectedDates(_objectSpread$f(_objectSpread$f({}, selectedDates.value[currentIndex.value]), {}, {
        year: dateObj.year,
        month: dateObj.month,
        day: dateObj.day
      }), currentIndex.value, {
        isDateInput: true
      });
    }
  };

  const handleDateInputBlur = () => {
    if (inputDate.value !== cacheValidInputDate) {
      inputDate.value = cacheValidInputDate;
    }
  };

  return {
    inputDate,
    handleDateInput,
    handleDateInputBlur
  };
}

var script$e = defineComponent({
  name: 'FCalendar',
  components: {
    LeftOutlined,
    RightOutlined,
    DoubleLeftOutlined,
    DoubleRightOutlined,
    InputInner: script$y,
    TimePicker: script$f
  },
  props: calendarProps,
  emits: ['change', 'selectedDay', 'update:activeDate'],

  setup(props, _ref2) {
    let {
      emit
    } = _ref2;
    const pickerRef = computed(() => {
      return pickerFactory(props.type);
    });
    const {
      currentDate,
      updateCurrentDate
    } = useCurrentDate(props, emit);
    const {
      selectedDates,
      updateSelectedDates
    } = useSelectedDates(props, emit, pickerRef);
    const {
      t
    } = useLocale();
    const activeIndex = computed(() => {
      if (pickerRef.value.isRange) {
        return props.rangePosition === RANGE_POSITION.LEFT ? 0 : 1;
      }

      return 0;
    });
    const {
      inputDate,
      handleDateInput,
      handleDateInputBlur
    } = useDateInput({
      props,
      selectedDates,
      updateSelectedDates,
      updateCurrentDate,
      picker: pickerRef
    });
    const {
      years,
      yearStart,
      yearEnd,
      selectYear,
      isYearSelect,
      yearCls
    } = useYear({
      props,
      selectedDates,
      updateSelectedDates,
      activeIndex,
      currentDate,
      updateCurrentDate
    });
    const {
      isMonthSelect,
      selectMonth,
      monthToNext,
      monthToPre,
      monthCls
    } = useMonth({
      props,
      selectedDates,
      updateSelectedDates,
      activeIndex,
      currentDate,
      updateCurrentDate,
      picker: pickerRef
    });
    const {
      days,
      isDaySelect,
      weekNames,
      dayCls
    } = useDay({
      props,
      selectedDates,
      currentDate,
      picker: pickerRef
    });
    const {
      isQuarterSelect,
      quarterList,
      selectQuarter,
      quarterCls
    } = useQuarter(props, selectedDates, updateSelectedDates, activeIndex, currentDate);
    const {
      currentTime,
      changeTime,
      innerDisabledTime
    } = useTime({
      props,
      selectedDates,
      updateSelectedDates,
      activeIndex,
      picker: pickerRef
    });

    const selectedDay = info => {
      var _selectedDates$value$;

      info.next && monthToNext();
      info.pre && monthToPre();
      let time;

      if (((_selectedDates$value$ = selectedDates.value[activeIndex.value]) === null || _selectedDates$value$ === void 0 ? void 0 : _selectedDates$value$.hour) == null) {
        time = getDefaultTime(props.defaultTime, props.rangePosition, pickerRef.value.hasTime);
      }

      updateSelectedDates(_objectSpread$f({
        year: info.year,
        month: info.month,
        day: info.day
      }, time), activeIndex.value);
    };

    const yearToPre = () => {
      if (isYearSelect.value) {
        updateCurrentDate({
          year: currentDate.year - YEAR_COUNT
        });
      } else {
        updateCurrentDate({
          year: currentDate.year - 1
        });
      }
    };

    const yearToNext = () => {
      if (isYearSelect.value) {
        updateCurrentDate({
          year: currentDate.year + YEAR_COUNT
        });
      } else {
        updateCurrentDate({
          year: currentDate.year + 1
        });
      }
    };

    const isNotDisabled = e => e.target.className.indexOf(`${prefixCls$t}-date-disabled`) === -1;

    const visibleLeftSingleArrow = computed(() => !isYearSelect.value && !isMonthSelect.value && !isQuarterSelect.value);
    const visibleRightSingleArrow = computed(() => !isYearSelect.value && !isMonthSelect.value && !isQuarterSelect.value);
    return {
      prefixCls: prefixCls$t,
      pickerRef,
      currentDate,
      MONTHS_NAMES,
      inputDate,
      handleDateInput,
      handleDateInputBlur,
      years,
      yearStart,
      yearEnd,
      selectYear,
      isYearSelect,
      yearCls,
      isMonthSelect,
      selectMonth,
      monthCls,
      weekNames,
      isDaySelect,
      days,
      isQuarterSelect,
      quarterList,
      selectQuarter,
      quarterCls,
      dayCls,
      monthToNext,
      monthToPre,
      isNotDisabled,
      selectedDay,
      currentTime,
      changeTime,
      innerDisabledTime,
      yearToPre,
      yearToNext,
      t,
      visibleLeftSingleArrow,
      visibleRightSingleArrow
    };
  }

});

const _hoisted_1$6 = ["onClick"];
const _hoisted_2$4 = ["onClick"];
const _hoisted_3$3 = ["onClick"];
const _hoisted_4 = ["onClick"];
function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_InputInner = resolveComponent("InputInner");

  const _component_TimePicker = resolveComponent("TimePicker");

  const _component_DoubleLeftOutlined = resolveComponent("DoubleLeftOutlined");

  const _component_LeftOutlined = resolveComponent("LeftOutlined");

  const _component_RightOutlined = resolveComponent("RightOutlined");

  const _component_DoubleRightOutlined = resolveComponent("DoubleRightOutlined");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [_ctx.pickerRef.hasTime ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-input`)
  }, [createVNode(_component_InputInner, {
    modelValue: _ctx.inputDate,
    class: normalizeClass(`${_ctx.prefixCls}-input-date`),
    placeholder: _ctx.t('datePicker.selectDate'),
    onInput: _ctx.handleDateInput,
    onBlur: _ctx.handleDateInputBlur
  }, null, 8
  /* PROPS */
  , ["modelValue", "class", "placeholder", "onInput", "onBlur"]), createVNode(_component_TimePicker, mergeProps({
    inputClass: `${_ctx.prefixCls}-input-time`,
    modelValue: _ctx.currentTime
  }, _ctx.innerDisabledTime, {
    showSuffix: false,
    clearable: false,
    hourStep: _ctx.hourStep,
    minuteStep: _ctx.minuteStep,
    secondStep: _ctx.secondStep,
    appendToContainer: false,
    placeholder: _ctx.t('datePicker.selectTime'),
    onChange: _ctx.changeTime
  }), null, 16
  /* FULL_PROPS */
  , ["inputClass", "modelValue", "hourStep", "minuteStep", "secondStep", "placeholder", "onChange"])], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-head`),
    onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"]))
  }, [createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-head-left`)
  }, [createVNode(_component_DoubleLeftOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-icon`),
    onClick: _ctx.yearToPre
  }, null, 8
  /* PROPS */
  , ["class", "onClick"]), withDirectives(createVNode(_component_LeftOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-icon`),
    onClick: _ctx.monthToPre
  }, null, 8
  /* PROPS */
  , ["class", "onClick"]), [[vShow, _ctx.visibleLeftSingleArrow]])], 2
  /* CLASS */
  ), createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-head-middle`)
  }, [createElementVNode("span", {
    class: normalizeClass(`${_ctx.prefixCls}-head-middle-item`)
  }, toDisplayString(_ctx.currentDate.year) + toDisplayString(_ctx.t('datePicker.year')), 3
  /* TEXT, CLASS */
  ), withDirectives(createElementVNode("span", {
    class: normalizeClass(`${_ctx.prefixCls}-head-middle-item`)
  }, toDisplayString(_ctx.t(`datePicker.month${_ctx.currentDate.month + 1}`)), 3
  /* TEXT, CLASS */
  ), [[vShow, !_ctx.isYearSelect && !_ctx.isMonthSelect && !_ctx.isQuarterSelect]])], 2
  /* CLASS */
  ), createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-head-right`)
  }, [withDirectives(createVNode(_component_RightOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-icon`),
    onClick: _ctx.monthToNext
  }, null, 8
  /* PROPS */
  , ["class", "onClick"]), [[vShow, _ctx.visibleRightSingleArrow]]), createVNode(_component_DoubleRightOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-icon`),
    onClick: _ctx.yearToNext
  }, null, 8
  /* PROPS */
  , ["class", "onClick"])], 2
  /* CLASS */
  )], 34
  /* CLASS, HYDRATE_EVENTS */
  ), createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-body`),
    onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {}, ["prevent"]))
  }, [_ctx.isDaySelect ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-days`)
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.weekNames, weekName => {
    return openBlock(), createElementBlock("span", {
      key: weekName,
      class: normalizeClass(`${_ctx.prefixCls}-week`)
    }, toDisplayString(weekName), 3
    /* TEXT, CLASS */
    );
  }), 128
  /* KEYED_FRAGMENT */
  )), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.days, (item, i) => {
    return openBlock(), createElementBlock("span", {
      key: i,
      class: normalizeClass(_ctx.dayCls(item)),
      onClick: $event => _ctx.isNotDisabled($event) && _ctx.selectedDay(item)
    }, toDisplayString(item.day), 11
    /* TEXT, CLASS, PROPS */
    , _hoisted_1$6);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), _ctx.isMonthSelect ? (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(`${_ctx.prefixCls}-months`)
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.MONTHS_NAMES, (monthName, i) => {
    return openBlock(), createElementBlock("span", {
      key: i,
      class: normalizeClass(_ctx.monthCls(i)),
      onClick: $event => _ctx.isNotDisabled($event) && _ctx.selectMonth(i)
    }, toDisplayString(_ctx.t(`datePicker.months.${monthName}`)), 11
    /* TEXT, CLASS, PROPS */
    , _hoisted_2$4);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), _ctx.isYearSelect ? (openBlock(), createElementBlock("div", {
    key: 2,
    class: normalizeClass(`${_ctx.prefixCls}-years`)
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.years, (year, index) => {
    return openBlock(), createElementBlock("span", {
      key: index,
      class: normalizeClass(_ctx.yearCls(year)),
      onClick: $event => _ctx.isNotDisabled($event) && _ctx.selectYear(year)
    }, toDisplayString(year), 11
    /* TEXT, CLASS, PROPS */
    , _hoisted_3$3);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), _ctx.isQuarterSelect ? (openBlock(), createElementBlock("div", {
    key: 3,
    class: normalizeClass(`${_ctx.prefixCls}-quarters`)
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.quarterList, item => {
    return openBlock(), createElementBlock("span", {
      key: item.value,
      class: normalizeClass(_ctx.quarterCls(item)),
      onClick: $event => _ctx.isNotDisabled($event) && _ctx.selectQuarter(item)
    }, toDisplayString(_ctx.t(`datePicker.quarters.${item.name}`)), 11
    /* TEXT, CLASS, PROPS */
    , _hoisted_4);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true)], 34
  /* CLASS, HYDRATE_EVENTS */
  )], 2
  /* CLASS */
  );
}

script$e.render = render$c;
script$e.__file = "components/date-picker/calendar.vue";

const useSelectStatus = props => {
  const selectedStatus = ref(0);
  const lastSelectedPosition = ref();
  watch(() => props.modelValue, () => {
    if (Array.isArray(props.modelValue)) {
      selectedStatus.value = props.modelValue.length ? SELECTED_STATUS.TWO : SELECTED_STATUS.EMPTY;
    }
  }, {
    immediate: true
  });
  watch(() => props.visible, () => {
    if (!props.visible && selectedStatus.value === SELECTED_STATUS.ONE) {
      selectedStatus.value = SELECTED_STATUS.EMPTY;
    }
  });

  const selectedDay = position => {
    lastSelectedPosition.value = position;

    switch (selectedStatus.value) {
      case SELECTED_STATUS.EMPTY:
        selectedStatus.value = SELECTED_STATUS.ONE;
        break;

      case SELECTED_STATUS.ONE:
        selectedStatus.value = SELECTED_STATUS.TWO;
        break;

      case SELECTED_STATUS.TWO:
        selectedStatus.value = SELECTED_STATUS.ONE;
        break;

      default:
        selectedStatus.value = SELECTED_STATUS.EMPTY;
        break;
    }
  };

  return {
    selectedStatus,
    selectedDay,
    lastSelectedPosition
  };
};
const useRange = _ref => {
  let {
    props,
    tempCurrentValue,
    innerDisabledDate,
    selectedStatus,
    lastSelectedPosition,
    picker
  } = _ref;
  // TODO  type 
  if (!picker.value.isRange) return {};
  const leftActiveDate = ref(getTimestampFromFormat(tempCurrentValue.value[0] && new Date(tempCurrentValue.value[0]), picker.value.format));
  const rightActiveDate = ref(picker.value.getRightActiveDate(leftActiveDate.value));

  const resetActiveDate = () => {
    if (picker.value.isInSamePanel(tempCurrentValue.value[0], tempCurrentValue.value[1])) {
      if (lastSelectedPosition.value === RANGE_POSITION.LEFT) {
        leftActiveDate.value = tempCurrentValue.value[0];
        rightActiveDate.value = picker.value.getRightActiveDate(leftActiveDate.value);
      } else {
        rightActiveDate.value = tempCurrentValue.value[1];
        leftActiveDate.value = picker.value.getLeftActiveDate(rightActiveDate.value);
      }
    } else {
      leftActiveDate.value = tempCurrentValue.value[0];
      rightActiveDate.value = tempCurrentValue.value[1];
    }
  };

  const changeCurrentDate = (timestamp, position) => {
    if (position === RANGE_POSITION.LEFT) {
      leftActiveDate.value = timestamp;

      if (timestamp >= rightActiveDate.value) {
        rightActiveDate.value = picker.value.getRightActiveDate(timestamp);
      }
    } else if (position === RANGE_POSITION.RIGHT) {
      rightActiveDate.value = timestamp;

      if (timestamp <= leftActiveDate.value) {
        leftActiveDate.value = picker.value.getLeftActiveDate(timestamp);
      }
    }
  };

  const maxRangeDisabled = (date, format, flagDate) => {
    if (flagDate) {
      return isBeyondRangeTime({
        flagDate,
        currentDate: date,
        maxRange: props.maxRange,
        format
      });
    } else if (props.maxRange && selectedStatus.value === SELECTED_STATUS.ONE) {
      return isBeyondRangeTime({
        flagDate: new Date(tempCurrentValue.value[0]),
        currentDate: date,
        maxRange: props.maxRange,
        format
      });
    }

    return false;
  };

  const rangeDisabledDate = (date, format, flagDate) => {
    if (maxRangeDisabled(date, format, flagDate)) {
      return true;
    }

    return innerDisabledDate(date, format);
  };

  return {
    leftActiveDate,
    rightActiveDate,
    changeCurrentDate,
    rangeDisabledDate,
    resetActiveDate
  };
};

function useDisable(props) {
  const innerDisabledDate = (date, format, flagDate) => {
    var _props$disabledDate;

    const min = props.minDate && contrastDate(date, props.minDate, format) === -1;
    const max = props.maxDate && contrastDate(date, props.maxDate, format) === 1;
    let isBeyondRange = false;

    if (props.maxRange && flagDate) {
      isBeyondRange = isBeyondRangeTime({
        currentDate: date,
        maxRange: props.maxRange,
        flagDate,
        format
      });
    }

    return min || max || isBeyondRange || ((_props$disabledDate = props.disabledDate) === null || _props$disabledDate === void 0 ? void 0 : _props$disabledDate.call(props, date));
  };

  return {
    innerDisabledDate
  };
}

function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$s = getPrefixCls('calendars');

const calendarsProps = _objectSpread$e(_objectSpread$e(_objectSpread$e({}, COMMON_PROPS), RANGE_PROPS), {}, {
  visible: {
    type: Boolean,
    default: false
  },
  disabledDate: {
    type: Function,
    default: () => false
  },
  control: Boolean,
  shortcuts: Object
});

var script$d = defineComponent({
  name: 'FCalendars',
  components: {
    Calendar: script$e,
    FButton
  },
  props: calendarsProps,
  emits: ['update:modelValue', 'tmpSelectedDateChange', 'change'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const [selectedDates] = useNormalModel(props, emit);
    const pickerRef = computed(() => {
      return pickerFactory(props.type);
    });
    const tempCurrentValue = ref([]);
    const {
      innerDisabledDate
    } = useDisable(props);
    const {
      t
    } = useLocale();
    const currentText = computed(() => {
      const confirmLang = pickerRef.value.confirmLang;
      return confirmLang ? t(confirmLang) : '';
    });
    const {
      selectedStatus,
      selectedDay,
      lastSelectedPosition
    } = useSelectStatus(props);
    const {
      leftActiveDate,
      rightActiveDate,
      changeCurrentDate,
      rangeDisabledDate,
      resetActiveDate
    } = useRange({
      props,
      tempCurrentValue,
      innerDisabledDate,
      selectedStatus,
      lastSelectedPosition,
      picker: pickerRef
    });
    const confirmDisabled = computed(() => {
      if (pickerRef.value.isRange) {
        return !tempCurrentValue.value.length;
      }

      if (pickerRef.value.name === PickerType.datemultiple) {
        return false;
      }

      return !tempCurrentValue.value[0];
    });
    const visibleFooter = computed(() => props.control || pickerRef.value.name === PickerType.datemultiple || pickerRef.value.isRange || pickerRef.value.hasTime);

    const change = () => {
      if (pickerRef.value.isRange || pickerRef.value.name === PickerType.datemultiple) {
        emit('change', tempCurrentValue.value);
      } else {
        emit('change', tempCurrentValue.value[0]);
      }
    };

    const updateTempCurrentValue = val => {
      tempCurrentValue.value = val;

      if (pickerRef.value.isRange || pickerRef.value.name === PickerType.datemultiple) {
        emit('tmpSelectedDateChange', tempCurrentValue.value);
      } else {
        emit('tmpSelectedDateChange', tempCurrentValue.value[0]);
      }

      if (!visibleFooter.value) {
        change();
      }
    };

    const handleTempCurrentValue = () => {
      if (isArray$1(selectedDates.value)) {
        tempCurrentValue.value = selectedDates.value;
      } else {
        tempCurrentValue.value = selectedDates.value ? [selectedDates.value] : [];
      }
    };

    watch(selectedDates, handleTempCurrentValue, {
      deep: true
    });
    const defaultActiveDate = ref(Date.now());
    watch(() => props.visible, () => {
      if (props.visible) {
        handleTempCurrentValue();

        if (tempCurrentValue.value.length) {
          if (pickerRef.value.isRange) {
            resetActiveDate();
          } else {
            defaultActiveDate.value = tempCurrentValue.value[0];
          }
        }
      }
    }, {
      immediate: true
    });

    const selectCurrentTime = () => {
      if (pickerRef.value.isRange) {
        // FEATURE
        const format = pickerRef.value.format;
        updateTempCurrentValue([getTimestampFromFormat(null, format), getTimestampFromFormat(null, format, true)]);
      } else {
        updateTempCurrentValue([getTimestampFromFormat(null, pickerRef.value.format)]);
        change();
      }
    };

    const confirm = () => {
      change();
    };

    const handleShortcut = val => {
      if (isFunction(val)) {
        val = val();
      }

      if (isArray$1(val)) {
        tempCurrentValue.value = val;
      } else if (isNumber(val)) {
        tempCurrentValue.value = [val];
      }

      change();
    };

    return {
      RANGE_POSITION,
      prefixCls: prefixCls$s,
      tempCurrentValue,
      change,
      pickerRef,
      leftActiveDate,
      rightActiveDate,
      changeCurrentDate,
      visibleFooter,
      selectCurrentTime,
      confirmDisabled,
      innerDisabledDate,
      rangeDisabledDate,
      selectedStatus,
      selectedDay,
      updateTempCurrentValue,
      confirm,
      t,
      currentText,
      handleShortcut,
      defaultActiveDate
    };
  }

});

const _hoisted_1$5 = ["onClick"];
function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Calendar = resolveComponent("Calendar");

  const _component_FButton = resolveComponent("FButton");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [createElementVNode("div", null, [_ctx.pickerRef.isRange ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-daterange`)
  }, [createVNode(_component_Calendar, {
    modelValue: _ctx.tempCurrentValue,
    type: _ctx.type,
    disabledTime: _ctx.disabledTime,
    disabledDate: _ctx.rangeDisabledDate,
    rangePosition: _ctx.RANGE_POSITION.LEFT,
    activeDate: _ctx.leftActiveDate,
    selectedStatus: _ctx.selectedStatus,
    hourStep: _ctx.hourStep,
    minuteStep: _ctx.minuteStep,
    secondStep: _ctx.secondStep,
    defaultTime: _ctx.defaultTime,
    onChange: _ctx.updateTempCurrentValue,
    onSelectedDay: _cache[0] || (_cache[0] = $event => _ctx.selectedDay(_ctx.RANGE_POSITION.LEFT)),
    "onUpdate:activeDate": _cache[1] || (_cache[1] = timestamp => _ctx.changeCurrentDate(timestamp, _ctx.RANGE_POSITION.LEFT))
  }, null, 8
  /* PROPS */
  , ["modelValue", "type", "disabledTime", "disabledDate", "rangePosition", "activeDate", "selectedStatus", "hourStep", "minuteStep", "secondStep", "defaultTime", "onChange"]), createVNode(_component_Calendar, {
    modelValue: _ctx.tempCurrentValue,
    type: _ctx.type,
    disabledTime: _ctx.disabledTime,
    disabledDate: _ctx.rangeDisabledDate,
    rangePosition: _ctx.RANGE_POSITION.RIGHT,
    activeDate: _ctx.rightActiveDate,
    selectedStatus: _ctx.selectedStatus,
    hourStep: _ctx.hourStep,
    minuteStep: _ctx.minuteStep,
    secondStep: _ctx.secondStep,
    defaultTime: _ctx.defaultTime,
    onChange: _ctx.updateTempCurrentValue,
    onSelectedDay: _cache[2] || (_cache[2] = $event => _ctx.selectedDay(_ctx.RANGE_POSITION.RIGHT)),
    "onUpdate:activeDate": _cache[3] || (_cache[3] = timestamp => _ctx.changeCurrentDate(timestamp, _ctx.RANGE_POSITION.RIGHT))
  }, null, 8
  /* PROPS */
  , ["modelValue", "type", "disabledTime", "disabledDate", "rangePosition", "activeDate", "selectedStatus", "hourStep", "minuteStep", "secondStep", "defaultTime", "onChange"])], 2
  /* CLASS */
  )) : (openBlock(), createBlock(_component_Calendar, {
    key: 1,
    activeDate: _ctx.defaultActiveDate,
    "onUpdate:activeDate": _cache[4] || (_cache[4] = $event => _ctx.defaultActiveDate = $event),
    modelValue: _ctx.tempCurrentValue,
    type: _ctx.type,
    disabledTime: _ctx.disabledTime,
    disabledDate: _ctx.innerDisabledDate,
    hourStep: _ctx.hourStep,
    minuteStep: _ctx.minuteStep,
    secondStep: _ctx.secondStep,
    defaultTime: _ctx.defaultTime,
    onChange: _ctx.updateTempCurrentValue
  }, null, 8
  /* PROPS */
  , ["activeDate", "modelValue", "type", "disabledTime", "disabledDate", "hourStep", "minuteStep", "secondStep", "defaultTime", "onChange"])), _ctx.visibleFooter ? (openBlock(), createElementBlock("div", {
    key: 2,
    class: normalizeClass(`${_ctx.prefixCls}-footer`)
  }, [createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-footer-inner`)
  }, [_ctx.currentText ? (openBlock(), createBlock(_component_FButton, {
    key: 0,
    type: "link",
    size: "small",
    onClick: _ctx.selectCurrentTime
  }, {
    default: withCtx(() => [createTextVNode(toDisplayString(_ctx.currentText), 1
    /* TEXT */
    )]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["onClick"])) : createCommentVNode("v-if", true), createVNode(_component_FButton, {
    disabled: _ctx.confirmDisabled,
    type: "primary",
    size: "small",
    onClick: _ctx.confirm
  }, {
    default: withCtx(() => [createTextVNode(toDisplayString(_ctx.t('datePicker.confirm')), 1
    /* TEXT */
    )]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["disabled", "onClick"])], 2
  /* CLASS */
  )], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true)]), _ctx.shortcuts && Object.keys(_ctx.shortcuts).length ? (openBlock(), createElementBlock("ul", {
    key: 0,
    class: normalizeClass(`${_ctx.prefixCls}-shortcuts`),
    onMousedown: _cache[5] || (_cache[5] = withModifiers(() => {}, ["prevent"]))
  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (val, name) => {
    return openBlock(), createElementBlock("li", {
      key: name,
      onClick: $event => _ctx.handleShortcut(val)
    }, toDisplayString(name), 9
    /* TEXT, PROPS */
    , _hoisted_1$5);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 34
  /* CLASS, HYDRATE_EVENTS */
  )) : createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$d.render = render$b;
script$d.__file = "components/date-picker/calendars.vue";

const prefixCls$r = getPrefixCls('range-input');
const rangeInputProps = {
  format: String,
  selectedDates: {
    type: Array
  },
  changeSelectedDates: Function,
  separator: String,
  maxRange: String,
  clearable: Boolean,
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: [String, Array],
  innerIsFocus: Boolean,
  innerIsError: Boolean
};

function useMouse(emit) {
  const hovering = ref(false);

  const onMouseLeave = e => {
    hovering.value = false;
    emit('mouseleave', e);
  };

  const onMouseEnter = e => {
    hovering.value = true;
    emit('mouseenter', e);
  };

  return {
    hovering,
    onMouseLeave,
    onMouseEnter
  };
}

function useRangeInput(props, position) {
  const inputText = ref();

  const resetInputValue = () => {
    inputText.value = isEmptyValue$1(props.selectedDates) ? '' : format$1(props.selectedDates[position], props.format);
  };

  watch(() => props.selectedDates, resetInputValue, {
    immediate: true
  });

  const updateInputText = val => {
    var _props$selectedDates, _props$selectedDates2;

    inputText.value = val;
    const date = strictParse(val, props.format, new Date());

    if (isValid(date) && !isBeyondRangeTime({
      flagDate: ((_props$selectedDates = props.selectedDates) === null || _props$selectedDates === void 0 ? void 0 : _props$selectedDates[position]) && new Date((_props$selectedDates2 = props.selectedDates) === null || _props$selectedDates2 === void 0 ? void 0 : _props$selectedDates2[position]),
      currentDate: date,
      maxRange: props.maxRange,
      format: props.format
    })) {
      // update selectedDates
      const dates = [...props.selectedDates];
      dates[position] = date.getTime();
      props.changeSelectedDates(dates);
    }
  };

  const {
    handleInput,
    handleCompositionStart,
    handleCompositionEnd
  } = useInput$1(updateInputText);
  return {
    inputText,
    handleInput,
    resetInputValue,
    handleCompositionStart,
    handleCompositionEnd
  };
}

function useLeftInput(props) {
  const {
    inputText,
    handleInput,
    resetInputValue,
    handleCompositionStart,
    handleCompositionEnd
  } = useRangeInput(props, 0);
  return {
    leftInputText: inputText,
    resetLeftInputText: resetInputValue,
    onLeftInput: handleInput,
    onLeftCompositionStart: handleCompositionStart,
    onLeftCompositionEnd: handleCompositionEnd
  };
}

function useRightInput(props) {
  const {
    inputText,
    handleInput,
    resetInputValue,
    handleCompositionStart,
    handleCompositionEnd
  } = useRangeInput(props, 1);
  return {
    rightInputText: inputText,
    resetRightInputText: resetInputValue,
    onRightInput: handleInput,
    onRightCompositionStart: handleCompositionStart,
    onRightCompositionEnd: handleCompositionEnd
  };
}

function useFocusBlur(props, emit) {
  const isFocus = ref(false);
  let againFocusFlag = false;
  watch(() => props.innerIsFocus, () => {
    if (props.innerIsFocus) {
      isFocus.value = true;
    }
  });

  const onFocus = e => {
    if (!isFocus.value) {
      isFocus.value = true;
      emit('focus', e);
    } else {
      againFocusFlag = true;
    }
  };

  const onBlur = e => {
    //  blur focus  input  blur
    nextTick(() => {
      if (isFocus.value && !againFocusFlag) {
        isFocus.value = false;
        emit('blur', e);
      }
    });
  };

  return {
    onFocus,
    onBlur
  };
}

var script$c = defineComponent({
  components: {
    CloseCircleFilled
  },
  props: rangeInputProps,
  emits: ['clear', 'blur', 'focus', 'mouseleave', 'mouseenter'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const inputRangeRefEl = ref();
    const innerPlaceHolder = computed(() => isArray$1(props.placeholder) ? props.placeholder : [props.placeholder, props.placeholder]);
    const {
      hovering,
      onMouseLeave,
      onMouseEnter
    } = useMouse(emit);
    const {
      leftInputText,
      resetLeftInputText,
      onLeftInput,
      onLeftCompositionStart,
      onLeftCompositionEnd
    } = useLeftInput(props);
    const {
      rightInputText,
      resetRightInputText,
      onRightInput,
      onRightCompositionStart,
      onRightCompositionEnd
    } = useRightInput(props);
    const showClear = computed(() => {
      var _props$selectedDates3;

      return props.clearable && !props.disabled && ((_props$selectedDates3 = props.selectedDates) === null || _props$selectedDates3 === void 0 ? void 0 : _props$selectedDates3.length) && hovering.value;
    });

    const clear = () => {
      emit('clear');
    };

    const {
      onFocus,
      onBlur
    } = useFocusBlur(props, emit);

    const focus = () => {
      if (!props.disabled) {
        inputRangeRefEl.value.focus();
      }
    };

    const blur = () => {
      inputRangeRefEl.value.blur();
    };

    return {
      inputRangeRefEl,
      prefixCls: prefixCls$r,
      innerPlaceHolder,
      leftInputText,
      onLeftInput,
      onLeftCompositionStart,
      onLeftCompositionEnd,
      rightInputText,
      onRightInput,
      onRightCompositionStart,
      onRightCompositionEnd,
      onFocus,
      onBlur: event => {
        resetLeftInputText();
        resetRightInputText();
        onBlur(event);
      },
      focus,
      blur,
      onMouseLeave,
      onMouseEnter,
      showClear,
      clear
    };
  }

});

const _hoisted_1$4 = ["tabindex"];
const _hoisted_2$3 = ["value", "placeholder"];
const _hoisted_3$2 = ["value", "placeholder"];
function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CloseCircleFilled = resolveComponent("CloseCircleFilled");

  return openBlock(), createElementBlock("span", {
    ref: "inputRangeRefEl",
    class: normalizeClass([_ctx.prefixCls, _ctx.disabled && 'is-disabled', _ctx.innerIsFocus && 'is-focused', _ctx.innerIsError && 'is-error']),
    tabindex: _ctx.disabled ? null : 0,
    onMouseenter: _cache[11] || (_cache[11] = function () {
      return _ctx.onMouseEnter && _ctx.onMouseEnter(...arguments);
    }),
    onMouseleave: _cache[12] || (_cache[12] = function () {
      return _ctx.onMouseLeave && _ctx.onMouseLeave(...arguments);
    }),
    onFocus: _cache[13] || (_cache[13] = function () {
      return _ctx.onFocus && _ctx.onFocus(...arguments);
    }),
    onBlur: _cache[14] || (_cache[14] = function () {
      return _ctx.onBlur && _ctx.onBlur(...arguments);
    })
  }, [createElementVNode("input", {
    class: normalizeClass(`${_ctx.prefixCls}-inner`),
    value: _ctx.leftInputText,
    placeholder: _ctx.innerPlaceHolder[0],
    onCompositionstart: _cache[0] || (_cache[0] = function () {
      return _ctx.onLeftCompositionStart && _ctx.onLeftCompositionStart(...arguments);
    }),
    onCompositionend: _cache[1] || (_cache[1] = function () {
      return _ctx.onLeftCompositionEnd && _ctx.onLeftCompositionEnd(...arguments);
    }),
    onInput: _cache[2] || (_cache[2] = function () {
      return _ctx.onLeftInput && _ctx.onLeftInput(...arguments);
    }),
    onFocus: _cache[3] || (_cache[3] = function () {
      return _ctx.onFocus && _ctx.onFocus(...arguments);
    }),
    onBlur: _cache[4] || (_cache[4] = function () {
      return _ctx.onBlur && _ctx.onBlur(...arguments);
    })
  }, null, 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , _hoisted_2$3), createElementVNode("span", {
    class: normalizeClass(`${_ctx.prefixCls}-separator`)
  }, [renderSlot(_ctx.$slots, "separator")], 2
  /* CLASS */
  ), createElementVNode("input", {
    class: normalizeClass(`${_ctx.prefixCls}-inner`),
    value: _ctx.rightInputText,
    placeholder: _ctx.innerPlaceHolder[1],
    onCompositionstart: _cache[5] || (_cache[5] = function () {
      return _ctx.onRightCompositionStart && _ctx.onRightCompositionStart(...arguments);
    }),
    onCompositionend: _cache[6] || (_cache[6] = function () {
      return _ctx.onRightCompositionEnd && _ctx.onRightCompositionEnd(...arguments);
    }),
    onInput: _cache[7] || (_cache[7] = function () {
      return _ctx.onRightInput && _ctx.onRightInput(...arguments);
    }),
    onFocus: _cache[8] || (_cache[8] = function () {
      return _ctx.onFocus && _ctx.onFocus(...arguments);
    }),
    onBlur: _cache[9] || (_cache[9] = function () {
      return _ctx.onBlur && _ctx.onBlur(...arguments);
    })
  }, null, 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , _hoisted_3$2), createElementVNode("span", {
    class: normalizeClass(`${_ctx.prefixCls}-suffix`),
    onMousedown: _cache[10] || (_cache[10] = withModifiers(() => {}, ["prevent"]))
  }, [_ctx.showClear ? (openBlock(), createBlock(_component_CloseCircleFilled, {
    key: 0,
    onClick: withModifiers(_ctx.clear, ["stop"])
  }, null, 8
  /* PROPS */
  , ["onClick"])) : renderSlot(_ctx.$slots, "suffix", {
    key: 1
  })], 34
  /* CLASS, HYDRATE_EVENTS */
  )], 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , _hoisted_1$4);
}

script$c.render = render$a;
script$c.__file = "components/date-picker/rangeInput.vue";

function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$q = getPrefixCls('date-picker');

const datePickerProps = _objectSpread$d(_objectSpread$d({
  open: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: [String, Array]
  },
  appendToContainer: {
    type: Boolean,
    default: true
  },
  getContainer: {
    type: Function
  },
  popperClass: [String, Array, Object],
  control: Boolean,
  shortcuts: Object,
  disabledDate: Function
}, COMMON_PROPS), RANGE_PROPS);

const useTmpSelectedDates = () => {
  const tmpSelectedDates = ref();

  const tmpSelectedDateChange = val => {
    tmpSelectedDates.value = val;
  };

  return {
    tmpSelectedDates,
    tmpSelectedDateChange
  };
};

const useInput = _ref => {
  let {
    props,
    visibleValue,
    picker,
    changeDateByInput
  } = _ref;
  const dateText = ref();
  const {
    innerDisabledDate
  } = useDisable(props);
  let cacheValidInputDate = '';

  const getFormatDate = () => {
    if (isEmptyValue$1(visibleValue.value)) {
      return '';
    }

    if (!picker.value.isRange) {
      if (isArray$1(visibleValue.value)) {
        return visibleValue.value.map(item => {
          return format$1(item, props.format || picker.value.format);
        }).join('; ');
      }

      return format$1(visibleValue.value, props.format || picker.value.format);
    }

    return '';
  };

  const resetDateText = () => {
    dateText.value = getFormatDate();
    cacheValidInputDate = dateText.value;
  };

  watch(visibleValue, resetDateText, {
    immediate: true
  });

  const handleDateInput = val => {
    dateText.value = val;
    const date = strictParse(val, props.format || picker.value.format, new Date());

    if (isValid(date) && !innerDisabledDate(date, props.format || picker.value.format)) {
      cacheValidInputDate = val;
      changeDateByInput(date.getTime());
    }
  };

  const handleDateInputBlur = () => {
    if (dateText.value !== cacheValidInputDate && cacheValidInputDate) {
      dateText.value = cacheValidInputDate;
    }
  };

  return {
    resetDateText,
    dateText,
    handleDateInput,
    handleDateInputBlur
  };
};

const usePlaceholder = (props, picker) => {
  const {
    t
  } = useLocale();
  const rangePlaceHolder = computed(() => {
    if (props.placeholder) return props.placeholder;
    const placeholderLang = picker.value.placeholderLang;

    if (Array.isArray(placeholderLang)) {
      return placeholderLang.map(item => t(item));
    }

    return t(placeholderLang);
  });
  const singlePlaceHolder = computed(() => {
    if (props.placeholder) return props.placeholder;
    return t(picker.value.placeholderLang);
  });
  return {
    rangePlaceHolder,
    singlePlaceHolder
  };
};

var script$b = defineComponent({
  name: 'FDatePicker',
  components: {
    Calendars: script$d,
    InputInner: script$y,
    Popper: FPopper,
    DateOutlined,
    RangeInput: script$c,
    SwapRightOutlined
  },
  props: datePickerProps,
  emits: ['update:modelValue', 'update:open', 'change', 'clear', 'blur', 'focus'],

  setup(props, _ref2) {
    let {
      emit,
      attrs
    } = _ref2;
    useTheme();
    const [isOpened, updatePopperOpen] = useNormalModel(props, emit, {
      prop: 'open'
    });
    const [currentValue, updateCurrentValue] = useNormalModel(props, emit);
    /**
     * props.format  picker.value.format 
     * picker.value.format 
     */

    const pickerRef = computed(() => {
      return pickerFactory(props.type);
    });
    const inputRefEl = ref();
    const inputRangeRefEL = ref();
    const calendarsRef = ref();
    const activeInputRefEL = computed(() => {
      if (pickerRef.value.isRange) {
        return inputRangeRefEL.value;
      }

      return inputRefEl.value;
    });
    const {
      validate,
      isError,
      isFormDisabled
    } = useFormAdaptor({
      valueType: computed(() => pickerRef.value.isRange ? 'array' : 'number'),
      forbidChildValidate: true
    });
    const innerDisabled = computed(() => props.disabled || isFormDisabled.value);
    const {
      rangePlaceHolder,
      singlePlaceHolder
    } = usePlaceholder(props, pickerRef);
    const {
      tmpSelectedDates,
      tmpSelectedDateChange
    } = useTmpSelectedDates();
    const visibleValue = computed(() => {
      if (isOpened.value) {
        return isNil(tmpSelectedDates.value) ? currentValue.value : tmpSelectedDates.value;
      }

      return currentValue.value;
    });

    const handleChange = val => {
      if (!isEqual(val, currentValue.value)) {
        updateCurrentValue(val);
        emit('change', val);
        validate('change');
      }
    }; //  currentValue


    const changeDateByInput = val => {
      tmpSelectedDateChange(null);
      handleChange(val);
    };

    const {
      resetDateText,
      dateText,
      handleDateInput,
      handleDateInputBlur
    } = useInput({
      props,
      visibleValue,
      changeDateByInput,
      picker: pickerRef
    }); // 

    const clear = () => {
      const initValue = pickerRef.value.isRange || pickerRef.value.name === PickerType.datemultiple ? [] : null;
      tmpSelectedDateChange(null);
      handleChange(initValue);
      emit('clear');
    };

    const changeDateBycalendars = val => {
      handleChange(val); // 
      // TODO 

      activeInputRefEL.value.focus();
      updatePopperOpen(false);
    };

    const inputIsFocus = ref(false);

    const handleFocus = e => {
      // 
      if (!inputIsFocus.value) {
        inputIsFocus.value = true;
        emit('focus', e);
      }
    };

    let cacheEvent = null;

    const checkBlur = () => {
      if (!isOpened.value && cacheEvent) {
        emit('blur', cacheEvent);
        validate('blur'); // 

        resetDateText();
        cacheEvent = null;
        inputIsFocus.value = false;
      }
    };

    const handleBlur = e => {
      cacheEvent = e; //  blur 

      if (!calendarsRef.value.$el.contains(e.relatedTarget)) {
        if (isOpened.value) {
          updatePopperOpen(false);
        }

        checkBlur();
      }
    };

    watch(isOpened, () => {
      if (!isOpened.value) {
        // 
        tmpSelectedDateChange(null);
      }
    });

    const handlePopperVisible = val => {
      if (val === false) {
        checkBlur();
      }
    };

    return {
      prefixCls: prefixCls$q,
      isOpened,
      currentValue,
      visibleValue,
      isError,
      innerDisabled,
      dateText,
      handleDateInput,
      handleDateInputBlur: event => {
        handleDateInputBlur();
        handleBlur(event);
      },
      PickerType,
      pickerRef,
      changeDateByInput,
      clear,
      changeDateBycalendars,
      inputIsFocus,
      handleFocus,
      handleBlur,
      tmpSelectedDateChange,
      rangePlaceHolder,
      singlePlaceHolder,
      handlePopperVisible,
      inputRefEl,
      inputRangeRefEL,
      calendarsRef,
      attrs
    };
  }

});

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SwapRightOutlined = resolveComponent("SwapRightOutlined");

  const _component_DateOutlined = resolveComponent("DateOutlined");

  const _component_RangeInput = resolveComponent("RangeInput");

  const _component_InputInner = resolveComponent("InputInner");

  const _component_calendars = resolveComponent("calendars");

  const _component_Popper = resolveComponent("Popper");

  return openBlock(), createBlock(_component_Popper, {
    modelValue: _ctx.isOpened,
    "onUpdate:modelValue": [_cache[0] || (_cache[0] = $event => _ctx.isOpened = $event), _ctx.handlePopperVisible],
    disabled: _ctx.innerDisabled,
    appendToContainer: _ctx.appendToContainer,
    getContainer: _ctx.getContainer,
    popperClass: [_ctx.popperClass, `${_ctx.prefixCls}-popper`],
    trigger: "click",
    hideAfter: 0,
    placement: "bottom-start",
    offset: 4,
    onlyShowTrigger: ""
  }, {
    trigger: withCtx(() => [_ctx.pickerRef.isRange ? (openBlock(), createBlock(_component_RangeInput, {
      key: 0,
      ref: "inputRangeRefEL",
      format: _ctx.format || _ctx.pickerRef.format,
      selectedDates: _ctx.visibleValue,
      placeholder: _ctx.rangePlaceHolder,
      clearable: _ctx.clearable,
      disabled: _ctx.innerDisabled,
      innerIsFocus: _ctx.inputIsFocus,
      innerIsError: _ctx.isError,
      class: normalizeClass(_ctx.attrs.class),
      style: normalizeStyle(_ctx.attrs.style),
      changeSelectedDates: _ctx.changeDateByInput,
      maxRange: _ctx.maxRange,
      onFocus: _ctx.handleFocus,
      onBlur: _ctx.handleBlur,
      onClear: _ctx.clear
    }, {
      separator: withCtx(() => [_ctx.$slots.separator ? renderSlot(_ctx.$slots, "separator", {
        key: 0
      }) : (openBlock(), createBlock(_component_SwapRightOutlined, {
        key: 1
      }))]),
      suffix: withCtx(() => [_ctx.$slots.suffixIcon ? renderSlot(_ctx.$slots, "suffixIcon", {
        key: 0
      }) : (openBlock(), createBlock(_component_DateOutlined, {
        key: 1
      }))]),
      _: 3
      /* FORWARDED */

    }, 8
    /* PROPS */
    , ["format", "selectedDates", "placeholder", "clearable", "disabled", "innerIsFocus", "innerIsError", "class", "style", "changeSelectedDates", "maxRange", "onFocus", "onBlur", "onClear"])) : (openBlock(), createBlock(_component_InputInner, {
      key: 1,
      ref: "inputRefEl",
      modelValue: _ctx.dateText,
      placeholder: _ctx.singlePlaceHolder,
      disabled: _ctx.innerDisabled,
      canEdit: _ctx.pickerRef.name !== _ctx.PickerType.datemultiple,
      clearable: _ctx.clearable,
      innerIsFocus: _ctx.inputIsFocus,
      innerIsError: _ctx.isError,
      class: normalizeClass(_ctx.attrs.class),
      style: normalizeStyle(_ctx.attrs.style),
      onFocus: _ctx.handleFocus,
      onInput: _ctx.handleDateInput,
      onBlur: _ctx.handleDateInputBlur,
      onClear: _ctx.clear
    }, {
      suffix: withCtx(() => [_ctx.$slots.suffixIcon ? renderSlot(_ctx.$slots, "suffixIcon", {
        key: 0
      }) : (openBlock(), createBlock(_component_DateOutlined, {
        key: 1
      }))]),
      _: 3
      /* FORWARDED */

    }, 8
    /* PROPS */
    , ["modelValue", "placeholder", "disabled", "canEdit", "clearable", "innerIsFocus", "innerIsError", "class", "style", "onFocus", "onInput", "onBlur", "onClear"]))]),
    default: withCtx(() => [createVNode(_component_calendars, {
      ref: "calendarsRef",
      visible: _ctx.isOpened,
      modelValue: _ctx.currentValue,
      type: _ctx.type,
      control: _ctx.control,
      shortcuts: _ctx.shortcuts,
      minDate: _ctx.minDate,
      maxDate: _ctx.maxDate,
      maxRange: _ctx.maxRange,
      hourStep: _ctx.hourStep,
      minuteStep: _ctx.minuteStep,
      secondStep: _ctx.secondStep,
      disabledDate: _ctx.disabledDate,
      disabledTime: _ctx.disabledTime,
      defaultTime: _ctx.defaultTime,
      onChange: _ctx.changeDateBycalendars,
      onTmpSelectedDateChange: _ctx.tmpSelectedDateChange
    }, null, 8
    /* PROPS */
    , ["visible", "modelValue", "type", "control", "shortcuts", "minDate", "maxDate", "maxRange", "hourStep", "minuteStep", "secondStep", "disabledDate", "disabledTime", "defaultTime", "onChange", "onTmpSelectedDateChange"])]),
    _: 3
    /* FORWARDED */

  }, 8
  /* PROPS */
  , ["modelValue", "disabled", "appendToContainer", "getContainer", "popperClass", "onUpdate:modelValue"]);
}

script$b.render = render$9;
script$b.__file = "components/date-picker/datePicker.vue";

const FDatePicker = withInstall(script$b);

const COMPONENT_NAME$2 = {
  TREE: 'FTree',
  TREE_NODE: 'FTreeNode'
};
const CHECK_STRATEGY$1 = {
  ALL: 'all',
  PARENT: 'parent',
  CHILD: 'child'
};
const INDENT = 16;

const treeProps = {
  data: {
    type: Array,

    default() {
      return [];
    }

  },
  defaultExpandAll: {
    type: Boolean,
    default: false
  },
  expandedKeys: {
    type: Array,

    default() {
      return [];
    }

  },
  accordion: {
    type: Boolean,
    default: false
  },
  selectable: {
    type: Boolean,
    default: true
  },
  selectedKeys: {
    type: Array,

    default() {
      return [];
    }

  },
  cascade: {
    type: Boolean,
    default: false
  },
  checkable: {
    type: Boolean,
    default: false
  },
  checkStrictly: {
    type: String,
    default: CHECK_STRATEGY$1.ALL
  },
  checkedKeys: {
    type: Array,

    default() {
      return [];
    }

  },
  multiple: {
    type: Boolean,
    default: false
  },
  childrenField: {
    type: String,
    default: 'children'
  },
  valueField: {
    type: String,
    default: 'value'
  },
  labelField: {
    type: String,
    default: 'label'
  },
  remote: {
    type: Boolean,
    default: false
  },
  loadData: {
    type: Function
  },
  filterMethod: {
    type: Function
  },
  inline: {
    type: Boolean,
    default: false
  },
  virtualList: {
    type: Boolean,
    default: false
  },
  cancelable: {
    type: Boolean,
    default: true
  },
  draggable: {
    type: Boolean,
    default: false
  }
};
extractPropsDefaultValue(treeProps);
const TREE_PROVIDE_KEY = Symbol('FTree');

var useTreeNode = (props => {
  const root = inject(TREE_PROVIDE_KEY);
  const node = root.nodeList.get(props.value);
  const isSelected = computed(() => root.hasSelected(props.value));
  const isExpanded = computed(() => {
    var _node$isExpanded;

    return (_node$isExpanded = node.isExpanded) === null || _node$isExpanded === void 0 ? void 0 : _node$isExpanded.value;
  });
  const isChecked = computed(() => node.isChecked.value);
  const isIndeterminate = computed(() => node.isIndeterminate.value);
  const isInline = computed(() => {
    if (!root.props.inline) {
      return false;
    }

    if (!props.isLeaf) {
      return false;
    }

    const nodeList = root.nodeList;
    const node = nodeList.get(props.value);
    const parentNodePath = node.indexPath[node.indexPath.length - 2];
    const parentNode = nodeList.get(parentNodePath);
    return parentNode.children.every(item => {
      const hasChildren = Array.isArray(item.children) && item.children.length;
      let isLeaf;

      if (!isNil(item.isLeaf)) {
        isLeaf = item.isLeaf;
      } else if (hasChildren) {
        isLeaf = false;
      } else if (root.props.remote) {
        isLeaf = false;
      } else {
        isLeaf = true;
      }

      return isLeaf;
    });
  });
  const isFirst = computed(() => {
    if (!isInline.value) {
      return false;
    }

    const nodeList = root.nodeList;
    const node = nodeList.get(props.value);
    const parentNodePath = node.indexPath[node.indexPath.length - 2];
    const parentNode = nodeList.get(parentNodePath);
    return parentNode.children[0].value === props.value;
  });
  return {
    root,
    isExpanded,
    isSelected,
    isChecked,
    isIndeterminate,
    isInline,
    isFirst
  };
});

const prefixCls$p = getPrefixCls('tree-node');
const treeNodeProps = {
  value: {
    type: [String, Number],
    required: true
  },
  label: {
    type: String,
    required: true
  },
  disabled: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  checkable: {
    type: Boolean
  },
  isLeaf: {
    type: Boolean,
    default: false
  },
  level: {
    type: Number,
    default: 0
  },
  draggable: {
    type: Boolean,
    default: false
  }
};
var TreeNode = defineComponent({
  name: COMPONENT_NAME$2.TREE_NODE,
  props: treeNodeProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      root,
      isExpanded,
      isSelected,
      isChecked,
      isIndeterminate,
      isInline,
      isFirst
    } = useTreeNode(props);
    const disabled = computed(() => props.disabled);
    const selectable = computed(() => isUndefined(props.selectable) ? root.props.selectable : props.selectable);
    const checkable = computed(() => isUndefined(props.checkable) ? root.props.checkable : props.checkable);
    const classList = computed(() => [prefixCls$p, disabled.value && 'is-disabled', isSelected.value && 'is-selected', isInline.value && 'is-inline', isFirst.value && 'is-inline-first'].filter(Boolean));
    const style = computed(() => {
      if (isInline.value && !isFirst.value) {
        return {};
      }

      return {
        paddingLeft: `${(props.level - 1) * INDENT}px`
      };
    });
    let isLoaded = false;
    const isLoading = ref(false);

    const handleClickSwitcher = async event => {
      const node = root.nodeList.get(props.value);

      if (!isLoaded && root.props.loadData && (!node.children || node.children.length === 0)) {
        isLoading.value = true;

        try {
          await root.props.loadData(node.origin);
          isLoaded = true;
          root.expandNode(props.value, event);
        } catch (e) {
          console.error(e);
        }

        isLoading.value = false;
      } else {
        root.expandNode(props.value, event);
      }
    };

    const handleClickContent = event => {
      if (disabled.value) return; //  select 

      if (selectable.value) {
        return root.selectNode(props.value, event);
      } //  check 


      if (checkable.value) {
        return root.checkNode(props.value, event);
      } // 


      if (!props.isLeaf) {
        handleClickSwitcher(event);
      }
    };

    const handleClickCheckbox = event => {
      if (disabled.value) return;

      if (checkable.value) {
        return root.checkNode(props.value, event);
      }
    };

    const handleStopClickPrefix = event => {
      event.stopPropagation();
    };

    const renderDrag = () => {
      const dragOverInfo = root.dragOverInfo.value;

      if ((dragOverInfo === null || dragOverInfo === void 0 ? void 0 : dragOverInfo.node.value) === props.value) {
        const style = {};

        if ((dragOverInfo === null || dragOverInfo === void 0 ? void 0 : dragOverInfo.position) === 'before') {
          style['top'] = '2px';
        } else if ((dragOverInfo === null || dragOverInfo === void 0 ? void 0 : dragOverInfo.position) === 'after') {
          style['bottom'] = '2px';
        }

        style['left'] = `${props.level * INDENT + 9}px`;
        return createVNode("div", {
          "class": `${prefixCls$p}-drag-over`,
          "style": style
        }, null);
      }

      return null;
    };

    const renderSwitcher = () => {
      if (props.isLeaf) {
        return createVNode("span", {
          "class": `${prefixCls$p}-switcher`
        }, null);
      }

      return createVNode("span", {
        "class": `${prefixCls$p}-switcher`,
        "onClick": handleClickSwitcher
      }, [isLoading.value ? createVNode(LoadingOutlined, null, null) : createVNode(CaretDownOutlined, {
        "class": `${prefixCls$p}-switcher-icon ${isExpanded.value ? 'is-expanded' : ''}`
      }, null)]);
    };

    const renderCheckbox = () => {
      if (root.props.checkable) {
        return createVNode("span", {
          "class": `${prefixCls$p}-checkbox`
        }, [createVNode(script$C, {
          "indeterminate": isIndeterminate.value,
          "modelValue": isChecked.value,
          "onClick": handleClickCheckbox,
          "disabled": props.disabled
        }, null)]);
      }

      return null;
    };

    const renderPrefix = () => {
      var _slots$prefix;

      if (!slots.prefix) return null;
      return createVNode("span", {
        "class": `${prefixCls$p}-content-prefix`,
        "onClick": handleStopClickPrefix
      }, [(_slots$prefix = slots.prefix) === null || _slots$prefix === void 0 ? void 0 : _slots$prefix.call(slots)]);
    };

    const renderSuffix = () => {
      var _slots$suffix;

      if (!slots.suffix) return null;
      return createVNode("span", {
        "class": `${prefixCls$p}-content-suffix`,
        "onClick": handleStopClickPrefix
      }, [(_slots$suffix = slots.suffix) === null || _slots$suffix === void 0 ? void 0 : _slots$suffix.call(slots)]);
    };

    return () => createVNode("div", {
      "class": classList.value,
      "style": style.value,
      "data-value": props.value,
      "draggable": props.draggable,
      "onDragstart": event => {
        root.handleDragstart(props.value, event);
      },
      "onDragenter": event => {
        root.handleDragenter(props.value, event);
      },
      "onDragover": event => {
        root.handleDragover(props.value, event);
      },
      "onDragleave": event => {
        root.handleDragleave(props.value, event);
      },
      "onDragend": event => {
        root.handleDragend(props.value, event);
      },
      "onDrop": event => {
        root.handleDrop(props.value, event);
      }
    }, [renderDrag(), renderSwitcher(), renderCheckbox(), createVNode("span", {
      "class": `${prefixCls$p}-content`,
      "onClick": handleClickContent
    }, [renderPrefix(), createVNode("span", {
      "class": `${prefixCls$p}-content-label`
    }, [props.label]), renderSuffix()])]);
  }

});

let uid = 1;

const getUid = () => {
  return uid++;
};

var useData$1 = (_ref => {
  let {
    props,
    emit
  } = _ref;
  const nodeList = new Map();
  const allKeys = ref([]);
  watch(allKeys, () => {
    emit('update:nodeList', nodeList);
  }, {
    immediate: true
  });

  const transformNode = (item, indexPath, level) => {
    const value = item[props.valueField];
    const label = item[props.labelField];
    const children = item[props.childrenField];
    const hasChildren = !!(Array.isArray(children) && children.length);
    let isLeaf;

    if (!isNil(item.isLeaf)) {
      isLeaf = item.isLeaf;
    } else if (hasChildren) {
      isLeaf = false;
    } else if (props.remote) {
      isLeaf = false;
    } else {
      isLeaf = true;
    }

    let copy;
    const newItem = {
      origin: item,
      prefix: item.prefix,
      suffix: item.suffix,
      disabled: item.disabled,
      selectable: item.selectable,
      checkable: item.checkable,
      value,
      label,
      isLeaf,
      children,
      hasChildren,
      level,
      indexPath: [...indexPath, value]
    };

    if (!nodeList.get(value)) {
      // Object.assign
      copy = Object.assign({}, newItem);
      copy.isExpanded = ref(false);
      copy.isIndeterminate = ref(false);
      copy.isChecked = ref(false);
    } else {
      copy = nodeList.get(value);
      Object.assign(copy, newItem);
    }

    copy.uid = getUid();
    return copy;
  };

  const flatNodes = function () {
    let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let indexPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    let level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    return nodes.reduce((res, node) => {
      const copy = transformNode(node, indexPath, level); // 

      nodeList.set(copy.value, copy);
      res.push(copy.value);
      children.push(copy);

      if (copy.hasChildren) {
        const children = [];
        const keys = flatNodes(copy.children, children, copy.indexPath, level + 1);
        copy.children = children;
        copy.childrenPath = keys; // Array.concat

        concat(res, keys);
      }

      return res;
    }, []);
  };

  watch([() => props.data], () => {
    allKeys.value = flatNodes(props.data);
  }, {
    immediate: true,
    deep: true
  });
  return {
    nodeList,
    allKeys
  };
});

var useState$1 = (_ref => {
  let {
    props,
    emit
  } = _ref;
  const [currentExpandedKeys, updateExpandedKeys] = useNormalModel(props, emit, {
    prop: 'expandedKeys'
  });
  const [currentCheckedKeys, updateCheckedKeys] = useNormalModel(props, emit, {
    prop: 'checkedKeys'
  });
  const [currentSelectedKeys, updateSelectedKeys] = useNormalModel(props, emit, {
    prop: 'selectedKeys'
  });

  const hasSelected = value => currentSelectedKeys.value.includes(value);

  return {
    currentExpandedKeys,
    updateExpandedKeys,
    currentCheckedKeys,
    updateCheckedKeys,
    currentSelectedKeys,
    updateSelectedKeys,
    hasSelected
  };
});

function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$o = getPrefixCls('tree-node');
var useDrag = (_ref => {
  let {
    nodeList,
    emit,
    expandNode
  } = _ref;
  let dragNode;
  let overBeginTimeMap = {};
  const dragOverInfo = ref();
  let timer;
  onUnmounted(() => {
    if (timer) {
      clearTimeout(timer);
    }
  });

  function resetDragState() {
    dragNode = null;
    overBeginTimeMap = {};
    dragOverInfo.value = null;
  }

  const handleDragstart = (value, event) => {
    const node = nodeList.get(value);
    dragNode = node;
    emit('dragstart', {
      node,
      event
    });
  };

  const handleDragend = (value, event) => {
    resetDragState();
    const node = nodeList.get(value);
    emit('dragend', {
      node,
      event
    });
  };

  function getTargetNode(value) {
    if (!dragNode) return;
    const node = nodeList.get(value);
    if (!node) return;
    if (node.indexPath.includes(dragNode.value)) return;
    return node;
  }

  const handleDragenter = (value, event) => {
    const node = getTargetNode(value);
    if (!node) return;
    emit('dragenter', {
      node,
      event
    });
  };

  const handleDragleave = (value, event) => {
    const node = getTargetNode(value);
    if (!node) return;
    emit('dragleave', {
      node,
      event
    });
  };

  const handleDragover = (value, event) => {
    event.preventDefault();
    const node = getTargetNode(value);

    if (!node) {
      dragOverInfo.value = null;
      return;
    }

    emit('dragover', {
      node,
      event
    }); // 1s

    if (!overBeginTimeMap[value]) {
      overBeginTimeMap[value] = Date.now();
    } else {
      if (Date.now() - overBeginTimeMap[value] > 1000 && node.hasChildren && !node.isExpanded.value) {
        expandNode(value, event);
      }
    }

    const targetNodeEl = document.querySelector(`.${prefixCls$o}[data-value='${value}']`); // 

    const {
      height: targetElOffsetHeight
    } = targetNodeEl.getBoundingClientRect();
    let mousePosition;
    const targeEl = event.currentTarget; // 

    const {
      top: elClientTop
    } = targeEl.getBoundingClientRect();
    const eventOffsetY = event.clientY - elClientTop;

    if (eventOffsetY <= targetElOffsetHeight / 2) {
      mousePosition = 'before';
    } else {
      mousePosition = 'after';
    }

    dragOverInfo.value = {
      node: node,
      position: mousePosition
    }; // 300

    if (timer) {
      clearTimeout(timer);
    }

    timer = setTimeout(() => {
      var _dragOverInfo$value;

      if (((_dragOverInfo$value = dragOverInfo.value) === null || _dragOverInfo$value === void 0 ? void 0 : _dragOverInfo$value.node) === node) {
        dragOverInfo.value = null;
      }
    }, 300);
  };

  const handleDrop = (value, event) => {
    const node = getTargetNode(value);
    if (!node) return;

    if (!dragOverInfo.value) {
      return;
    }

    emit('drop', _objectSpread$c(_objectSpread$c({}, dragOverInfo.value), {}, {
      dragNode,
      event
    }));
  };

  return {
    handleDragstart,
    handleDragenter,
    handleDragover,
    handleDragleave,
    handleDragend,
    handleDrop,
    dragOverInfo
  };
});

var useFilter = ((props, allKeys, nodeList) => {
  const filteredKeys = ref([]);
  const filteredExpandedKeys = ref([]);
  const isSearchingRef = ref(false);

  function traverse(filterMethod, filterText) {
    const _filteredExpandedKeys = [];
    const _filteredKeys = [];

    const _filteredExpandedKeysMap = new Map();

    const _filteredKeysMap = new Map();

    allKeys.value.forEach(key => {
      const node = nodeList.get(key);

      if (filterMethod(filterText, node)) {
        const parentKeys = node.indexPath;
        parentKeys.forEach(_key => {
          if (!_filteredExpandedKeysMap.get(_key)) {
            _filteredExpandedKeys.push(_key);

            _filteredExpandedKeysMap.set(_key, true);
          }

          if (!_filteredKeysMap.get(_key)) {
            _filteredKeys.push(_key);

            _filteredKeysMap.set(_key, true);
          }
        });
      }
    });

    _filteredExpandedKeysMap.clear();

    _filteredKeysMap.clear();

    return [_filteredExpandedKeys, _filteredKeys];
  }

  const filter = filterText => {
    const filterMethod = props.filterMethod;

    if (!isFunction(filterMethod)) {
      return;
    }

    if (filterText) {
      const [_filteredExpandedKeys, _filteredKeys] = traverse(filterMethod, filterText);
      filteredExpandedKeys.value = _filteredExpandedKeys;
      filteredKeys.value = _filteredKeys;
    } else {
      filteredExpandedKeys.value = [];
      filteredKeys.value = [];
    }

    isSearchingRef.value = filterText ? true : false;
  };

  return {
    filteredKeys,
    filteredExpandedKeys,
    filter,
    isSearchingRef
  };
});

const getChildrenByValues = function (nodeList) {
  let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const arr = [...values];
  values.forEach(value => {
    const node = nodeList.get(value);

    if (node.hasChildren) {
      // Array.concat
      concat(arr, node.childrenPath);
    }
  });
  return arr;
};
const getParentByValues = function (nodeList) {
  let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const res = {};
  values.forEach(value => {
    const node = nodeList.get(value);

    if (!res[node.level]) {
      res[node.level] = [];
    }

    res[node.level].push(node.value);
  });
  const levels = Object.keys(res).map(key => Number(key));
  const maxLevel = levels[levels.length - 1];

  for (let level = maxLevel; level > 0; level--) {
    const levelValues = res[level];

    if (levelValues) {
      levelValues.forEach(value => {
        const node = nodeList.get(value);
        const parentValue = node.indexPath[node.indexPath.length - 2];

        if (parentValue) {
          const parentNode = nodeList.get(parentValue);

          if (parentNode.children.every(child => levelValues.includes(child.value))) {
            if (!res[level - 1]) {
              res[level - 1] = [];
            }

            if (!res[level - 1].includes(parentValue)) {
              res[level - 1].push(parentValue);
            }
          }
        }
      });
    }
  }

  const arr = [];
  Object.values(res).forEach(levelValues => {
    // Array.concat
    concat(arr, levelValues);
  });
  return arr;
};
const getBrotherKeys = (node, props, nodeList) => {
  var _nodeList$get;

  const parentNode = node.indexPath[node.indexPath.length - 2];
  const arr = [];
  (parentNode ? ((_nodeList$get = nodeList.get(parentNode)) === null || _nodeList$get === void 0 ? void 0 : _nodeList$get.children) || [] : props.data).forEach(item => {
    const value = item[props.valueField];

    if (value !== node.value) {
      arr.push(value);
    }
  });
  return arr;
};

var useExpand = (_ref => {
  let {
    isSearchingRef,
    filteredExpandedKeys,
    nodeList,
    currentExpandedKeys,
    updateExpandedKeys,
    props,
    emit,
    allKeys
  } = _ref;
  const expandingNode = shallowRef(null);

  const expandNode = (val, event) => {
    if (isSearchingRef.value) {
      const _value = cloneDeep(filteredExpandedKeys.value);

      const index = _value.indexOf(val); // 


      if (index !== -1) {
        _value.splice(index, 1);
      } else {
        _value.push(val);
      }

      filteredExpandedKeys.value = _value;
      return;
    }

    const node = nodeList.get(val);
    expandingNode.value = node;
    let values = cloneDeep(currentExpandedKeys.value);
    const index = values.indexOf(val); // 

    if (index !== -1) {
      values.splice(index, 1); // 

      node.isExpanded.value = false;
    } else {
      if (props.accordion) {
        const brotherKeys = getBrotherKeys(node, props, nodeList);
        values = values.filter(item => !brotherKeys.includes(item));
      }

      values.push(val); // 

      node.isExpanded.value = true;
    }

    updateExpandedKeys(values);
    emit('expand', {
      expandedKeys: values,
      event,
      node,
      expanded: values.includes(val)
    });
  };

  onMounted(() => {
    if (props.defaultExpandAll && currentExpandedKeys.value.length === 0) {
      updateExpandedKeys(allKeys.value.filter(value => !nodeList.get(value).isLeaf));
    }
  });
  return {
    expandNode,
    expandingNode
  };
});

var useSelect = (_ref => {
  let {
    nodeList,
    currentSelectedKeys,
    updateSelectedKeys,
    props,
    emit
  } = _ref;

  const selectNode = (val, event) => {
    if (!props.selectable) {
      return;
    }

    const node = nodeList.get(val);
    const values = cloneDeep(currentSelectedKeys.value);
    const index = values.indexOf(val);

    if (props.multiple) {
      if (index !== -1) {
        props.cancelable && values.splice(index, 1);
      } else {
        values.push(val);
      }
    } else if (index !== -1) {
      props.cancelable && values.splice(index, 1);
    } else {
      values[0] = val;
    }

    updateSelectedKeys(values);
    emit('select', {
      selectedKeys: values,
      event,
      node,
      selected: values.includes(val)
    });
  };

  return {
    selectNode
  };
});

var useCheck = (_ref => {
  let {
    allKeys,
    nodeList,
    currentCheckedKeys,
    updateCheckedKeys,
    props,
    emit
  } = _ref;

  function computeIndeterminate(node) {
    if (node.hasChildren) {
      if (node.isChecked.value) {
        node.isIndeterminate.value = false;
      } else {
        node.isIndeterminate.value = node.children.some(item => item.isChecked.value || item.isIndeterminate.value);
      }
    } else {
      node.isIndeterminate.value = false;
    }
  }

  function init() {
    if (props.checkable) {
      if (!props.cascade) {
        return currentCheckedKeys.value;
      }

      if (props.checkStrictly === CHECK_STRATEGY$1.ALL) {
        return currentCheckedKeys.value;
      }

      if (props.checkStrictly === CHECK_STRATEGY$1.PARENT) {
        return getChildrenByValues(nodeList, currentCheckedKeys.value);
      }

      if (props.checkStrictly === CHECK_STRATEGY$1.CHILD) {
        return getParentByValues(nodeList, currentCheckedKeys.value);
      }

      return currentCheckedKeys.value;
    }

    return [];
  }

  const _keys = shallowRef([]);

  let unwatch = false;
  let unwatchCurrent = false;
  watch(currentCheckedKeys, () => {
    if (!props.checkable) return;

    if (unwatchCurrent) {
      unwatchCurrent = false;
      return;
    }

    _keys.value = init();
  }, {
    immediate: true,
    deep: true
  });
  watch(_keys, (newKeys, oldKeys) => {
    if (!props.checkable) return;

    if (unwatch) {
      unwatch = false;
      return;
    } // 


    Array.isArray(oldKeys) && oldKeys.forEach(key => {
      const node = nodeList.get(key);
      node.isChecked.value = false;
    });
    newKeys.forEach(key => {
      const node = nodeList.get(key);
      node.isChecked.value = true;
    });

    if (props.cascade) {
      allKeys.value.slice(0).reverse().forEach(key => {
        const node = nodeList.get(key);
        computeIndeterminate(node);
      });
    }
  }, {
    immediate: true
  });

  const computeCheckedKeys = (_values, node) => {
    const {
      hasChildren,
      childrenPath,
      indexPath,
      isChecked,
      value
    } = node;

    if (isChecked.value) {
      if (hasChildren) {
        childrenPath.forEach(key => {
          const childNode = nodeList.get(key);

          if (childNode.isChecked.value) {
            childNode.isChecked.value = false;

            const index = _values.indexOf(childNode.value);

            _values.splice(index, 1);
          }

          childNode.isIndeterminate.value = false;
        });
      }

      let len = indexPath.length - 1;

      for (len; len >= 0; len--) {
        const parentNode = nodeList.get(indexPath[len]);

        if (parentNode.isChecked.value) {
          parentNode.isChecked.value = false;

          const index = _values.indexOf(parentNode.value);

          _values.splice(index, 1);
        }

        computeIndeterminate(parentNode);
      }
    } else {
      if (hasChildren) {
        childrenPath.forEach(key => {
          const childNode = nodeList.get(key);

          if (!childNode.isChecked.value) {
            childNode.isChecked.value = true;

            _values.push(childNode.value);
          }

          childNode.isIndeterminate.value = false;
        });
      } // 


      _values.push(value);

      node.isChecked.value = true;
      computeIndeterminate(node);
      let len = indexPath.length - 2;

      for (len; len >= 0; len--) {
        const parentNode = nodeList.get(indexPath[len]);

        if (parentNode.children.every(childNode => childNode.isChecked.value)) {
          parentNode.isChecked.value = true;

          _values.push(parentNode.value);
        }

        computeIndeterminate(parentNode);
      }
    }
  };

  const checkNode = (val, event) => {
    const node = nodeList.get(val);
    unwatch = true;
    unwatchCurrent = true;

    const _values = cloneDeep(_keys.value);

    let values;

    if (!props.cascade) {
      // 
      const index = _values.indexOf(val);

      if (node.isChecked.value) {
        _values.splice(index, 1);
      } else {
        _values.push(val);
      }

      values = _values;
    } else {
      if (props.checkStrictly === CHECK_STRATEGY$1.ALL) {
        computeCheckedKeys(_values, node);
        values = _values;
      } else if (props.checkStrictly === CHECK_STRATEGY$1.PARENT) {
        computeCheckedKeys(_values, node);
        values = _values.filter(key => {
          const node = nodeList.get(key);
          return node.indexPath.filter(path => {
            const parenNode = nodeList.get(path);
            return parenNode.isChecked.value;
          }).length === 1;
        });
      } else if (props.checkStrictly === CHECK_STRATEGY$1.CHILD) {
        computeCheckedKeys(_values, node);
        values = _values.filter(key => {
          const node = nodeList.get(key);
          return node.isLeaf;
        });
      } else {
        computeCheckedKeys(_values, node);
        values = _values;
      }
    }

    _keys.value = _values;
    updateCheckedKeys(values);
    emit('check', {
      checkedKeys: values,
      event,
      node,
      checked: node.isChecked.value
    });
  };

  return {
    checkNode
  };
});

var useCurrentData = (_ref => {
  let {
    props,
    isSearchingRef,
    filteredExpandedKeys,
    currentExpandedKeys,
    filteredKeys,
    allKeys,
    expandingNode,
    nodeList
  } = _ref;
  const currentData = ref([]);

  const _addNode = function (nodes) {
    let res = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    nodes.forEach(node => {
      res.push(node.value);

      if (node.hasChildren && node.isExpanded.value) {
        _addNode(node.children, res);
      }
    });
  };

  const addNode = (nodes, index) => {
    const res = [];

    _addNode(nodes, res);

    const arr1 = currentData.value.slice(0, index);
    const arr2 = currentData.value.slice(index);
    concat(arr1, res);
    concat(arr1, arr2);
    currentData.value = arr1;
  };

  const deleteNode = (keys, index) => {
    let len = 0;
    keys.forEach(key => {
      if (key === currentData.value[index + len]) {
        len += 1;
      }
    });
    currentData.value.splice(index, len);
  };

  const computeCurrentData = () => {
    const res = [];
    const expandedKeys = isSearchingRef.value ? filteredExpandedKeys.value : currentExpandedKeys.value;
    const keys = isSearchingRef.value ? filteredKeys.value : allKeys.value;

    if (expandingNode.value) {
      const node = expandingNode.value; // 

      if (node.isExpanded.value) {
        if (props.accordion) {
          const brotherKeys = getBrotherKeys(node, props, nodeList);
          brotherKeys.forEach(key => {
            const brotherNode = nodeList.get(key);

            if (brotherNode.isExpanded.value) {
              const index = currentData.value.indexOf(brotherNode.value);
              deleteNode(brotherNode.childrenPath, index + 1);
              brotherNode.isExpanded.value = false;
            }
          });
        }

        const index = currentData.value.indexOf(node.value);
        addNode(node.children, index + 1);
      } else {
        const index = currentData.value.indexOf(node.value);
        deleteNode(node.childrenPath, index + 1);
      }

      expandingNode.value = null;
      return;
    } // 


    keys.forEach(key => {
      const node = nodeList.get(key);

      if (node.hasChildren) {
        node.isExpanded.value = expandedKeys.includes(key);
      }

      const indexPath = node.indexPath;
      const len = indexPath.length;
      let index = 0;
      let parentExpanded = true;

      while (index < len - 1) {
        const parentNode = nodeList.get(indexPath[index]);

        if (!parentNode.isExpanded.value) {
          parentExpanded = false;
          break;
        }

        index += 1;
      }

      if (parentExpanded) {
        res.push(key);
      }
    });
    currentData.value = res;
  };

  watch([filteredExpandedKeys, filteredKeys], debounce(() => {
    if (!isSearchingRef.value) return;
    computeCurrentData();
  }, 10)); // currentExpandedKeys deep watch

  watch([currentExpandedKeys, allKeys], debounce(() => {
    if (isSearchingRef.value) return;
    computeCurrentData();
  }, 10), {
    immediate: true,
    deep: true
  });
  watch([isSearchingRef], () => {
    computeCurrentData();
  });
  return {
    currentData
  };
});

function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$n = getPrefixCls('tree');
var Tree = defineComponent({
  name: COMPONENT_NAME$2.TREE,
  props: _objectSpread$b({}, treeProps),
  emits: ['update:expandedKeys', 'update:checkedKeys', 'update:selectedKeys', 'update:nodeList', 'check', 'expand', 'load', 'select', 'dragstart', 'dragenter', 'dragover', 'dragleave', 'dragend', 'drop'],

  setup(props, _ref) {
    let {
      emit,
      expose
    } = _ref;
    useTheme();
    const {
      nodeList,
      allKeys
    } = useData$1({
      props,
      emit
    });
    const {
      currentExpandedKeys,
      updateExpandedKeys,
      currentCheckedKeys,
      updateCheckedKeys,
      currentSelectedKeys,
      updateSelectedKeys,
      hasSelected
    } = useState$1({
      props,
      emit
    });
    const {
      filter,
      filteredExpandedKeys,
      filteredKeys,
      isSearchingRef
    } = useFilter(props, allKeys, nodeList);
    const {
      expandNode,
      expandingNode
    } = useExpand({
      allKeys,
      isSearchingRef,
      filteredExpandedKeys,
      nodeList,
      currentExpandedKeys,
      updateExpandedKeys,
      props,
      emit
    });
    const {
      selectNode
    } = useSelect({
      nodeList,
      currentSelectedKeys,
      updateSelectedKeys,
      props,
      emit
    });
    const {
      checkNode
    } = useCheck({
      allKeys,
      nodeList,
      currentCheckedKeys,
      updateCheckedKeys,
      props,
      emit
    });
    const {
      currentData
    } = useCurrentData({
      props,
      isSearchingRef,
      filteredExpandedKeys,
      currentExpandedKeys,
      filteredKeys,
      allKeys,
      expandingNode,
      nodeList
    });
    const {
      handleDragstart,
      handleDragenter,
      handleDragover,
      handleDragleave,
      handleDragend,
      handleDrop,
      dragOverInfo
    } = useDrag({
      nodeList,
      emit,
      expandNode
    });

    if (expose) {
      expose({
        selectNode,
        expandNode,
        checkNode,
        filter
      });
    }

    provide(TREE_PROVIDE_KEY, {
      props,
      selectNode,
      expandNode,
      checkNode,
      hasSelected,
      nodeList,
      handleDragstart,
      handleDragenter,
      handleDragover,
      handleDragleave,
      handleDragend,
      handleDrop,
      dragOverInfo
    });

    const renderNode = value => {
      const node = nodeList.get(value);
      const itemSlots = {};

      if (isFunction(node.prefix)) {
        itemSlots.prefix = node.prefix;
      }

      if (isString$1(node.prefix)) {
        itemSlots.prefix = () => node.prefix;
      }

      if (isFunction(node.suffix)) {
        itemSlots.suffix = node.suffix;
      }

      if (isString$1(node.suffix)) {
        itemSlots.suffix = () => node.suffix;
      }

      return createVNode(TreeNode, {
        "key": node.uid,
        "level": node.level,
        "value": node.value,
        "label": node.label,
        "disabled": node.disabled,
        "selectable": node.selectable,
        "checkable": node.checkable,
        "isLeaf": node.isLeaf,
        "draggable": props.draggable && !props.inline && !node.disabled
      }, itemSlots);
    };

    const renderChildren = arr => arr.map(value => renderNode(value));

    const renderDefault = _ref2 => {
      let {
        source
      } = _ref2;
      return renderNode(source);
    };

    return () => props.virtualList && !props.inline ? createVNode(VirtualList, {
      "dataSources": currentData.value,
      "dataKey": source => {
        return source;
      },
      "estimateSize": 32,
      "keeps": 14,
      "observeResize": false,
      "class": prefixCls$n
    }, {
      default: renderDefault
    }) : createVNode("div", {
      "class": prefixCls$n,
      "role": "tree"
    }, [renderChildren(currentData.value)]);
  }

});

const FTree = withInstall(Tree);

const key = Symbol('FUpload');

const _hoisted_1$3 = ["name", "multiple", "accept"];
var script$a = /*#__PURE__*/defineComponent({
  __name: 'trigger',

  setup(__props) {
    const {
      name,
      multiple,
      accept,
      disabled,
      prefixCls,
      onUploadFiles,
      inputRef
    } = inject(key);
    const acceptStr = computed(() => accept.value.join(','));

    const handleClick = () => {
      if (disabled.value) return;
      inputRef.value.click();
    };

    const handleChange = e => {
      const files = e.target.files;
      if (!files) return;
      onUploadFiles(files);
    };

    const {
      t
    } = useLocale();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(prefixCls)),
        onClick: handleClick
      }, [renderSlot(_ctx.$slots, "default", {}, () => [createVNode(unref(FButton$1), {
        class: normalizeClass(`${unref(prefixCls)}-trigger-default`),
        disabled: unref(disabled)
      }, {
        icon: withCtx(() => [createVNode(unref(UploadOutlined))]),
        default: withCtx(() => [createTextVNode(" " + toDisplayString(unref(t)('upload.btnText')), 1
        /* TEXT */
        )]),
        _: 1
        /* STABLE */

      }, 8
      /* PROPS */
      , ["class", "disabled"])]), createElementVNode("input", {
        ref_key: "inputRef",
        ref: inputRef,
        class: normalizeClass(`${unref(prefixCls)}-input`),
        type: "file",
        name: unref(name),
        multiple: unref(multiple),
        accept: unref(acceptStr),
        onChange: handleChange
      }, null, 42
      /* CLASS, PROPS, HYDRATE_EVENTS */
      , _hoisted_1$3)], 2
      /* CLASS */
      );
    };
  }

});

script$a.__file = "components/upload/trigger.vue";

var script$9 = /*#__PURE__*/defineComponent({
  __name: 'fileList',

  setup(__props) {
    const {
      disabled,
      prefixCls,
      uploadFiles,
      onRemove
    } = inject(key);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(`${unref(prefixCls)}-list`)
      }, [(openBlock(true), createElementBlock(Fragment, null, renderList(unref(uploadFiles), file => {
        return openBlock(), createElementBlock("div", {
          key: file.uid,
          class: normalizeClass([`${unref(prefixCls)}-list-item`, `is-${file.status}`])
        }, [createElementVNode("div", {
          class: normalizeClass(`${unref(prefixCls)}-list-name-wrapper`)
        }, [renderSlot(_ctx.$slots, "file", {
          file: file
        }, () => [createVNode(unref(FileOutlined)), createElementVNode("div", {
          class: normalizeClass(`${unref(prefixCls)}-list-name`)
        }, toDisplayString(file.name), 3
        /* TEXT, CLASS */
        )]), file.status === 'uploading' ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(`${unref(prefixCls)}-list-progress`)
        }, [createElementVNode("span", {
          class: normalizeClass(`${unref(prefixCls)}-list-progress-inner`),
          style: normalizeStyle({
            width: file.percentage + '%'
          })
        }, null, 6
        /* CLASS, STYLE */
        )], 2
        /* CLASS */
        )) : createCommentVNode("v-if", true)], 2
        /* CLASS */
        ), createElementVNode("div", {
          class: normalizeClass(`${unref(prefixCls)}-list-icons`)
        }, [!unref(disabled) ? (openBlock(), createBlock(unref(CloseCircleFilled), {
          key: 0,
          class: normalizeClass(`${unref(prefixCls)}-list-icons-close`),
          onClick: $event => unref(onRemove)(null, file)
        }, null, 8
        /* PROPS */
        , ["class", "onClick"])) : createCommentVNode("v-if", true)], 2
        /* CLASS */
        )], 2
        /* CLASS */
        );
      }), 128
      /* KEYED_FRAGMENT */
      ))], 2
      /* CLASS */
      );
    };
  }

});

script$9.__file = "components/upload/fileList.vue";

function getError(action, option, xhr) {
  let msg;

  if (xhr.response) {
    msg = `${xhr.response.error || xhr.response}`;
  } else if (xhr.responseText) {
    msg = `${xhr.responseText}`;
  } else {
    msg = `fail to post ${action} ${xhr.status}`;
  }

  const err = new Error(msg);
  err.status = xhr.status;
  err.method = 'post';
  err.url = action;
  return err;
}

function getBody(xhr) {
  const text = xhr.responseText || xhr.response;

  if (!text) {
    return text;
  }

  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}

function upload(option) {
  if (typeof XMLHttpRequest === 'undefined') {
    return;
  }

  const xhr = new XMLHttpRequest();
  const action = option.action;

  if (xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }

      option.onProgress(e);
    };
  }

  const formData = new FormData();

  if (option.data) {
    Object.keys(option.data).forEach(key => {
      formData.append(key, option.data[key]);
    });
  }

  formData.append(option.fileName, option.file, option.file.name);

  xhr.onerror = function error() {
    option.onError(getError(action, option, xhr));
  };

  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(action, option, xhr));
    }

    if (option.transformResponse) {
      try {
        option.onSuccess(option.transformResponse(xhr));
      } catch (e) {
        const msg = (e === null || e === void 0 ? void 0 : e.message) || `fail to post ${action} ${xhr.status}`;
        const err = new Error(msg);
        err.status = xhr.status;
        err.method = 'post';
        err.url = action;
        option.onError(err);
      }
    } else {
      option.onSuccess(getBody(xhr));
    }
  };

  xhr.open('post', action, true); // eslint-disable-next-line no-restricted-syntax

  if (option.withCredentials && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }

  if (option.timeout) {
    xhr.timeout = option.timeout;
  }

  const headers = option.headers || {};
  Object.keys(headers).forEach(item => {
    if (hasOwn(headers, item) && headers[item] !== null) {
      xhr.setRequestHeader(item, headers[item]);
    }
  });
  xhr.send(formData);
  return xhr;
}

function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$m = getPrefixCls('upload');

function genUid(seed) {
  return Date.now() + seed;
}

function getFile(rawFile, uploadFiles) {
  return uploadFiles.find(file => file.uid === rawFile.uid);
}

var useUpload = ((props, emit) => {
  const isDragger = ref(false);
  const inputRef = ref();
  const uploadFiles = ref([]);
  const requestList = ref({});
  let cachedFiles = [];
  let tempIndex = 1;

  function initFile(rawFile) {
    const uid = genUid(tempIndex++);
    rawFile.uid = uid;
    const file = {
      name: rawFile.name,
      percentage: 0,
      status: 'ready',
      size: rawFile.size,
      raw: rawFile,
      uid,
      url: ''
    };
    return file;
  }

  function abort(file) {
    const _requestList = requestList.value;

    if (file) {
      const uid = file.uid;

      if (_requestList[uid]) {
        _requestList[uid].abort();
      }
    } else {
      Object.keys(_requestList).forEach(uid => {
        const _uid = uid;
        if (_requestList[_uid]) _requestList[_uid].abort();
        delete _requestList[_uid];
      });
    }
  }

  function onStart(rawFile) {
    const file = initFile(rawFile);

    if (props.listType === 'picture-card') {
      try {
        file.url = URL.createObjectURL(rawFile);
      } catch (error) {
        console.error('[Upload]', error);
        emit('error', {
          error,
          file,
          fileList: uploadFiles.value
        });
      }
    }

    uploadFiles.value.push(file);
    emit('change', {
      file,
      fileList: uploadFiles.value
    });
  }

  function onExceed(files) {
    emit('exceed', {
      files,
      fileList: uploadFiles.value
    });
  }

  function onProgress(_ref) {
    let {
      event,
      rawFile
    } = _ref;
    const file = getFile(rawFile, uploadFiles.value);

    if (!file) {
      return;
    }

    file.status = 'uploading';
    file.percentage = event.percent || 0;
    emit('progress', {
      event,
      file,
      fileList: uploadFiles.value
    });
  }

  function onSuccess(_ref2) {
    let {
      response,
      rawFile
    } = _ref2;
    const file = getFile(rawFile, uploadFiles.value);
    if (!file) return;
    file.status = 'success';
    file.response = response;
    emit('success', {
      response,
      file,
      fileList: uploadFiles.value
    });
    emit('change', {
      file,
      fileList: uploadFiles.value
    });
  }

  function onError(_ref3) {
    let {
      error,
      rawFile
    } = _ref3;
    const uploadFilesValue = uploadFiles.value;
    const file = getFile(rawFile, uploadFilesValue);
    if (!file) return;
    file.status = 'error';
    emit('error', {
      error,
      file,
      fileList: uploadFilesValue
    });
    emit('change', {
      file,
      fileList: uploadFilesValue
    });
  }

  function onRemove(rawFile, file) {
    const uploadFilesValue = uploadFiles.value;
    file = file || getFile(rawFile, uploadFilesValue);

    if (!file) {
      return;
    }

    const doRemove = () => {
      abort(file);
      uploadFilesValue.splice(uploadFilesValue.indexOf(file), 1);
      emit('remove', {
        file,
        fileList: uploadFilesValue
      });
      emit('change', {
        file,
        fileList: uploadFilesValue
      });
    };

    if (!props.beforeRemove) {
      return doRemove();
    }

    if (isFunction(props.beforeRemove)) {
      const before = props.beforeRemove(file, uploadFilesValue);

      if (before instanceof Promise) {
        before.then(() => {
          doRemove();
        }).catch(noop$1);
      } else if (before !== false) {
        doRemove();
      }
    }
  }

  const post = rawFile => {
    if (!props.action) {
      onRemove(rawFile);
      console.error('[FUpload] action');
      return;
    }

    const {
      uid
    } = rawFile;
    const options = {
      headers: props.headers,
      withCredentials: props.withCredentials,
      data: props.data,
      file: rawFile,
      fileName: props.name,
      action: props.action,
      timeout: props.timeout,
      transformResponse: props.transformResponse,
      onProgress: e => {
        onProgress({
          event: e,
          rawFile
        });
      },
      onSuccess: res => {
        onSuccess({
          response: res,
          rawFile
        });
        delete requestList.value[uid];
      },
      onError: err => {
        onError({
          error: err,
          rawFile
        });
        delete requestList.value[uid];
      }
    };
    const req = props.httpRequest(options);
    requestList.value[uid] = req;

    if (req instanceof Promise) {
      req.then(options.onSuccess, options.onError);
    }
  };

  const upload = async rawFile => {
    inputRef.value.value = null;

    if (!props.beforeUpload) {
      return post(rawFile);
    }

    try {
      let processedFile = await props.beforeUpload(rawFile);

      if (processedFile === false) {
        return onRemove(rawFile);
      }

      const fileType = Object.prototype.toString.call(processedFile);

      if (fileType === '[object File]' || fileType === '[object Blob]') {
        if (fileType === '[object Blob]') {
          processedFile = new File([processedFile], rawFile.name, {
            type: rawFile.type
          });
        }

        Object.keys(rawFile).forEach(p => {
          if (hasOwn(rawFile, p)) {
            processedFile[p] = rawFile[p];
          }
        });
        post(processedFile);
      } else {
        post(rawFile);
      }
    } catch (e) {
      onRemove(rawFile);
    }
  };

  const onUploadFiles = files => {
    files = Array.from(files);

    if (props.multipleLimit && props.fileList.length + files.length > props.multipleLimit) {
      onExceed(files);
      return;
    }

    let postFiles = files;

    if (!props.multiple) {
      postFiles = postFiles.slice(0, 1);
    }

    if (postFiles.length === 0) {
      return;
    }

    postFiles.forEach(rawFile => {
      onStart(rawFile);
      upload(rawFile);
    });
  }; // disabled


  const {
    isFormDisabled
  } = useFormAdaptor();
  provide(key, _objectSpread$a(_objectSpread$a({}, toRefs(props)), {}, {
    disabled: computed(() => {
      return props.disabled || isFormDisabled.value;
    }),
    prefixCls: prefixCls$m,
    uploadFiles,
    onRemove,
    onUploadFiles,
    inputRef,
    isDragger
  }));
  watch(() => props.fileList, fileList => {
    if (!isEqual(cachedFiles, fileList)) {
      cachedFiles = [];
      uploadFiles.value = fileList.map(file => {
        const cloneFile = cloneDeep(file);
        cachedFiles.push(cloneFile);
        return _objectSpread$a(_objectSpread$a({}, cloneFile), {}, {
          uid: file.uid || genUid(tempIndex++),
          status: file.status || 'success'
        });
      });
    }
  }, {
    immediate: true,
    deep: true
  });
  return {
    uploadFiles,
    isDragger
  };
});

const uploadProps = {
  accept: {
    type: Array,
    default: () => []
  },
  action: String,
  headers: {
    type: Object,
    default: () => ({})
  },
  data: {
    type: Object,
    default: () => ({})
  },
  withCredentials: {
    type: Boolean,
    default: false
  },
  timeout: {
    type: Number
  },
  beforeUpload: Function,
  beforeRemove: Function,
  disabled: {
    type: Boolean,
    default: false
  },
  fileList: {
    type: Array,
    default: () => []
  },
  listType: {
    type: String,
    default: 'text'
  },
  multiple: {
    type: Boolean,
    default: false
  },
  multipleLimit: Number,
  name: {
    type: String,
    default: 'file'
  },
  showFileList: {
    type: Boolean,
    default: true
  },
  httpRequest: {
    type: Function,
    default: upload
  },
  transformResponse: Function
};
var Upload = defineComponent({
  name: 'FUpload',
  props: uploadProps,
  emits: ['change', 'remove', 'success', 'error', 'progress', 'exceed'],

  setup(props, ctx) {
    useTheme();
    const {
      uploadFiles,
      isDragger
    } = useUpload(props, ctx.emit);

    const getFileList = () => {
      if (!props.showFileList) {
        return null;
      }

      const fileListSlots = ctx.slots.fileList;

      if (!fileListSlots) {
        const file = ctx.slots.file;
        return createVNode(script$9, null, {
          file
        });
      }

      return fileListSlots({
        uploadFiles: uploadFiles.value
      });
    };

    return () => {
      var _ctx$slots$default, _ctx$slots, _ctx$slots$tip, _ctx$slots2;

      return createVNode(Fragment, null, [ctx.slots.default ? createVNode(script$a, {
        "class": isDragger.value && 'is-dragger'
      }, {
        default: () => [(_ctx$slots$default = (_ctx$slots = ctx.slots).default) === null || _ctx$slots$default === void 0 ? void 0 : _ctx$slots$default.call(_ctx$slots, {
          uploadFiles: uploadFiles.value
        })]
      }) : createVNode(script$a, {
        "class": isDragger.value && 'is-dragger'
      }, null), (_ctx$slots$tip = (_ctx$slots2 = ctx.slots).tip) === null || _ctx$slots$tip === void 0 ? void 0 : _ctx$slots$tip.call(_ctx$slots2), getFileList()]);
    };
  }

});

/**
 * This is a rather simple version. I may fix it later to make it more accurate.
 * I've looked at https://github.com/broofa/mime, however it doesn't has a esm
 * version, so I can't simply use it.
 */
function matchType(name, mimeType, accept) {
  name = name.toLowerCase();
  mimeType = mimeType.toLocaleLowerCase();
  const acceptAtoms = accept.map(acceptAtom => acceptAtom.trim()).filter(Boolean);
  return acceptAtoms.some(acceptAtom => {
    if (acceptAtom.startsWith('.')) {
      // suffix
      if (name.endsWith(acceptAtom)) return true;
    } else if (acceptAtom.includes('/')) {
      // mime type
      const [type, subtype] = mimeType.split('/');
      const [acceptType, acceptSubtype] = acceptAtom.split('/');

      if (acceptType === '*' || type && acceptType && acceptType === type) {
        if (acceptSubtype === '*' || subtype && acceptSubtype && acceptSubtype === subtype) {
          return true;
        }
      }
    } else {
      // invalid type
      return true;
    }

    return false;
  });
}

const uploadDraggerProps = {
  onFileTypeInvalid: {
    type: Function
  }
};
var UploadDragger = defineComponent({
  name: 'FUploadDragger',
  props: uploadDraggerProps,
  emits: [],

  setup(props, ctx) {
    useTheme();
    const {
      t
    } = useLocale();
    const {
      prefixCls,
      onUploadFiles,
      isDragger,
      accept,
      multiple,
      disabled // disabled 

    } = inject(key);
    isDragger.value = true;
    const isHovering = ref(false);
    const classList = computed(() => {
      return [`${prefixCls}-dragger`, isHovering.value && 'is-hovering', disabled.value && 'is-disabled'].filter(Boolean);
    });

    const handleEnter = event => {
      if (disabled.value) return; // 

      event.preventDefault();
      isHovering.value = true;
    };

    const handleLeave = event => {
      if (disabled.value) return; // 

      event.preventDefault();
      isHovering.value = false;
    };

    const handleOver = event => {
      if (disabled.value) return; // 

      event.preventDefault();
    };

    const handleDrop = event => {
      if (disabled.value) return; // 

      event.preventDefault();
      isHovering.value = false;
      let postFiles = Array.from(event.dataTransfer.files);
      if (!postFiles.length) return;

      if (!multiple.value) {
        postFiles = postFiles.slice(0, 1);
      }

      const filterFiles = accept.value.length ? postFiles.filter(file => {
        return matchType(file.name, file.type, accept.value);
      }) : postFiles;

      if (filterFiles.length !== postFiles.length) {
        if (props.onFileTypeInvalid) {
          props.onFileTypeInvalid(postFiles.filter(file => {
            return !matchType(file.name, file.type, accept.value);
          }));
        } else {
          FMessage.error(t('upload.fileTypeInvalidTip'));
        }
      }

      onUploadFiles(filterFiles);
    };

    return () => {
      var _ctx$slots, _ctx$slots$default;

      return createVNode("div", {
        "class": classList.value,
        "onDragenter": handleEnter,
        "onDragleave": handleLeave,
        "onDrop": handleDrop,
        "onDragover": handleOver
      }, [(_ctx$slots = ctx.slots) === null || _ctx$slots === void 0 ? void 0 : (_ctx$slots$default = _ctx$slots.default) === null || _ctx$slots$default === void 0 ? void 0 : _ctx$slots$default.call(_ctx$slots)]);
    };
  }

});

const FUpload = withInstall(Upload, {
  UploadDragger
});
const FUploadDragger = withNoopInstall(UploadDragger);

var useSpecialModel = (function (props, emit) {
  var _config$prop;

  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    prop: 'modelValue',
    isEqual: false
  };
  let callback = arguments.length > 3 ? arguments[3] : undefined;
  const usingProp = (_config$prop = config === null || config === void 0 ? void 0 : config.prop) !== null && _config$prop !== void 0 ? _config$prop : 'modelValue';
  const currentValue = ref(props[usingProp]);

  const pureUpdateCurrentValue = value => {
    if (value === currentValue.value || config.isEqual && isEqual(value, currentValue.value)) {
      return;
    }

    currentValue.value = value;
  };

  const updateCurrentValue = value => {
    if (value === currentValue.value) {
      return;
    }

    pureUpdateCurrentValue(value);
    emit(`update:${usingProp}`, value);
    callback();
  };

  watch(() => props[usingProp], val => {
    pureUpdateCurrentValue(val);
  });
  return [computed({
    get() {
      return currentValue.value;
    },

    set(value) {
      updateCurrentValue(value);
    }

  }), updateCurrentValue];
});

const COMPONENT_NAME$1 = {
  PAGINATION: 'FPagination',
  PAGINATION_JUMPER: 'FPaginationJumper',
  PAGINATION_PAGER: 'FPaginationPager',
  PAGINATION_SIMPLER: 'FPaginationSimpler',
  PAGINATION_SIZES: 'FPaginationSizes',
  PAGINATION_TOTAL: 'FPaginationTotal'
};
const PROPS = {
  // 
  pageSize: {
    type: Number,
    default: 10
  },
  // 
  currentPage: {
    type: Number,
    default: 1
  },
  // 
  totalCount: {
    type: Number,
    default: 0
  },
  // 
  pageSizeOption: {
    type: Array,

    default() {
      return [10, 20, 30, 50, 100];
    }

  },
  // 
  showQuickJumper: {
    type: Boolean,
    default: false
  },
  // 
  showSizeChanger: {
    type: Boolean,
    default: false
  },
  // 
  showTotal: {
    type: Boolean,
    default: false
  },
  // 
  small: {
    type: Boolean,
    default: false
  },
  // 
  simple: {
    type: Boolean,
    default: false
  }
};

const prefixCls$l = getPrefixCls('pagination');
var Simpler = defineComponent({
  name: COMPONENT_NAME$1.PAGINATION_SIMPLER,
  components: {
    LeftOutlined,
    RightOutlined
  },
  props: {
    modelValue: {
      type: Number,
      default: 1
    },
    total: {
      type: Number,
      default: 0
    }
  },
  emits: [UPDATE_MODEL_EVENT$1],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const {
      total
    } = toRefs(props);
    const [currentPage, updateCurrentPage] = useNormalModel(props, emit);

    const handleCurrentChange = cur => {
      let temp = 0;

      if (cur < 1) {
        temp = 1;
      } else if (cur > total.value) {
        temp = total.value < 1 ? 1 : total.value;
      } else {
        temp = cur;
      }

      updateCurrentPage(temp);
    };

    watch(total, () => {
      if (total.value > 0 && total.value < currentPage.value) {
        updateCurrentPage(total.value);
      }
    });
    return () => createVNode("div", {
      "class": `${prefixCls$l}-pager ${prefixCls$l}-simpler`
    }, [createVNode("div", {
      "class": `${prefixCls$l}-pager-item${currentPage.value <= 1 ? ' is-disabled' : ''}`,
      "onClick": handleCurrentChange.bind(null, currentPage.value - 1)
    }, [createVNode(LeftOutlined, null, null)]), createVNode("div", {
      "class": `${prefixCls$l}-pager-item is-current`
    }, [currentPage.value]), createVNode("div", {
      "class": `${prefixCls$l}-simpler-total`
    }, [createVNode("i", {
      "class": `${prefixCls$l}-simpler-total-split`
    }, [createTextVNode("/")]), createVNode("span", null, [total.value])]), createVNode("div", {
      "class": `${prefixCls$l}-pager-item${total.value <= currentPage.value ? ' is-disabled' : ''}`,
      "onClick": handleCurrentChange.bind(null, currentPage.value + 1)
    }, [createVNode(RightOutlined, null, null)])]);
  }

});

const prefixCls$k = getPrefixCls('pagination');
const STEP = 5; // 

var Pager = defineComponent({
  name: COMPONENT_NAME$1.PAGINATION_PAGER,
  components: {
    LeftOutlined,
    RightOutlined,
    MoreOutlined,
    DoubleLeftOutlined,
    DoubleRightOutlined
  },
  props: {
    modelValue: {
      type: Number,
      default: 1
    },
    total: {
      type: Number,
      default: 0
    }
  },
  emits: [UPDATE_MODEL_EVENT$1],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const {
      total
    } = toRefs(props);
    const [currentPage, updateCurrentPage] = useNormalModel(props, emit);
    const pages = computed(() => {
      const res = [];
      let count = 0;
      const currentVal = Number.isNaN(parseInt(currentPage.value, 10)) ? 1 : parseInt(currentPage.value, 10);
      let start = currentVal - Math.floor(STEP / 2);

      while (count < STEP) {
        res.push(start);
        count += 1;
        start += 1;
      }

      while (res[0] < 1) {
        res.shift();
        const lastCount = res[res.length - 1];

        if (lastCount < total.value - 1) {
          res.push(lastCount + 1);
        }
      }

      while (res[res.length - 1] > total.value) {
        res.pop();

        if (res[0] > 2) {
          res.unshift(res[0] - 1);
        }
      }

      if (res[0] === 1) {
        res.shift();
      }

      if (res[res.length - 1] === total.value) {
        res.pop();
      }

      return res;
    });

    const handleCurrentChange = cur => {
      let temp = 0;

      if (cur < 1) {
        temp = 1;
      } else if (cur > total.value) {
        temp = total.value < 1 ? 1 : total.value;
      } else {
        temp = cur;
      }

      updateCurrentPage(temp);
    };

    const getClassList = cur => `${prefixCls$k}-pager-item${cur === parseInt(currentPage.value, 10) ? ' is-active' : ''}`;

    const getBtnElement = () => pages.value.map(item => createVNode("div", {
      "class": getClassList(item),
      "onClick": handleCurrentChange.bind(null, item)
    }, [item]));

    const renderPrevDoubleJump = () => {
      if (pages.value.length > 0 && pages.value[0] > 2) {
        return createVNode("div", {
          "class": `${prefixCls$k}-pager-item is-double-jump`,
          "onClick": handleCurrentChange.bind(null, currentPage.value - STEP)
        }, [createVNode("div", {
          "class": 'is-more'
        }, [createVNode(MoreOutlined, null, null)]), createVNode("div", {
          "class": 'is-jump'
        }, [createVNode(DoubleLeftOutlined, null, null)])]);
      }

      return null;
    };

    const renderNextDoubleJump = () => {
      if (pages.value.length > 0 && pages.value[pages.value.length - 1] < total.value - 1) {
        return createVNode("div", {
          "class": `${prefixCls$k}-pager-item is-double-jump`,
          "onClick": handleCurrentChange.bind(null, currentPage.value + STEP)
        }, [createVNode("div", {
          "class": 'is-more'
        }, [createVNode(MoreOutlined, null, null)]), createVNode("div", {
          "class": 'is-jump'
        }, [createVNode(DoubleRightOutlined, null, null)])]);
      }

      return null;
    };

    const renderLast = () => {
      if (total.value > 1) {
        return createVNode("div", {
          "class": getClassList(total.value),
          "onClick": handleCurrentChange.bind(null, total.value)
        }, [total.value]);
      }

      return null;
    };

    watch(total, () => {
      if (total.value > 0 && total.value < currentPage.value) {
        updateCurrentPage(total.value);
      }
    });
    return () => createVNode("div", {
      "class": `${prefixCls$k}-pager`
    }, [createVNode("div", {
      "class": `${prefixCls$k}-pager-item${currentPage.value <= 1 ? ' is-disabled' : ''}`,
      "onClick": handleCurrentChange.bind(null, currentPage.value - 1)
    }, [createVNode(LeftOutlined, null, null)]), createVNode("div", {
      "class": getClassList(1),
      "onClick": handleCurrentChange.bind(null, 1)
    }, [createTextVNode("1")]), renderPrevDoubleJump(), getBtnElement(), renderNextDoubleJump(), renderLast(), createVNode("div", {
      "class": `${prefixCls$k}-pager-item${total.value <= currentPage.value ? ' is-disabled' : ''}`,
      "onClick": handleCurrentChange.bind(null, currentPage.value + 1)
    }, [createVNode(RightOutlined, null, null)])]);
  }

});

const prefixCls$j = getPrefixCls('pagination');
const pagerSizeProps = {
  modelValue: {
    type: Number,
    default: 10
  },
  pageSizeOption: {
    type: Array
  }
};
var Sizes = defineComponent({
  name: COMPONENT_NAME$1.PAGINATION_SIZES,
  components: {
    FSelect: script$k,
    FOption: FOption$1
  },
  props: pagerSizeProps,
  emits: [UPDATE_MODEL_EVENT$1],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const [pageSize] = useNormalModel(props, emit);
    const {
      t
    } = useLocale();

    const renderOptions = () => props.pageSizeOption && props.pageSizeOption.map(item => createVNode(FOption$1, {
      "key": item,
      "value": item,
      "label": `${item}${t('pagination.pageSize')}`
    }, null));

    return () => createVNode("div", {
      "class": `${prefixCls$j}-size`
    }, [createVNode(script$k, {
      "class": `${prefixCls$j}-size-select`,
      "modelValue": pageSize.value,
      "onUpdate:modelValue": $event => pageSize.value = $event
    }, {
      default: () => [renderOptions()]
    })]);
  }

});

const prefixCls$i = getPrefixCls('pagination');
var Jumper = defineComponent({
  name: COMPONENT_NAME$1.PAGINATION_JUMPER,
  components: {
    InputInner: script$y
  },
  props: {
    total: {
      type: Number,
      default: 0
    }
  },
  emits: ['change'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const current = ref();
    const {
      total
    } = toRefs(props);

    const handleChange = val => {
      const cur = parseInt(val, 10);

      if (Number.isNaN(cur)) {
        return;
      }

      const currentPage = cur < 1 ? 1 : cur > total.value ? total.value : cur;
      current.value = currentPage;
      emit('change', currentPage);
    };

    const {
      t
    } = useLocale();
    return () => createVNode("div", {
      "class": `${prefixCls$i}-jumper`
    }, [createVNode("span", {
      "class": `${prefixCls$i}-jumper-item`
    }, [t('pagination.goto')]), createVNode(script$y, {
      "class": `${prefixCls$i}-jumper-input`,
      "modelValue": current.value,
      "onUpdate:modelValue": $event => current.value = $event,
      "placeholder": "",
      "onChange": handleChange
    }, null), createVNode("span", {
      "class": `${prefixCls$i}-jumper-item`
    }, [t('pagination.pageClassifier')])]);
  }

});

const prefixCls$h = getPrefixCls('pagination');
var Total = defineComponent({
  name: COMPONENT_NAME$1.PAGINATION_TOTAL,
  props: {
    total: {
      type: Number,
      default: 0
    }
  },

  setup(props) {
    const {
      total
    } = toRefs(props);
    const {
      t
    } = useLocale();
    return () => createVNode("div", {
      "class": `${prefixCls$h}-total`
    }, [t('pagination.total', {
      total: total.value
    })]);
  }

});

const prefixCls$g = getPrefixCls('pagination');
var Pagination = defineComponent({
  name: COMPONENT_NAME$1.PAGINATION,
  components: {
    Simpler,
    Pager,
    Sizes,
    Jumper,
    Total
  },
  props: PROPS,
  emits: [CHANGE_EVENT$1, 'pageSizeChange', 'update:currentPage', 'update:pageSize'],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    useTheme();
    let timer;

    const changeEvent = () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        emit(CHANGE_EVENT$1, currentPage.value, pageSize.value);
      });
    };

    let pageSizeTimer;

    const pageSizeChangeEvent = () => {
      changeEvent();
      clearTimeout(pageSizeTimer);
      pageSizeTimer = setTimeout(() => {
        emit('pageSizeChange', pageSize.value);
      });
    };

    const [currentPage, updateCurrentPage] = useSpecialModel(props, emit, {
      prop: 'currentPage'
    }, changeEvent);
    const [pageSize] = useSpecialModel(props, emit, {
      prop: 'pageSize'
    }, pageSizeChangeEvent);
    const {
      small,
      pageSizeOption,
      totalCount,
      simple,
      showSizeChanger,
      showQuickJumper,
      showTotal
    } = toRefs(props);
    const totalPage = ref(Math.ceil(totalCount.value / pageSize.value));
    const classList = computed(() => `${prefixCls$g}${small.value ? ` ${prefixCls$g}-small` : ''}`);
    const sizeOption = computed(() => {
      const res = pageSizeOption.value.slice();

      if (res.includes(pageSize.value) === false) {
        res.push(pageSize.value);
      }

      res.sort((x, y) => x - y);
      return res;
    });

    const renderSimpler = () => {
      if (!simple.value) {
        return null;
      }

      return createVNode(Simpler, {
        "modelValue": currentPage.value,
        "onUpdate:modelValue": $event => currentPage.value = $event,
        "total": totalPage.value
      }, null);
    };

    const renderPager = () => {
      if (simple.value) {
        return null;
      }

      return createVNode(Pager, {
        "modelValue": currentPage.value,
        "onUpdate:modelValue": $event => currentPage.value = $event,
        "total": totalPage.value
      }, null);
    };

    const renderSizes = () => {
      if (!showSizeChanger.value) {
        return null;
      }

      return createVNode(Sizes, {
        "modelValue": pageSize.value,
        "onUpdate:modelValue": $event => pageSize.value = $event,
        "page-size-option": sizeOption.value
      }, null);
    };

    const renderJumper = () => {
      if (!showQuickJumper.value) {
        return null;
      }

      return createVNode(Jumper, {
        "total": totalPage.value,
        "onChange": updateCurrentPage
      }, null);
    };

    const renderTotal = () => {
      if (!showTotal.value) {
        return null;
      }

      return createVNode(Total, {
        "total": totalCount.value
      }, null);
    };

    watch(totalCount, () => {
      totalPage.value = Math.ceil(totalCount.value / pageSize.value);
    });
    watch(pageSize, () => {
      totalPage.value = Math.ceil(totalCount.value / pageSize.value);
    });
    return () => createVNode("div", {
      "class": classList.value
    }, [renderSimpler(), renderPager(), renderSizes(), renderJumper(), renderTotal()]);
  }

});

const FPagination = withInstall(Pagination);

function download(_ref) {
  let {
    href,
    name
  } = _ref;
  const a = document.createElement('a');
  a.download = name !== null && name !== void 0 ? name : `${Date.now()}`;
  a.href = href;
  a.target = '_blank';
  a.style.display = 'none';
  document.body.append(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
  }, 0);
}

const PREVIEW_PROVIDE_KEY = Symbol('wPreview');

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$f = getPrefixCls('preview');
const previewProps = {
  show: {
    type: Boolean,
    default: true
  },
  hideOnClickModal: {
    type: Boolean,
    default: false
  },
  src: {
    type: String,
    default: ''
  },
  download: {
    type: Boolean,
    default: false
  },
  getContainer: {
    type: Function
  },
  size: Object,
  name: String
};
var script$8 = defineComponent({
  name: 'FPreview',
  components: {
    LeftOutlined,
    RightOutlined,
    CloseOutlined,
    ReloadOutlined,
    RotateLeftOutlined,
    SearchPlusOutlined,
    SearchMinusOutlined,
    DownloadOutlined
  },
  props: previewProps,
  emits: [CLOSE_EVENT],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const containerRef = ref();
    const clientHeight = document.documentElement.clientHeight;
    const clientWidth = document.documentElement.clientWidth;
    const zIndex = ref(PopupManager$1.nextZIndex());
    const transform = ref({
      scale: 1,
      rotateDeg: 0,
      offsetX: 0,
      offsetY: 0
    });
    const {
      isGroup,
      next,
      prev
    } = inject(PREVIEW_PROVIDE_KEY, {
      isGroup: ref(false),
      next: noop$1,
      prev: noop$1
    });
    const config = useConfig();
    const getContainer = computed(() => {
      var _config$getContainer;

      return props.getContainer || ((_config$getContainer = config.getContainer) === null || _config$getContainer === void 0 ? void 0 : _config$getContainer.value);
    });
    const previewStyle = computed(() => {
      const {
        scale,
        rotateDeg,
        offsetX,
        offsetY
      } = transform.value;
      const style = {
        transform: `scale(${scale}) rotate(${rotateDeg}deg)`,
        transition: 'transform .3s',
        'margin-left': `${offsetX}px`,
        'margin-top': `${offsetY}px`
      };

      if (props.size.height > clientHeight || props.size.width > clientWidth) {
        if (props.size.height / props.size.width >= clientHeight / clientWidth) {
          style.height = `${clientHeight}px`;
          style.width = 'auto';
        } else {
          style.width = `${clientWidth}px`;
          style.height = 'auto';
        }
      }

      return style;
    });

    const handleActions = (action, option) => {
      const {
        zoomRate,
        rotateDeg
      } = _objectSpread$9({
        zoomRate: 0.2,
        rotateDeg: 90
      }, option);

      switch (action) {
        case 'zoomOut':
          if (transform.value.scale > 0.2) {
            transform.value.scale = parseFloat((transform.value.scale - zoomRate).toFixed(3));
          }

          break;

        case 'zoomIn':
          transform.value.scale = parseFloat((transform.value.scale + zoomRate).toFixed(3));
          break;

        case 'rotateLeft':
          transform.value.rotateDeg -= rotateDeg;
          break;

        case 'rotateRight':
          transform.value.rotateDeg += rotateDeg;
          break;
      }
    };

    const reset = () => {
      transform.value = {
        scale: 1,
        rotateDeg: 0,
        offsetX: 0,
        offsetY: 0
      };
    };

    useEventListener(containerRef, 'wheel', e => {
      e.preventDefault();
      window.requestAnimationFrame(() => {
        const delta = e.deltaY ? e.deltaY : e.detail;

        if (delta < 0) {
          handleActions('zoomIn', {
            zoomRate: 0.015
          });
        } else {
          handleActions('zoomOut', {
            zoomRate: 0.015
          });
        }
      });
    }, {
      passive: false
    });
    let isMouseDown = false;
    let startX;
    let startY;
    let imgOffsetX;
    let imgOffsetY;

    const handleMouseDown = event => {
      // 
      event.preventDefault();
      isMouseDown = true; // 

      const {
        offsetX,
        offsetY
      } = transform.value;
      startX = event.pageX;
      startY = event.pageY;
      imgOffsetX = offsetX;
      imgOffsetY = offsetY;
    };

    const dragHandle = event => {
      transform.value.offsetX = imgOffsetX + event.pageX - startX;
      transform.value.offsetY = imgOffsetY + event.pageY - startY;
    }; // 0.1s 


    const throttleDrag = throttle(dragHandle, 100);

    const handleMouseMove = event => {
      if (!isMouseDown) return;
      throttleDrag(event);
    };

    const handleMouseUp = () => {
      isMouseDown = false;
    };

    const handleClose = () => {
      emit(CLOSE_EVENT);
    };

    watch(() => props.src, () => {
      reset();
    });
    return {
      containerRef,
      prefixCls: prefixCls$f,
      handleClose,
      isGroup,
      prev,
      next,
      handleActions,
      previewStyle,
      zIndex,
      handleMouseDown,
      handleMouseMove,
      handleMouseUp,
      getContainer
    };
  }

});

const _hoisted_1$2 = ["download", "href"];
const _hoisted_2$2 = ["src"];
function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  var _ctx$getContainer, _ctx$getContainer2;

  const _component_CloseOutlined = resolveComponent("CloseOutlined");

  const _component_LeftOutlined = resolveComponent("LeftOutlined");

  const _component_RightOutlined = resolveComponent("RightOutlined");

  const _component_SearchMinusOutlined = resolveComponent("SearchMinusOutlined");

  const _component_SearchPlusOutlined = resolveComponent("SearchPlusOutlined");

  const _component_DownloadOutlined = resolveComponent("DownloadOutlined");

  const _component_RotateLeftOutlined = resolveComponent("RotateLeftOutlined");

  const _component_ReloadOutlined = resolveComponent("ReloadOutlined");

  return openBlock(), createBlock(Teleport, {
    disabled: !((_ctx$getContainer = _ctx.getContainer) !== null && _ctx$getContainer !== void 0 && _ctx$getContainer.call(_ctx)),
    to: (_ctx$getContainer2 = _ctx.getContainer) === null || _ctx$getContainer2 === void 0 ? void 0 : _ctx$getContainer2.call(_ctx)
  }, [withDirectives(createElementVNode("div", {
    ref: "containerRef",
    class: normalizeClass(`${_ctx.prefixCls}`),
    style: normalizeStyle({
      zIndex: _ctx.zIndex
    }),
    onClick: _cache[10] || (_cache[10] = withModifiers($event => _ctx.hideOnClickModal && _ctx.handleClose(), ["self"]))
  }, [createCommentVNode(" close "), createElementVNode("div", {
    class: normalizeClass([`${_ctx.prefixCls}__close`, `${_ctx.prefixCls}__btn`]),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.handleClose && _ctx.handleClose(...arguments);
    })
  }, [createVNode(_component_CloseOutlined)], 2
  /* CLASS */
  ), createCommentVNode(" arrow "), _ctx.isGroup ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass([`${_ctx.prefixCls}__arrow-left`, `${_ctx.prefixCls}__btn`]),
    onClick: _cache[1] || (_cache[1] = function () {
      return _ctx.prev && _ctx.prev(...arguments);
    })
  }, [createVNode(_component_LeftOutlined)], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), _ctx.isGroup ? (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass([`${_ctx.prefixCls}__arrow-right`, `${_ctx.prefixCls}__btn`]),
    onClick: _cache[2] || (_cache[2] = function () {
      return _ctx.next && _ctx.next(...arguments);
    })
  }, [createVNode(_component_RightOutlined)], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), _ctx.name ? (openBlock(), createElementBlock("div", {
    key: 2,
    class: normalizeClass(`${_ctx.prefixCls}__name`)
  }, toDisplayString(`${_ctx.name}(${_ctx.size.width}x${_ctx.size.height})`), 3
  /* TEXT, CLASS */
  )) : createCommentVNode("v-if", true), createCommentVNode(" toolBar "), createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}__toolBar`)
  }, [createVNode(_component_SearchMinusOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-zoom-out`),
    onClick: _cache[3] || (_cache[3] = $event => _ctx.handleActions('zoomOut'))
  }, null, 8
  /* PROPS */
  , ["class"]), createVNode(_component_SearchPlusOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-zoom-in`),
    onClick: _cache[4] || (_cache[4] = $event => _ctx.handleActions('zoomIn'))
  }, null, 8
  /* PROPS */
  , ["class"]), _ctx.download ? (openBlock(), createElementBlock("a", {
    key: 0,
    download: _ctx.name || Date.now(),
    href: _ctx.src,
    target: "_blank",
    class: normalizeClass(`${_ctx.prefixCls}-download`)
  }, [createVNode(_component_DownloadOutlined)], 10
  /* CLASS, PROPS */
  , _hoisted_1$2)) : createCommentVNode("v-if", true), createVNode(_component_RotateLeftOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-rotate-left`),
    onClick: _cache[5] || (_cache[5] = $event => _ctx.handleActions('rotateLeft'))
  }, null, 8
  /* PROPS */
  , ["class"]), createVNode(_component_ReloadOutlined, {
    class: normalizeClass(`${_ctx.prefixCls}-rotate-right`),
    onClick: _cache[6] || (_cache[6] = $event => _ctx.handleActions('rotateRight'))
  }, null, 8
  /* PROPS */
  , ["class"])], 2
  /* CLASS */
  ), createCommentVNode(" canvas "), createElementVNode("img", {
    ref: "img",
    class: normalizeClass([`${_ctx.prefixCls}__canvas`]),
    src: _ctx.src,
    style: normalizeStyle(_ctx.previewStyle),
    onMousedown: _cache[7] || (_cache[7] = function () {
      return _ctx.handleMouseDown && _ctx.handleMouseDown(...arguments);
    }),
    onMousemove: _cache[8] || (_cache[8] = function () {
      return _ctx.handleMouseMove && _ctx.handleMouseMove(...arguments);
    }),
    onMouseup: _cache[9] || (_cache[9] = function () {
      return _ctx.handleMouseUp && _ctx.handleMouseUp(...arguments);
    })
  }, null, 46
  /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */
  , _hoisted_2$2)], 6
  /* CLASS, STYLE */
  ), [[vShow, _ctx.show]])], 8
  /* PROPS */
  , ["disabled", "to"]);
}

script$8.render = render$8;
script$8.__file = "components/image/preview.vue";

const prefixCls$e = getPrefixCls('img');
let curIndex = 0;
let prevOverflow$1 = '';
var script$7 = defineComponent({
  name: 'FImage',
  componentName: 'FImage',
  components: {
    Preview: script$8,
    PictureOutlined,
    PictureFailOutlined
  },
  props: {
    src: {
      type: String,
      default: ''
    },
    name: String,
    preview: {
      type: Boolean,
      default: false
    },
    fit: {
      type: String
    },
    lazy: {
      type: Boolean,
      default: false
    },
    hideOnClickModal: {
      type: Boolean,
      default: false
    },
    scrollContainer: [String, Object],
    download: {
      type: Boolean,
      default: false
    },
    previewContainer: {
      type: Function
    }
  },
  emits: [ERROR_EVENT, LOAD_EVENT, CLOSE_EVENT],

  setup(props, _ref) {
    let {
      attrs,
      emit
    } = _ref;
    useTheme();
    const loading = ref(true);
    const isLoadError = ref(false);
    const container = ref(null);
    const isShowPreview = ref(false);
    const currentId = ref(curIndex++);
    const {
      width = '',
      height = '',
      crossorigin = '',
      decoding = 'auto',
      alt = '',
      sizes = '',
      srcset = '',
      usemap = ''
    } = attrs;
    const imgCommonProps = {
      crossorigin,
      decoding,
      alt,
      sizes,
      srcset,
      usemap
    };
    const imageSize = reactive({
      height: 0,
      width: 0
    });
    const {
      isGroup,
      setShowPreview,
      setCurrent,
      registerImage
    } = inject(PREVIEW_PROVIDE_KEY, {
      setShowPreview: noop$1,
      isGroup: ref(false),
      setCurrent: noop$1,
      registerImage: noopInNoop
    });
    const canPreview = computed(() => props.preview && !isLoadError.value);
    const canGroupPreview = computed(() => isGroup.value && !isLoadError.value);

    const _scrollContainer = computed(() => {
      let dom;
      const _container = props.scrollContainer;

      if (isString$1(_container) && _container !== '') {
        dom = document.querySelector(_container);
      }

      if (isHtmlElement(_container)) {
        dom = _container;
      } else if (container) {
        dom = getScrollContainer(container.value);
      }

      return dom;
    });

    const imageStyle = computed(() => {
      const {
        fit
      } = props;
      const styleObj = {
        objectFit: 'fill',
        cursor: ''
      };

      if (fit) {
        styleObj.objectFit = fit;
      }

      if (props.download || canPreview.value || canGroupPreview.value) {
        styleObj.cursor = 'pointer';
      }

      return styleObj;
    });

    const handleLoaded = (e, img) => {
      imageSize.width = img.width;
      imageSize.height = img.height;
      loading.value = false;
      isLoadError.value = false;
      emit(LOAD_EVENT, e);
    };

    const handleError = e => {
      loading.value = false;
      isLoadError.value = true;
      emit(ERROR_EVENT, e);
    };

    const loadImage = () => {
      if (!loading.value) return;
      const img = new Image();
      img.addEventListener('load', e => handleLoaded(e, img));
      img.addEventListener('error', handleError);
      img.src = props.src;
    };

    const lazyLoadHandler = useThrottleFn(() => {
      // load image until image enter the container
      if (isInContainer(container.value, _scrollContainer.value)) {
        loadImage();
      }
    }, 200);
    let clearScrollListener = noop$1;

    async function addLazyLoadListener() {
      await nextTick();
      clearScrollListener && clearScrollListener();

      if (_scrollContainer.value) {
        clearScrollListener = useEventListener(_scrollContainer, 'scroll', lazyLoadHandler);
      }

      lazyLoadHandler();
    }

    function clickHandler() {
      if (canGroupPreview.value) {
        setCurrent(currentId.value);
        setShowPreview(true);
      } else if (canPreview.value) {
        // prevent body scroll
        prevOverflow$1 = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        isShowPreview.value = true;
      } else if (props.download) {
        // 
        download({
          href: props.src,
          name: props.name
        });
      }
    }

    function closeViewer() {
      document.body.style.overflow = prevOverflow$1;
      isShowPreview.value = false;
      emit(CLOSE_EVENT);
    }

    watch(() => props.src, _src => {
      if (_src) {
        if (props.lazy) {
          addLazyLoadListener();
        } else {
          loadImage();
        }
      }
    }, {
      immediate: true
    });
    let unRegister = noop$1;
    watch([() => props.src, canGroupPreview], () => {
      unRegister();

      if (canGroupPreview.value) {
        unRegister = registerImage({
          id: currentId.value,
          url: props.src,
          name: props.name,
          size: imageSize,
          download: props.download
        });
      }
    }, {
      immediate: true
    });
    onUnmounted(() => {
      unRegister && unRegister();
      clearScrollListener && clearScrollListener();
    });
    return {
      width,
      height,
      imgCommonProps,
      imageStyle,
      isShowPreview,
      clickHandler,
      closeViewer,
      container,
      prefixCls: prefixCls$e,
      isLoadError,
      loading,
      imageSize
    };
  }

});

const _hoisted_1$1 = /*#__PURE__*/createElementVNode("span", null, "", -1
/* HOISTED */
);

const _hoisted_2$1 = /*#__PURE__*/createElementVNode("span", null, "", -1
/* HOISTED */
);

const _hoisted_3$1 = ["src"];
function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PictureOutlined = resolveComponent("PictureOutlined");

  const _component_PictureFailOutlined = resolveComponent("PictureFailOutlined");

  const _component_preview = resolveComponent("preview");

  return openBlock(), createElementBlock("div", {
    ref: "container",
    class: normalizeClass(_ctx.prefixCls)
  }, [_ctx.loading ? renderSlot(_ctx.$slots, "placeholder", {
    key: 0
  }, () => [createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}__placeholder`)
  }, [createVNode(_component_PictureOutlined), _hoisted_1$1], 2
  /* CLASS */
  )]) : _ctx.isLoadError ? renderSlot(_ctx.$slots, "error", {
    key: 1
  }, () => [createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}__error`)
  }, [createVNode(_component_PictureFailOutlined), _hoisted_2$1], 2
  /* CLASS */
  )]) : (openBlock(), createElementBlock("div", {
    key: 2,
    class: normalizeClass(`${_ctx.prefixCls}__inner`),
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.clickHandler && _ctx.clickHandler(...arguments);
    })
  }, [renderSlot(_ctx.$slots, "default", {}, () => [createElementVNode("img", mergeProps({
    src: _ctx.src,
    class: `${_ctx.prefixCls}__inner-image`,
    style: _ctx.imageStyle
  }, _ctx.imgCommonProps), null, 16
  /* FULL_PROPS */
  , _hoisted_3$1)])], 2
  /* CLASS */
  )), _ctx.isShowPreview ? (openBlock(), createBlock(_component_preview, {
    key: 3,
    src: _ctx.src,
    name: _ctx.name,
    size: _ctx.imageSize,
    download: _ctx.download,
    "hide-on-click-modal": _ctx.hideOnClickModal,
    getContainer: _ctx.previewContainer,
    onClose: _ctx.closeViewer
  }, null, 8
  /* PROPS */
  , ["src", "name", "size", "download", "hide-on-click-modal", "getContainer", "onClose"])) : createCommentVNode("v-if", true)], 2
  /* CLASS */
  );
}

script$7.render = render$7;
script$7.__file = "components/image/image.vue";

let prevOverflow = '';
var PreviewGroup = defineComponent({
  name: 'FPreviewGroup',
  props: {
    hideOnClickModal: {
      type: Boolean,
      default: false
    }
  },

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useTheme();
    const previewUrls = reactive({});
    const curIndex = ref();
    const isGroup = ref(true);
    const isShowPreview = ref(false);

    const setCurrent = val => {
      curIndex.value = val;
    };

    const previewUrlsKeys = computed(() => Object.keys(previewUrls));
    const currentPreviewIndex = computed(() => previewUrlsKeys.value.indexOf(String(curIndex.value)));

    const registerImage = param => {
      previewUrls[param.id] = param;
      return () => {
        delete previewUrls[param.id];
      };
    };

    const setShowPreview = () => {
      prevOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      isShowPreview.value = true;
    };

    const closeViewer = () => {
      document.body.style.overflow = prevOverflow;
      isShowPreview.value = false;
    };

    const next = () => {
      if (currentPreviewIndex.value < previewUrlsKeys.value.length - 1) {
        setCurrent(previewUrlsKeys.value[currentPreviewIndex.value + 1]);
      } else {
        setCurrent(previewUrlsKeys.value[previewUrlsKeys.value.length - currentPreviewIndex.value - 1]);
      }
    };

    const prev = () => {
      if (currentPreviewIndex.value > 0) {
        setCurrent(previewUrlsKeys.value[String(currentPreviewIndex.value - 1)]);
      } else {
        setCurrent(previewUrlsKeys.value[previewUrlsKeys.value.length - currentPreviewIndex.value - 1]);
      }
    };

    provide(PREVIEW_PROVIDE_KEY, {
      isGroup,
      prev,
      next,
      registerImage,
      curIndex,
      setCurrent,
      setShowPreview
    });
    return () => {
      var _slots$default;

      return createVNode(Fragment, null, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots), isShowPreview.value && createVNode(script$8, {
        "src": previewUrls[curIndex.value].url,
        "name": previewUrls[curIndex.value].name,
        "size": previewUrls[curIndex.value].size,
        "download": previewUrls[curIndex.value].download,
        "hideOnClickModal": props.hideOnClickModal,
        "onClose": closeViewer
      }, null)]);
    };
  }

});

const FImage = withInstall(script$7);
const FPreviewGroup = withInstall(PreviewGroup);

const provideKey$1 = Symbol('FForm');
const FORM_NAME = 'FForm';
const FORM_ITEM_NAME = 'FFormItem';
const FORM_LAYOUT = {
  HORIZONTAL: 'horizontal',
  INLINE: 'inline'
};
const LABEL_POSITION = {
  LEFT: 'left',
  RIGHT: 'right',
  TOP: 'top'
};
const VALIDATE_STATUS = {
  DEFAULT: '',
  ERROR: 'error',
  VALIDATING: 'validating',
  SUCCESS: 'success'
};
const VALIDATE_MESSAGE_DEFAULT = '';
const TRIGGER_TYPE_DEFAULT = ''; //  trigger 

const RULE_TYPE_DEFAULT = 'string'; //  rule 

// wrap sync validator
function wrapValidator(validator, async) {
  return function () {
    try {
      const validateResult = validator(...arguments);

      if (!async && (typeof validateResult === 'boolean' || validateResult instanceof Error || Array.isArray(validateResult)) || // Error[]
      typeof validateResult !== 'boolean' && validateResult !== null && validateResult !== void 0 && validateResult.then) {
        return validateResult;
      }

      if (typeof validateResult === 'undefined') {
        return true;
      }

      console.warn('form-item/validate', `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ${async ? '`Promise`' : '`boolean`, `Error` or `Promise`'} typed value instead.`);
      return true;
    } catch (err) {
      console.warn('form-item/validate', 'An error is catched in the validation, ' + "so the validation won't be done. Your callback in `validate` method of " + "`form` or `form-item` won't be called in this validation.");
      console.error(err); // If returns undefined, async-validator won't trigger callback
      // so the result will be abandoned, which means not true and not false

      return 'undefined';
    }
  };
}
function allPromiseFinish(promiseList) {
  if (!promiseList.length) return Promise.resolve([]);
  let hasError = false;
  let count = promiseList.length;
  const results = [];
  return new Promise((resolve, reject) => {
    promiseList.forEach((promise, index) => {
      promise.catch(e => {
        hasError = true;
        return e;
      }).then(result => {
        count -= 1;
        results[index] = result;
        if (count > 0) return;
        if (hasError) reject(results);
        resolve(results);
      });
    });
  });
}

const formProps = {
  model: Object,
  rules: {
    type: Object,
    default: () => ({})
  },
  layout: {
    type: String,
    default: FORM_LAYOUT.HORIZONTAL
  },
  span: {
    type: Number,
    default: 6
  },
  inlineItemGap: {
    type: [String, Number],
    default: 11
  },
  inlineItemWidth: [String, Number],
  labelPosition: {
    type: String,
    default: LABEL_POSITION.LEFT
  },
  showMessage: {
    type: Boolean,
    default: true
  },
  labelWidth: [String, Number],
  labelClass: String,
  disabled: {
    type: Boolean,
    default: false
  }
};
const formItemProps = {
  prop: String,
  value: {
    type: [String, Number, Boolean, Array, Object],
    // eslint-disable-next-line no-undefined
    default: undefined
  },
  label: String,
  labelWidth: [String, Number],
  labelClass: String,
  span: {
    type: Number,
    default: null
  },
  showMessage: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => {
      return [];
    }
  }
};

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$d = getPrefixCls('form');
var script$6 = defineComponent({
  name: FORM_NAME,
  props: formProps,

  setup(props) {
    useTheme();
    const formFields = {};
    const formClass = computed(() => [prefixCls$d, `${prefixCls$d}-${props.layout}`, props.disabled && `${prefixCls$d}-disabled` // disabled
    ]);
    const formStyle = computed(() => {
      const tempColStyle = props.layout === FORM_LAYOUT.INLINE && props.inlineItemWidth && {
        'grid-template-columns': `repeat(auto-fit, ${addUnit(props.inlineItemWidth)})`
      };
      const gapStyle = props.layout === FORM_LAYOUT.INLINE && props.inlineItemGap && {
        'grid-gap': `${addUnit(props.inlineItemGap)}`
      };
      return _objectSpread$8(_objectSpread$8({}, tempColStyle), gapStyle);
    });

    const addField = (formItemProp, formItemContext) => {
      if (formItemProp) formFields[formItemProp] = formItemContext;
    };

    const removeField = formItemProp => {
      delete formFields[formItemProp];
    };

    const validateFields = async function (fieldProps) {
      let trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TRIGGER_TYPE_DEFAULT;
      if (!props.model) return Promise.reject('Form `model` is required for resetFields to work.');
      const specifyPropsFlag = Boolean(fieldProps.length); // prop: ; 

      const promiseList = []; // 

      Object.values(formFields).forEach(formField => {
        if (specifyPropsFlag && !fieldProps.includes(formField.prop)) return; // Skip if Specify prop but not include

        const promise = formField.validateRules(trigger);
        promiseList.push(promise.then(() => ({
          name: formField.prop,
          errors: []
        })).catch(errors => Promise.reject({
          name: formField.prop,
          errors
        })));
      });
      const summaryPromise = allPromiseFinish(promiseList); // 

      try {
        await summaryPromise;
      } catch (results) {
        const errorList = [];
        const errorNameList = [];
        results === null || results === void 0 ? void 0 : results.forEach(result => {
          var _result$errors;

          if (result !== null && result !== void 0 && (_result$errors = result.errors) !== null && _result$errors !== void 0 && _result$errors.length) {
            errorList.push(result);
            errorNameList.push(result === null || result === void 0 ? void 0 : result.name);
          }
        });
        return Promise.reject({
          valid: false,
          values: errorNameList,
          errorFields: errorList
        });
      }
    };
    /** 
     *    fieldProps { string[] }     props 
     *    return    { Promise }   
     */


    const validate = function () {
      let fieldProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return validateFields(fieldProps);
    };
    /**  */


    const clearValidate = () => {
      if (!props.model) return Promise.reject('Form `model` is required for resetFields to work.');
      Object.values(formFields).forEach(formField => {
        formField.clearValidate();
      });
    };
    /**  */


    const resetFields = () => {
      if (!props.model) return Promise.reject('Form `model` is required for resetFields to work.');
      Object.values(formFields).forEach(formField => {
        formField.resetField();
      });
    };

    provide(provideKey$1, _objectSpread$8(_objectSpread$8({}, toRefs(props)), {}, {
      addField,
      removeField
    }));
    return {
      formClass,
      formStyle,
      validate,
      clearValidate,
      resetFields
    };
  }

});

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("form", {
    class: normalizeClass(_ctx.formClass),
    style: normalizeStyle(_ctx.formStyle)
  }, [renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  );
}

script$6.render = render$6;
script$6.__file = "components/form/form.vue";

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}
/* eslint no-console:0 */


var formatRegExp = /%[sdj%]/g;

var warning = function warning() {}; // don't print warning message when in production env or node runtime

if (typeof process !== 'undefined' && NODE_ENV !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {
  warning = function warning(type, errors) {
    if (typeof console !== 'undefined' && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined') {
      if (errors.every(function (e) {
        return typeof e === 'string';
      })) {
        console.warn(type, errors);
      }
    }
  };
}

function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  errors.forEach(function (error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}

function format(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var i = 0;
  var len = args.length;

  if (typeof template === 'function') {
    return template.apply(null, args);
  }

  if (typeof template === 'string') {
    var str = template.replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }

      if (i >= len) {
        return x;
      }

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

          break;

        default:
          return x;
      }
    });
    return str;
  }

  return template;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }

  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }

  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }

  return false;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors || []);
    total++;

    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }

    var original = index;
    index = index + 1;

    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k] || []);
  });
  return ret;
}

var AsyncValidationError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AsyncValidationError, _Error);

  function AsyncValidationError(errors, fields) {
    var _this;

    _this = _Error.call(this, 'Async Validation Error') || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }

  return AsyncValidationError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };

      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });

    _pending["catch"](function (e) {
      return e;
    });

    return _pending;
  }

  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function (resolve, reject) {
    var next = function next(errors) {
      results.push.apply(results, errors);
      total++;

      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };

    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }

    objArrKeys.forEach(function (key) {
      var arr = objArr[key];

      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function (e) {
    return e;
  });
  return pending;
}

function isErrorObj(obj) {
  return !!(obj && obj.message !== undefined);
}

function getValue(value, path) {
  var v = value;

  for (var i = 0; i < path.length; i++) {
    if (v == undefined) {
      return v;
    }

    v = v[path[i]];
  }

  return v;
}

function complementError(rule, source) {
  return function (oe) {
    var fieldValue;

    if (rule.fullFields) {
      fieldValue = getValue(source, rule.fullFields);
    } else {
      fieldValue = source[oe.field || rule.fullField];
    }

    if (isErrorObj(oe)) {
      oe.field = oe.field || rule.fullField;
      oe.fieldValue = fieldValue;
      return oe;
    }

    return {
      message: typeof oe === 'function' ? oe() : oe,
      fieldValue: fieldValue,
      field: oe.field || rule.fullField
    };
  };
}

function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];

        if (typeof value === 'object' && typeof target[s] === 'object') {
          target[s] = _extends({}, target[s], value);
        } else {
          target[s] = value;
        }
      }
    }
  }

  return target;
}

var required$1 = function required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
    errors.push(format(options.messages.required, rule.fullField));
  }
};
/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


var whitespace = function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(format(options.messages.whitespace, rule.fullField));
  }
};
/* eslint max-len:0 */


var pattern$2 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", 'i'),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }

    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }

    return typeof value === 'number';
  },
  object: function object(value) {
    return typeof value === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === 'string' && value.length <= 2048 && !!value.match(pattern$2.url);
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern$2.hex);
  }
};

var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    required$1(rule, value, source, errors, options);
    return;
  }

  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;

  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    } // straight typeof check

  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};

var range = function range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number'; // U+010000U+10FFFFSupplementary Plane

  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);

  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  } // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type


  if (!key) {
    return false;
  }

  if (arr) {
    val = value.length;
  }

  if (str) {
    // U+010000lengthbug"".lenght !== 3
    val = value.replace(spRegexp, '_').length;
  }

  if (len) {
    if (val !== rule.len) {
      errors.push(format(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};

var ENUM$1 = 'enum';

var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];

  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));
  }
};

var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      // if a RegExp instance is passed, reset `lastIndex` in case its `global`
      // flag is accidentally set to `true`, which in a validation scenario
      // is not necessary and the result might be misleading
      rule.pattern.lastIndex = 0;

      if (!rule.pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);

      if (!_pattern.test(value)) {
        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};

var rules = {
  required: required$1,
  whitespace: whitespace,
  type: type$1,
  range: range,
  "enum": enumerable$1,
  pattern: pattern$1
};

var string = function string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'string');

    if (!isEmptyValue(value, 'string')) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);

      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }

  callback(errors);
};

var method = function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var number = function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (value === '') {
      value = undefined;
    }

    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var _boolean = function _boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var regexp = function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var integer = function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var floatFn = function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var array = function array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if ((value === undefined || value === null) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'array');

    if (value !== undefined && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var object = function object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var ENUM = 'enum';

var enumerable = function enumerable(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var pattern = function pattern(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'string')) {
      rules.pattern(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var date = function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

  if (validate) {
    if (isEmptyValue(value, 'date') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'date')) {
      var dateObject;

      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }

      rules.type(rule, dateObject, source, errors, options);

      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }

  callback(errors);
};

var required = function required(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value;
  rules.required(rule, value, source, errors, options, type);
  callback(errors);
};

var type = function type(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, ruleType);

    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
};

var any = function any(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);
  }

  callback(errors);
};

var validators = {
  string: string,
  method: method,
  number: number,
  "boolean": _boolean,
  regexp: regexp,
  integer: integer,
  "float": floatFn,
  array: array,
  object: object,
  "enum": enumerable,
  pattern: pattern,
  date: date,
  url: type,
  hex: type,
  email: type,
  required: required,
  any: any
};

function newMessages() {
  return {
    "default": 'Validation error on field %s',
    required: '%s is required',
    "enum": '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      "boolean": '%s is not a %s',
      integer: '%s is not an %s',
      "float": '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}

var messages = newMessages();
/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */

var Schema = /*#__PURE__*/function () {
  // ========================= Static =========================
  // ======================== Instance ========================
  function Schema(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }

  var _proto = Schema.prototype;

  _proto.define = function define(rules) {
    var _this = this;

    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }

    if (typeof rules !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }

    this.rules = {};
    Object.keys(rules).forEach(function (name) {
      var item = rules[name];
      _this.rules[name] = Array.isArray(item) ? item : [item];
    });
  };

  _proto.messages = function messages(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }

    return this._messages;
  };

  _proto.validate = function validate(source_, o, oc) {
    var _this2 = this;

    if (o === void 0) {
      o = {};
    }

    if (oc === void 0) {
      oc = function oc() {};
    }

    var source = source_;
    var options = o;
    var callback = oc;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }

      return Promise.resolve(source);
    }

    function complete(results) {
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          var _errors;

          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }

      for (var i = 0; i < results.length; i++) {
        add(results[i]);
      }

      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }

    if (options.messages) {
      var messages$1 = this.messages();

      if (messages$1 === messages) {
        messages$1 = newMessages();
      }

      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }

    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      var arr = _this2.rules[z];
      var value = source[z];
      arr.forEach(function (r) {
        var rule = r;

        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = _extends({}, source);
          }

          value = source[z] = rule.transform(value);
        }

        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        } // Fill validator. Skip if nothing need to validate


        rule.validator = _this2.getValidationMethod(rule);

        if (!rule.validator) {
          return;
        }

        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this2.getType(rule);
        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;

      function addFullField(key, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
        });
      }

      function cb(e) {
        if (e === void 0) {
          e = [];
        }

        var errorList = Array.isArray(e) ? e : [e];

        if (!options.suppressWarning && errorList.length) {
          Schema.warning('async-validator:', errorList);
        }

        if (errorList.length && rule.message !== undefined) {
          errorList = [].concat(rule.message);
        } // Fill error info


        var filledErrors = errorList.map(complementError(rule, source));

        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }

        if (!deep) {
          doIt(filledErrors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message !== undefined) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
            }

            return doIt(filledErrors);
          }

          var fieldsSchema = {};

          if (rule.defaultField) {
            Object.keys(data.value).map(function (key) {
              fieldsSchema[key] = rule.defaultField;
            });
          }

          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function (field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema(paredFieldsSchema);
          schema.messages(options.messages);

          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }

          schema.validate(data.value, data.rule.options || options, function (errs) {
            var finalErrors = [];

            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }

            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }

            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }

      var res;

      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        res = rule.validator(rule, data.value, cb, data.source, options);

        if (res === true) {
          cb();
        } else if (res === false) {
          cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }

      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    }, source);
  };

  _proto.getType = function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }

    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format('Unknown rule type %s', rule.type));
    }

    return rule.type || 'string';
  };

  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }

    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');

    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }

    if (keys.length === 1 && keys[0] === 'required') {
      return validators.required;
    }

    return validators[this.getType(rule)] || undefined;
  };

  return Schema;
}();

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }

  validators[type] = validator;
};

Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$c = getPrefixCls('form-item');
var script$5 = defineComponent({
  name: FORM_ITEM_NAME,
  props: formItemProps,

  setup(props) {
    const {
      model,
      rules,
      layout,
      span,
      inlineItemWidth,
      showMessage,
      labelWidth,
      labelClass,
      labelPosition,
      disabled,
      addField,
      removeField
    } = inject(provideKey$1);
    const formItemProp = computed(() => {
      return props.prop || `${prefixCls$c}_${getCurrentInstance().uid}`;
    });
    const fieldValue = computed(() => {
      //  value 
      if (props.value !== undefined) return props.value; //  model[prop] 

      if (!model.value || !formItemProp.value) return;
      return get(model.value, formItemProp.value);
    });
    const initialValue = cloneDeep(fieldValue.value);
    const formItemRules = computed(() => {
      const _rules = [].concat(props.rules || []).concat(get(rules === null || rules === void 0 ? void 0 : rules.value, formItemProp.value) || []);

      return _rules;
    });
    /** : 
     *      :  A|B A  B  A 
     */

    const validateDisabled = ref(false); // 

    const validateStatus = ref(VALIDATE_STATUS.DEFAULT);
    const validateMessage = ref(VALIDATE_MESSAGE_DEFAULT);

    const setValidateInfo = function () {
      let status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : VALIDATE_STATUS.DEFAULT;
      let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VALIDATE_MESSAGE_DEFAULT;
      validateStatus.value = status;
      validateMessage.value = message;
    };
    /** : formItem   */


    const formItemShowMessage = computed(() => (props.showMessage === null ? showMessage.value : props.showMessage) && validateStatus.value === VALIDATE_STATUS.ERROR);
    const formItemRequired = computed(() => formItemRules.value.length > 0 && formItemRules.value.some(_ => _.required));
    const formItemClass = computed(() => [prefixCls$c, // inlineFormItem : Form  inlineItemWidth,  inlineItemWidth 
    // inlineFormItem :  formformItem  span,  formItem 
    layout.value === FORM_LAYOUT.INLINE && !inlineItemWidth.value && `${prefixCls$c}-span-${Math.ceil(props.span || span.value)}`, labelPosition.value !== LABEL_POSITION.LEFT && `${prefixCls$c}-${labelPosition.value}`, formItemRequired.value && 'is-required', // : is-required
    validateStatus.value === VALIDATE_STATUS.ERROR && 'is-error' // : is-error
    ].filter(Boolean));
    const formItemLabelClass = computed(() => [`${prefixCls$c}-label`, labelClass.value, props.labelClass].filter(Boolean));
    const formItemLabelStyle = computed(() => ({
      width: addUnit(props.labelWidth || labelWidth.value)
    }));
    /** :  String  */

    let ruleDefaultType = RULE_TYPE_DEFAULT;

    const setRuleDefaultType = function () {
      let val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RULE_TYPE_DEFAULT;
      ruleDefaultType = val;
    };

    const validateRules = async function () {
      let trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TRIGGER_TYPE_DEFAULT;

      if (validateDisabled.value) {
        validateDisabled.value = false;
        return;
      }
      /**  triggersRules
       *
       *   trigger  rule 
       *   trigger :
       *      rule.trigger ,  rule  trigger 
       *      rule.trigger ,  Array| String
       */


      const triggersRules = !trigger ? formItemRules.value : formItemRules.value.filter(rule => !rule.trigger || (isArray$1(rule.trigger) ? rule.trigger.includes(trigger) : rule.trigger === trigger)); //  rule  validator

      const activeRules = triggersRules.map(rule => {
        const shallowClonedRule = Object.assign({}, rule);

        if (shallowClonedRule.validator) {
          shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
        }

        if (shallowClonedRule.asyncValidator) {
          shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
        }

        if (!shallowClonedRule.type) {
          shallowClonedRule.type = ruleDefaultType;
        }

        return shallowClonedRule;
      });
      if (!activeRules.length) return Promise.resolve(); // 

      const descriptor = {};
      descriptor[formItemProp.value] = activeRules;
      const validatorModel = {};
      validatorModel[formItemProp.value] = fieldValue.value;
      const validator = new Schema(descriptor);

      try {
        await Promise.resolve(validator.validate(validatorModel));
        setValidateInfo(VALIDATE_STATUS.SUCCESS);
      } catch (errObj) {
        if (errObj.errors) {
          const error = errObj.errors[0];
          setValidateInfo(VALIDATE_STATUS.ERROR, error.message);
          return Promise.reject([_objectSpread$7(_objectSpread$7({}, error), {}, {
            message: error.message
          })]);
        }
      }
    }; // 


    const validate = async function () {
      let trigger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TRIGGER_TYPE_DEFAULT;

      try {
        await validateRules(trigger);
      } catch (err) {}
    };

    const clearValidate = () => {
      setValidateInfo();
      validateDisabled.value = false;
    };

    const resetField = () => {
      setValidateInfo();
      validateDisabled.value = true; // 
      // reset initialValue

      set(model.value, formItemProp.value, cloneDeep(initialValue)); // reset validateDisabled after onFieldChange triggered

      nextTick(() => {
        validateDisabled.value = false;
      });
    };

    addField(formItemProp.value, {
      prop: formItemProp.value,
      value: fieldValue.value,
      rules: formItemRules.value,
      validateRules,
      clearValidate,
      resetField
    });
    onBeforeUnmount(() => {
      removeField(formItemProp.value);
    });
    provide(FORM_ITEM_INJECTION_KEY, {
      validate,
      setRuleDefaultType,
      isError: computed(() => {
        return validateStatus.value === VALIDATE_STATUS.ERROR;
      }),
      isFormDisabled: disabled
    });
    return {
      prefixCls: prefixCls$c,
      formItemClass,
      formItemLabelClass,
      formItemLabelStyle,
      formItemShowMessage,
      validateMessage,
      validate,
      clearValidate
    };
  }

});

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.formItemClass)
  }, [_ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("label", {
    key: 0,
    class: normalizeClass(_ctx.formItemLabelClass),
    style: normalizeStyle(_ctx.formItemLabelStyle)
  }, [renderSlot(_ctx.$slots, "label", {}, () => [createTextVNode(toDisplayString(_ctx.label), 1
  /* TEXT */
  )])], 6
  /* CLASS, STYLE */
  )) : createCommentVNode("v-if", true), createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}-content`)
  }, [renderSlot(_ctx.$slots, "default"), createVNode(Transition, {
    name: "fes-fade"
  }, {
    default: withCtx(() => [_ctx.formItemShowMessage ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-error`)
    }, toDisplayString(_ctx.validateMessage), 3
    /* TEXT, CLASS */
    )) : createCommentVNode("v-if", true)]),
    _: 1
    /* STABLE */

  })], 2
  /* CLASS */
  )], 2
  /* CLASS */
  );
}

script$5.render = render$5;
script$5.__file = "components/form/formItem.vue";

const FForm = withInstall(script$6, {
  FormItem: script$5
});
const FFormItem = withNoopInstall(script$5);

const CAROUSEL_NAME = 'FCarousel';
const CAROUSEL_ITEM_NAME = 'FCarouselItem';
const provideKey = Symbol(CAROUSEL_NAME);
const CHANGE_EVENT = 'change';
const CARD_SCALE = 0.83;

var Arrow = defineComponent({
  name: 'FCarouselArrow',
  components: {
    LeftOutlined,
    RightOutlined
  },
  props: {
    hover: {
      type: Boolean,
      required: true
    },
    activeIndex: Number
  },

  setup(props) {
    const {
      prefixCls,
      direction,
      slideChildren,
      showArrow,
      loop,
      setActiveItem
    } = inject(provideKey);
    const arrowVisible = computed(() => showArrow !== 'never' && direction.value === 'horizontal');
    const arrowLeftShow = computed(() => (showArrow === 'always' || props.hover) && (loop || props.activeIndex > 0));
    const arrowRightShow = computed(() => (showArrow === 'always' || props.hover) && (loop || props.activeIndex < slideChildren.value.length - 1));

    const slideItemInStage = (slideItem, index) => {
      const length = slideChildren.value.length;

      if (index === length - 1 && slideItem.inStage && slideChildren.value[0].active || slideItem.inStage && slideChildren.value[index + 1] && slideChildren.value[index + 1].active) {
        return 'left';
      }

      if (index === 0 && slideItem.inStage && slideChildren.value[length - 1].active || slideItem.inStage && slideChildren.value[index - 1] && slideChildren.value[index - 1].active) {
        return 'right';
      }

      return false;
    }; // 


    const onEnterArrowButton = arrow => {
      if (direction.value === 'vertical') return;
      slideChildren.value.forEach((item, index) => {
        if (arrow === slideItemInStage(item, index)) {
          item.hover = true;
        }
      });
    }; // 


    const onLeaveArrowButton = () => {
      if (direction.value === 'vertical') return;
      slideChildren.value.forEach(item => {
        item.hover = false;
      });
    }; // 


    const handleArrowClick = throttle((event, index) => {
      event.stopPropagation();
      setActiveItem(index);
    }, 300, {
      trailing: true
    });
    return () => {
      if (arrowVisible.value) {
        return createVNode(Fragment, null, [createVNode(Transition, {
          "name": "carousel-arrow-left"
        }, {
          default: () => [withDirectives(createVNode("button", {
            "type": "button",
            "class": `${prefixCls}-arrow ${prefixCls}-arrow-left`,
            "onMouseenter": () => onEnterArrowButton('left'),
            "onMouseleave": onLeaveArrowButton,
            "onClick": e => handleArrowClick(e, props.activeIndex - 1)
          }, [createVNode(LeftOutlined, null, null)]), [[vShow, arrowLeftShow.value]])]
        }), createVNode(Transition, {
          "name": "carousel-arrow-right"
        }, {
          default: () => [withDirectives(createVNode("button", {
            "type": "button",
            "class": `${prefixCls}-arrow ${prefixCls}-arrow-right`,
            "onMouseenter": () => onEnterArrowButton('right'),
            "onMouseleave": onLeaveArrowButton,
            "onClick": e => handleArrowClick(e, props.activeIndex + 1)
          }, [createVNode(RightOutlined, null, null)]), [[vShow, arrowRightShow.value]])]
        })]);
      }
    };
  }

});

const INDICATOR_MOUSE_EVENT = 'mouse-operate';
var Indicator = defineComponent({
  name: 'FCarouselIndicator',
  props: {
    trigger: {
      type: String,
      default: 'click'
    },
    activeIndex: Number,
    position: String,
    placement: String,
    indicatorType: String,
    type: String
  },
  emits: [INDICATOR_MOUSE_EVENT],

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const {
      prefixCls,
      slideChildren
    } = inject(provideKey);
    const indicatorsClass = computed(() => {
      const classes = [`${prefixCls}-indicators`, `${prefixCls}-indicators-${props.placement}`];

      if (props.position === 'outside' || props.type === 'card') {
        classes.push(`${prefixCls}-indicators-outside`);
      }

      return classes;
    });

    const onClickIndicator = (index, event) => {
      event.stopPropagation();
      emit(INDICATOR_MOUSE_EVENT, index, event);
    };

    const onHoverIndicator = (index, event) => {
      if (props.trigger === 'hover' && index !== props.activeIndex) {
        emit(INDICATOR_MOUSE_EVENT, index, event);
      }
    };

    const throttledIndicatorHover = throttle((index, event) => {
      event.stopPropagation();
      onHoverIndicator(index, event);
    }, 300);
    return () => createVNode("ul", {
      "class": indicatorsClass.value
    }, [slideChildren.value.map((item, index) => createVNode("li", {
      "key": index,
      "class": [`${prefixCls}-indicator`, `${prefixCls}-indicator-${props.indicatorType}`, props.activeIndex === index ? 'is-active' : ''],
      "onMouseenter": e => throttledIndicatorHover(index, e),
      "onClick": e => onClickIndicator(index, e)
    }, [createVNode("button", {
      "type": "button",
      "class": `${prefixCls}-indicator-btn`
    }, null)]))]);
  }

});

function useCarouselItem(_ref) {
  let {
    loop,
    activeIndex
  } = _ref;
  // 
  const slideChildren = ref([]);

  const resetItemPosition = oldIndex => {
    slideChildren.value.forEach((item, index) => {
      item.translateItem(index, activeIndex.value, oldIndex);
    });
  };

  function setActiveItem(itemIndex) {
    const index = Number(itemIndex);

    if (Number.isNaN(index) || index !== Math.floor(index)) {
      console.warn(`[${CAROUSEL_NAME}]: ${CAROUSEL_NAME} index must be an integer.`);
      return;
    }

    const childrenCount = slideChildren.value.length;
    const oldIndex = activeIndex.value;

    if (index < 0) {
      activeIndex.value = loop ? childrenCount - 1 : 0;
    } else if (index >= childrenCount) {
      activeIndex.value = loop ? 0 : childrenCount - 1;
    } else {
      activeIndex.value = index;
    }

    if (oldIndex === activeIndex.value) {
      resetItemPosition(oldIndex);
    }
  }

  function prev() {
    setActiveItem(activeIndex.value - 1);
  }

  function next() {
    setActiveItem(activeIndex.value + 1);
  }

  function addItem(item) {
    slideChildren.value.push(item);
  }

  function removeItem(uid) {
    const index = slideChildren.value.findIndex(item => item.uid === uid);

    if (index !== -1) {
      slideChildren.value.splice(index, 1);
      if (activeIndex.value === index) next();
    }
  }

  return {
    slideChildren,
    addItem,
    removeItem,
    resetItemPosition,
    setActiveItem,
    prev,
    next
  };
}

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$b = getPrefixCls('carousel');
var useCarousel = (props => {
  const wrapperRef = ref(null); // 

  const activeIndex = ref(-1); // 
  // 

  const direction = computed(() => {
    const {
      indicatorPlacement: propIndicatorPlacement
    } = props;

    if (propIndicatorPlacement === 'top' || propIndicatorPlacement === 'bottom') {
      return 'horizontal';
    }

    if (propIndicatorPlacement === 'left' || propIndicatorPlacement === 'right') {
      return 'vertical';
    }

    return '';
  });
  const itemState = useCarouselItem({
    loop: props.loop,
    activeIndex
  });

  const state = _objectSpread$6({
    prefixCls: prefixCls$b,
    wrapperRef,
    direction,
    type: props.type,
    loop: props.loop,
    showArrow: props.showArrow,
    activeIndex
  }, itemState);

  provide(provideKey, state);
  return state;
});

var useCarouselStyle = (_ref => {
  let {
    prefixCls,
    height,
    type,
    direction
  } = _ref;
  const wrapperClass = computed(() => {
    const classes = [prefixCls, `${prefixCls}-${direction.value}`];

    if (type === 'card') {
      classes.push(`${prefixCls}-card`);
    }

    return classes;
  });
  const carouselStyle = computed(() => {
    const style = {
      height
    };
    return style;
  });
  return {
    wrapperClass,
    carouselStyle
  };
});

// control play
var useCarouselPlay = (_ref => {
  let {
    loop,
    autoplay,
    interval,
    initialIndex,
    activeIndex,
    slideChildren
  } = _ref;

  const play = () => {
    if (activeIndex.value < slideChildren.value.length - 1) {
      activeIndex.value = activeIndex.value + 1;
    } else if (loop) {
      activeIndex.value = 0;
    }
  };

  let playTimer = null;

  const startTimer = () => {
    if (interval <= 0 || !autoplay || playTimer) return;
    playTimer = window.setInterval(play, interval);
  };

  const pauseTimer = () => {
    clearInterval(playTimer);
    playTimer = null;
  };

  watch(() => autoplay, current => {
    current ? startTimer() : pauseTimer();
  }); // lifecycle

  onMounted(() => {
    nextTick(() => {
      if (initialIndex >= 0 && initialIndex < slideChildren.value.length) {
        activeIndex.value = initialIndex;
      }

      startTimer();
    });
  });
  onBeforeUnmount(() => {
    pauseTimer();
  });
  return {
    startTimer,
    pauseTimer
  };
});

const carouselProps = {
  height: {
    type: String,
    default: ''
  },
  initialIndex: {
    type: Number,
    default: 0
  },
  trigger: {
    type: String,
    default: 'click'
  },
  autoplay: {
    type: Boolean,
    default: true
  },
  interval: {
    type: Number,
    default: 3000
  },
  indicatorType: {
    type: String,
    default: 'linear'
  },
  indicatorPlacement: {
    type: String,
    default: 'bottom'
  },
  indicatorPosition: {
    type: String,
    default: ''
  },
  showArrow: {
    type: String,
    default: 'hover'
  },
  type: {
    type: String,
    default: ''
  },
  loop: {
    type: Boolean,
    default: true
  },
  pauseOnHover: {
    type: Boolean,
    default: true
  }
};
var Carousel = defineComponent({
  name: CAROUSEL_NAME,
  components: {
    Arrow
  },
  props: carouselProps,
  emits: [CHANGE_EVENT],

  setup(props, _ref) {
    let {
      slots,
      emit,
      expose
    } = _ref;
    useTheme();
    const {
      prefixCls,
      wrapperRef,
      direction,
      slideChildren,
      activeIndex,
      prev,
      next,
      setActiveItem,
      resetItemPosition
    } = useCarousel(props);
    const {
      wrapperClass,
      carouselStyle
    } = useCarouselStyle({
      prefixCls,
      height: props.height,
      type: props.type,
      direction
    });
    const {
      startTimer,
      pauseTimer
    } = useCarouselPlay({
      interval: props.interval,
      initialIndex: props.initialIndex,
      autoplay: props.autoplay,
      loop: props.loop,
      activeIndex,
      slideChildren
    }); // mouse event

    const carouselHover = ref(false);

    const handleMouseEnter = event => {
      event.stopPropagation();
      carouselHover.value = true;
      if (props.pauseOnHover) pauseTimer();
    };

    const handleMouseLeave = event => {
      event.stopPropagation();
      carouselHover.value = false;
      startTimer();
    }; //  (click / hover)


    const onOperateIndicator = index => {
      activeIndex.value = index;
    }; // watch


    watch(() => activeIndex.value, (currValue, prevState) => {
      resetItemPosition(prevState);

      if (prevState > -1) {
        emit(CHANGE_EVENT, currValue, prevState);
      }
    });
    watch(() => props.loop, () => {
      setActiveItem(activeIndex.value);
    });
    useResize(wrapperRef, resetItemPosition); // expose methods

    expose({
      setActiveItem,
      prev,
      next
    }); // render

    return () => {
      var _slots$default;

      return createVNode("div", {
        "ref": wrapperRef,
        "class": wrapperClass.value,
        "onMouseenter": handleMouseEnter,
        "onMouseleave": handleMouseLeave
      }, [createVNode("div", {
        "class": `${prefixCls}-slides`
      }, [createVNode(Arrow, {
        "hover": carouselHover.value,
        "activeIndex": activeIndex.value
      }, null), createVNode("div", {
        "class": `${prefixCls}-list`,
        "style": carouselStyle.value
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])]), createVNode(Indicator, {
        "trigger": props.trigger,
        "activeIndex": activeIndex.value,
        "position": props.indicatorPosition,
        "placement": props.indicatorPlacement,
        "indicatorType": props.indicatorType,
        "type": props.type,
        "onMouseOperate": onOperateIndicator
      }, null)]);
    };
  }

});

const carouselItemProps = {
  key: {
    type: String,
    default: ''
  }
};

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const useItemStyle = direction => {
  const itemStyleState = reactive({
    translate: 0,
    scale: 1
  });
  const itemStyle = computed(() => {
    const translateType = direction.value === 'vertical' ? 'translateY' : 'translateX';
    const value = `${translateType}(${itemStyleState.translate}px) scale(${itemStyleState.scale}, ${itemStyleState.scale})`;
    const style = {
      transform: value
    };
    return style;
  });

  const setItemStyle = (translate, scale) => {
    itemStyleState.translate = translate;
    if (scale) itemStyleState.scale = scale;
  };

  return {
    itemStyle,
    setItemStyle
  };
};

var CarouselItem = defineComponent({
  name: CAROUSEL_ITEM_NAME,
  props: carouselItemProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useTheme();
    const instance = getCurrentInstance();
    const slideRef = ref(null);
    const {
      prefixCls,
      direction,
      wrapperRef,
      type: parentType,
      loop,
      slideChildren,
      setActiveItem,
      addItem,
      removeItem
    } = inject(provideKey);
    const {
      itemStyle,
      setItemStyle
    } = useItemStyle(direction);

    function processIndex(index, activeIndex, length) {
      if (activeIndex === 0 && index === length - 1) {
        return -1;
      }

      if (activeIndex === length - 1 && index === 0) {
        return length;
      }

      if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
        return length + 1;
      }

      if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
        return -2;
      }

      return index;
    }

    const itemStatus = reactive({
      hover: false,
      active: false,
      inStage: false,
      animating: false
    });

    function calcCardTranslate(index, activeIndex) {
      var _wrapperRef$value;

      const parentWidth = ((_wrapperRef$value = wrapperRef.value) === null || _wrapperRef$value === void 0 ? void 0 : _wrapperRef$value.offsetWidth) || 0;

      if (itemStatus.inStage) {
        return parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1) / 4;
      }

      if (index < activeIndex) {
        return -(1 + CARD_SCALE) * parentWidth / 4;
      }

      return (3 + CARD_SCALE) * parentWidth / 4;
    }

    function calcTranslate(index, activeIndex, isVertical) {
      var _wrapperRef$value2, _wrapperRef$value3;

      const distance = (isVertical ? (_wrapperRef$value2 = wrapperRef.value) === null || _wrapperRef$value2 === void 0 ? void 0 : _wrapperRef$value2.offsetHeight : (_wrapperRef$value3 = wrapperRef.value) === null || _wrapperRef$value3 === void 0 ? void 0 : _wrapperRef$value3.offsetWidth) || 0;
      return distance * (index - activeIndex);
    }

    const itemReady = ref(false);

    const translateItem = (index, activeIndex, oldIndex) => {
      const length = slideChildren.value.length; // eslint-disable-next-line no-undefined

      if (parentType !== 'card' && oldIndex !== undefined) {
        itemStatus.animating = index === activeIndex || index === oldIndex;
      }

      if (index !== activeIndex && length > 2 && loop) {
        index = processIndex(index, activeIndex, length);
      }

      if (parentType === 'card') {
        if (direction.value === 'vertical') {
          console.warn(`[${CAROUSEL_ITEM_NAME}]: ${CAROUSEL_NAME} vertical direction is not supported in card mode.`);
        }

        itemStatus.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
        itemStatus.active = index === activeIndex;
        setItemStyle(calcCardTranslate(index, activeIndex), itemStatus.active ? 1 : CARD_SCALE);
      } else {
        itemStatus.active = index === activeIndex;
        const isVertical = direction.value === 'vertical';
        setItemStyle(calcTranslate(index, activeIndex, isVertical));
      }

      itemReady.value = true;
    };

    const onClickSlide = () => {
      if (parentType === 'card') {
        const index = slideChildren.value.map(item => item.uid).indexOf(instance.uid);
        setActiveItem(index);
      }
    };

    onMounted(() => {
      addItem(_objectSpread$5(_objectSpread$5(_objectSpread$5({
        uid: instance.uid
      }, props), toRefs(itemStatus)), {}, {
        translateItem
      }));
    });
    onUnmounted(() => {
      removeItem(instance.uid);
    });
    return () => {
      var _slots$default;

      return withDirectives(createVNode("div", {
        "ref": slideRef,
        "class": {
          [`${prefixCls}-item`]: true,
          [`${prefixCls}-item-card`]: parentType === 'card',
          'is-in-stage': itemStatus.inStage,
          'is-hover': itemStatus.hover,
          'is-active': itemStatus.active,
          'is-animating': itemStatus.animating
        },
        "style": itemStyle.value,
        "onClick": onClickSlide
      }, [parentType === 'card' && withDirectives(createVNode("div", {
        "class": `${prefixCls}-item-mask`
      }, null), [[vShow, !itemStatus.active]]), (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)]), [[vShow, itemReady.value]]);
    };
  }

});

const FCarousel = withInstall(Carousel, {
  CarouselItem
});
const FCarouselItem = withNoopInstall(CarouselItem);

const FVirtualList = withInstall(VirtualList);

const prefixCls$a = getPrefixCls('drawer');
const UPDATE_SHOW_EVENT = 'update:show';
const OK_EVENT = 'ok';
const CANCEL_EVENT = 'cancel';
const AFTER_LEAVE_EVENT = 'after-leave'; // 

const drawerProps = {
  show: Boolean,
  displayDirective: {
    type: String,
    default: 'show'
  },
  closable: {
    type: Boolean,
    default: true
  },
  mask: {
    type: Boolean,
    default: true
  },
  maskClosable: {
    type: Boolean,
    default: true
  },
  title: String,
  okText: {
    type: String,
    default: ''
  },
  cancelText: {
    type: String,
    default: ''
  },
  width: {
    type: [String, Number],
    default: 520
  },
  height: {
    type: [String, Number],
    default: 520
  },
  footer: {
    type: Boolean,
    default: false
  },
  getContainer: {
    type: Function
  },
  placement: {
    type: String,
    default: 'right'
  },
  contentClass: String
};
const Drawer = defineComponent({
  name: 'FDrawer',
  props: drawerProps,
  emits: [UPDATE_SHOW_EVENT, OK_EVENT, CANCEL_EVENT, AFTER_LEAVE_EVENT],

  setup(props, ctx) {
    useTheme();
    const zIndex = ref(PopupManager$1.nextZIndex());
    const visible = ref(false);
    useLockScreen(visible);
    watch(() => props.show, () => {
      if (props.show) zIndex.value = PopupManager$1.nextZIndex();
      nextTick(() => {
        visible.value = props.show;
      });
    }, {
      immediate: true
    });
    const config = useConfig();
    const getContainer = computed(() => {
      var _config$getContainer;

      return props.getContainer || ((_config$getContainer = config.getContainer) === null || _config$getContainer === void 0 ? void 0 : _config$getContainer.value);
    });

    function handleCancel(event) {
      ctx.emit(UPDATE_SHOW_EVENT, false);
      ctx.emit(CANCEL_EVENT, event);
    }

    function handleOk(event) {
      ctx.emit(OK_EVENT, event);
    }

    function handleTransitionAfterLeave(el) {
      ctx.emit(AFTER_LEAVE_EVENT, el);
    }

    const hasHeader = computed(() => ctx.slots.title || props.title);

    function getHeader() {
      var _ctx$slots$title, _ctx$slots;

      const closeJsx = props.closable && createVNode("div", {
        "class": `${prefixCls$a}-close`,
        "onClick": handleCancel
      }, [createVNode(CloseOutlined, null, null)]);

      if (!hasHeader.value) return closeJsx;
      const header = ((_ctx$slots$title = (_ctx$slots = ctx.slots).title) === null || _ctx$slots$title === void 0 ? void 0 : _ctx$slots$title.call(_ctx$slots)) || props.title;
      return createVNode("div", {
        "class": `${prefixCls$a}-header`
      }, [header, closeJsx]);
    }

    function getFooter() {
      if (!props.footer) return null;
      let footer;

      if (ctx.slots.footer) {
        footer = ctx.slots.footer();
      } else {
        footer = createVNode(Fragment, null, [createVNode(FButton$1, {
          "type": "primary",
          "class": "btn-margin",
          "size": "middle",
          "onClick": handleOk
        }, {
          default: () => [props.okText]
        }), createVNode(FButton$1, {
          "size": "middle",
          "onClick": handleCancel
        }, {
          default: () => [props.cancelText]
        })]);
      }

      return createVNode("div", {
        "class": `${prefixCls$a}-footer`
      }, [footer]);
    }

    const styles = computed(() => {
      const sty = {
        width: '100%',
        height: '100%'
      };
      const propsKey = ['top', 'bottom'].includes(props.placement) ? 'height' : 'width';
      sty[propsKey] = isNumber(props[propsKey]) ? `${props[propsKey]}px` : props[propsKey];
      return sty;
    });
    const showDom = computed(() => props.displayDirective === 'if' && visible.value || props.displayDirective === 'show');
    return () => {
      var _getContainer$value, _getContainer$value2, _ctx$slots$default, _ctx$slots2;

      return createVNode(Teleport, {
        "disabled": !((_getContainer$value = getContainer.value) !== null && _getContainer$value !== void 0 && _getContainer$value.call(getContainer)),
        "to": (_getContainer$value2 = getContainer.value) === null || _getContainer$value2 === void 0 ? void 0 : _getContainer$value2.call(getContainer)
      }, {
        default: () => [createVNode("div", {
          "class": `${prefixCls$a} ${prefixCls$a}-${props.placement}`
        }, [createVNode(Transition, {
          "name": `${prefixCls$a}-mask-fade`
        }, {
          default: () => [props.mask && showDom.value && withDirectives(createVNode("div", {
            "class": `${prefixCls$a}-mask`,
            "style": {
              zIndex: zIndex.value
            }
          }, null), [[vShow, visible.value]])]
        }), createVNode(Transition, {
          "name": `${prefixCls$a}-fade`,
          "onAfterLeave": handleTransitionAfterLeave
        }, {
          default: () => [showDom.value && withDirectives(createVNode("div", {
            "class": {
              [`${prefixCls$a}-container`]: true,
              [`${prefixCls$a}-no-header`]: !hasHeader.value,
              [`${prefixCls$a}-no-footer`]: !props.footer
            },
            "style": {
              zIndex: zIndex.value
            },
            "onClick": event => props.maskClosable && props.mask && handleCancel(event)
          }, [createVNode("div", {
            "class": `${prefixCls$a}-wrapper ${props.contentClass || ''}`,
            "style": styles.value,
            "onClick": event => event.stopPropagation()
          }, [getHeader(), createVNode("div", {
            "class": `${prefixCls$a}-body`
          }, [(_ctx$slots$default = (_ctx$slots2 = ctx.slots).default) === null || _ctx$slots$default === void 0 ? void 0 : _ctx$slots$default.call(_ctx$slots2)]), getFooter()])]), [[vShow, visible.value]])]
        })])]
      });
    };
  }

});
var Drawer$1 = Drawer;

const FDrawer = withInstall(Drawer$1);

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$9 = getPrefixCls('select-tree');
var script$4 = defineComponent({
  name: 'FSelectTree',
  components: {
    Popper: FPopper,
    SelectTrigger: script$l,
    Tree,
    Scrollbar: script$n
  },
  props: _objectSpread$4(_objectSpread$4(_objectSpread$4({}, selectProps), treeProps), {}, {
    modelValue: {
      type: [String, Number, Array]
    }
  }),
  emits: [UPDATE_MODEL_EVENT$1, CHANGE_EVENT$1, 'removeTag', 'visibleChange', 'focus', 'blur', 'clear'],

  setup(props, _ref) {
    let {
      emit,
      attrs
    } = _ref;
    useTheme();
    const {
      validate,
      isError,
      isFormDisabled
    } = useFormAdaptor({
      valueType: computed(() => props.multiple ? 'array' : 'string')
    });
    const isOpened = ref(false);
    const [currentValue, updateCurrentValue] = props.multiple ? useArrayModel(props, emit) : useNormalModel(props, emit);
    const filterText = ref('');
    const {
      t
    } = useLocale();
    const inputPlaceholder = computed(() => props.placeholder || t('select.placeholder'));
    const listEmptyText = computed(() => props.emptyText || t('select.emptyText'));
    const innerDisabled = computed(() => props.disabled || isFormDisabled.value);
    watch(isOpened, () => {
      emit('visibleChange', unref(isOpened));
    });

    const handleChange = () => {
      emit(CHANGE_EVENT$1, currentValue.value);
      validate(CHANGE_EVENT$1);
    };

    const nodeList = shallowRef(new Map());

    const onChangeNodeList = data => {
      nodeList.value = data;
      triggerRef(nodeList);
    };

    const treeSelectable = computed(() => !props.multiple);
    const treeCheckable = computed(() => props.multiple);
    const selectedKeys = computed(() => {
      if (!props.multiple) return currentValue.value ? [currentValue.value] : [];
      return [];
    });
    const checkedKeys = computed(() => {
      if (props.multiple) {
        return currentValue.value;
      }

      return [];
    });
    watch(() => props.checkStrictly, () => {
      if (props.multiple && props.cascade) {
        updateCurrentValue([]);
      }
    });

    const handleClear = () => {
      const value = props.multiple ? [] : null;

      if (props.multiple ? currentValue.value.length : currentValue.value !== null) {
        updateCurrentValue(value);
        handleChange();
      }

      emit('clear');
    };

    const handleSelect = data => {
      if (innerDisabled.value) return;
      filterText.value = '';

      if (!props.multiple) {
        updateCurrentValue(data.selectedKeys[0]);
        isOpened.value = false;
      } else {
        updateCurrentValue(data.selectedKeys);
      }

      handleChange();
    };

    const handleCheck = data => {
      if (innerDisabled.value) return;
      filterText.value = '';

      if (!props.multiple) {
        updateCurrentValue(data.checkedKeys[0]);
        isOpened.value = false;
      } else {
        updateCurrentValue(data.checkedKeys);
      }

      handleChange();
    };

    const handleRemove = value => {
      if (!props.multiple) {
        return;
      }

      const findIndex = currentValue.value.indexOf(value);

      if (findIndex !== -1) {
        emit('removeTag', value); // arrayModel

        updateCurrentValue(value);
        handleChange();
      }
    };

    const selectedOptions = computed(() => {
      const values = props.multiple ? currentValue.value : [currentValue.value];
      const nodeListValue = nodeList.value;
      return values.map(val => {
        return nodeListValue.get(val);
      }).filter(Boolean);
    });

    const focus = e => {
      emit('focus', e);
      validate('focus');
    };

    const blur = e => {
      if (isOpened.value) {
        isOpened.value = false;
      }

      emit('blur', e);
      validate('blur');
    };

    const handleFilterTextChange = val => {
      filterText.value = val;
    };

    const refTree = ref(null);
    watch(filterText, debounce(() => {
      refTree.value.filter(filterText.value);
    }, 300));
    const filterMethod = computed(() => {
      const defaultMethod = (value, node) => {
        return node.label.indexOf(value) !== -1;
      };

      return props.filter || defaultMethod;
    });
    const triggerDomRef = ref();
    const triggerWidth = ref(0);
    onMounted(() => {
      if (triggerDomRef.value) {
        triggerWidth.value = triggerDomRef.value.$el.offsetWidth;
      }
    });
    const dropdownStyle = computed(() => {
      const style = {};

      if (triggerWidth.value) {
        style['min-width'] = `${triggerWidth.value}px`;
      }

      return style;
    });
    return {
      prefixCls: prefixCls$9,
      isOpened,
      currentValue,
      handleRemove,
      handleClear,
      selectedOptions,
      focus,
      blur,
      handleFilterTextChange,
      treeSelectable,
      selectedKeys,
      treeCheckable,
      handleSelect,
      handleCheck,
      checkedKeys,
      refTree,
      filterMethod,
      triggerDomRef,
      dropdownStyle,
      onChangeNodeList,
      inputPlaceholder,
      listEmptyText,
      isError,
      attrs,
      innerDisabled
    };
  }

});

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectTrigger = resolveComponent("SelectTrigger");

  const _component_Tree = resolveComponent("Tree");

  const _component_Scrollbar = resolveComponent("Scrollbar");

  const _component_Popper = resolveComponent("Popper");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [createVNode(_component_Popper, {
    modelValue: _ctx.isOpened,
    "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => _ctx.isOpened = $event),
    trigger: "click",
    placement: "bottom-start",
    popperClass: `${_ctx.prefixCls}-popper`,
    appendToContainer: _ctx.appendToContainer,
    getContainer: _ctx.getContainer,
    offset: 4,
    hideAfter: 0,
    disabled: _ctx.innerDisabled,
    lazy: false
  }, {
    trigger: withCtx(() => [createVNode(_component_SelectTrigger, {
      ref: "triggerDomRef",
      selectedOptions: _ctx.selectedOptions,
      disabled: _ctx.innerDisabled,
      clearable: _ctx.clearable,
      isOpened: _ctx.isOpened,
      multiple: _ctx.multiple,
      placeholder: _ctx.inputPlaceholder,
      filterable: _ctx.filterable,
      collapseTags: _ctx.collapseTags,
      collapseTagsLimit: _ctx.collapseTagsLimit,
      tagBordered: _ctx.tagBordered,
      class: normalizeClass([{
        'is-error': _ctx.isError
      }, _ctx.attrs.class]),
      style: normalizeStyle(_ctx.attrs.style),
      renderTag: _ctx.$slots.tag,
      onRemove: _ctx.handleRemove,
      onClear: _ctx.handleClear,
      onFocus: _ctx.focus,
      onBlur: _ctx.blur,
      onInput: _ctx.handleFilterTextChange
    }, null, 8
    /* PROPS */
    , ["selectedOptions", "disabled", "clearable", "isOpened", "multiple", "placeholder", "filterable", "collapseTags", "collapseTagsLimit", "tagBordered", "class", "style", "renderTag", "onRemove", "onClear", "onFocus", "onBlur", "onInput"])]),
    default: withCtx(() => [_ctx.virtualList && !_ctx.inline ? (openBlock(), createElementBlock(Fragment, {
      key: 0
    }, [withDirectives(createVNode(_component_Tree, {
      ref: "refTree",
      selectedKeys: _ctx.selectedKeys,
      checkedKeys: _ctx.checkedKeys,
      data: _ctx.data,
      defaultExpandAll: _ctx.defaultExpandAll,
      expandedKeys: _ctx.expandedKeys,
      accordion: _ctx.accordion,
      selectable: _ctx.treeSelectable,
      checkable: _ctx.treeCheckable,
      checkStrictly: _ctx.checkStrictly,
      cascade: _ctx.cascade,
      multiple: _ctx.multiple,
      childrenField: _ctx.childrenField,
      valueField: _ctx.valueField,
      labelField: _ctx.labelField,
      filterMethod: _ctx.filterMethod,
      inline: _ctx.inline,
      remote: _ctx.remote,
      loadData: _ctx.loadData,
      virtualList: "",
      style: normalizeStyle(_ctx.dropdownStyle),
      class: normalizeClass(`${_ctx.prefixCls}-dropdown is-max-height`),
      "onUpdate:nodeList": _ctx.onChangeNodeList,
      onSelect: _ctx.handleSelect,
      onCheck: _ctx.handleCheck,
      onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"]))
    }, null, 8
    /* PROPS */
    , ["selectedKeys", "checkedKeys", "data", "defaultExpandAll", "expandedKeys", "accordion", "selectable", "checkable", "checkStrictly", "cascade", "multiple", "childrenField", "valueField", "labelField", "filterMethod", "inline", "remote", "loadData", "style", "class", "onUpdate:nodeList", "onSelect", "onCheck"]), [[vShow, _ctx.data.length]]), withDirectives(createElementVNode("div", {
      class: normalizeClass(`${_ctx.prefixCls}-null`),
      onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {}, ["prevent"]))
    }, toDisplayString(_ctx.listEmptyText), 35
    /* TEXT, CLASS, HYDRATE_EVENTS */
    ), [[vShow, !_ctx.data.length]])], 64
    /* STABLE_FRAGMENT */
    )) : (openBlock(), createBlock(_component_Scrollbar, {
      key: 1,
      containerStyle: _ctx.dropdownStyle,
      containerClass: `${_ctx.prefixCls}-dropdown`,
      onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {}, ["prevent"]))
    }, {
      default: withCtx(() => [withDirectives(createVNode(_component_Tree, {
        ref: "refTree",
        selectedKeys: _ctx.selectedKeys,
        checkedKeys: _ctx.checkedKeys,
        data: _ctx.data,
        defaultExpandAll: _ctx.defaultExpandAll,
        expandedKeys: _ctx.expandedKeys,
        accordion: _ctx.accordion,
        selectable: _ctx.treeSelectable,
        checkable: _ctx.treeCheckable,
        checkStrictly: _ctx.checkStrictly,
        cascade: _ctx.cascade,
        multiple: _ctx.multiple,
        childrenField: _ctx.childrenField,
        valueField: _ctx.valueField,
        labelField: _ctx.labelField,
        filterMethod: _ctx.filterMethod,
        inline: _ctx.inline,
        remote: _ctx.remote,
        loadData: _ctx.loadData,
        "onUpdate:nodeList": _ctx.onChangeNodeList,
        onSelect: _ctx.handleSelect,
        onCheck: _ctx.handleCheck
      }, null, 8
      /* PROPS */
      , ["selectedKeys", "checkedKeys", "data", "defaultExpandAll", "expandedKeys", "accordion", "selectable", "checkable", "checkStrictly", "cascade", "multiple", "childrenField", "valueField", "labelField", "filterMethod", "inline", "remote", "loadData", "onUpdate:nodeList", "onSelect", "onCheck"]), [[vShow, _ctx.data.length]]), withDirectives(createElementVNode("div", {
        class: normalizeClass(`${_ctx.prefixCls}-null`)
      }, toDisplayString(_ctx.listEmptyText), 3
      /* TEXT, CLASS */
      ), [[vShow, !_ctx.data.length]])]),
      _: 1
      /* STABLE */

    }, 8
    /* PROPS */
    , ["containerStyle", "containerClass"]))]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["modelValue", "popperClass", "appendToContainer", "getContainer", "disabled"])], 2
  /* CLASS */
  );
}

script$4.render = render$4;
script$4.__file = "components/select-tree/selectTree.vue";

const FSelectTree = withInstall(script$4);

function createKey(prefix, suffix) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return prefix + (suffix === 'default' ? '' : suffix.replace(/^[a-z]/, startChar => startChar.toUpperCase()));
}

const prefixCls$8 = getPrefixCls('space');
const spaceProps = {
  align: String,
  justify: {
    type: String,
    default: 'start'
  },
  inline: Boolean,
  vertical: Boolean,
  // 
  size: {
    type: [String, Number, Array],
    default: 'small'
  },
  itemStyle: [String, Object],
  wrap: {
    type: Boolean,
    default: true
  }
};

const useMargin = (props, themeVarsRef) => {
  const margin = computed(() => {
    const {
      size
    } = props;
    let horizontal = 0;
    let vertical = 0;

    if (Array.isArray(size)) {
      horizontal = size[0];
      vertical = size[1];
    } else if (typeof size === 'number') {
      horizontal = size;
      vertical = size;
    } else {
      const currentSize = depx(themeVarsRef.value[createKey('padding', size)] || themeVarsRef.value[createKey('padding', 'small')]);
      horizontal = currentSize;
      vertical = currentSize;
    }

    return {
      horizontal: `${horizontal}px`,
      vertical: `${vertical}px`,
      semiHorizontal: `${horizontal / 2}px`,
      semiVertical: `${vertical / 2}px`
    };
  });
  return {
    margin
  };
};

var Space = defineComponent({
  name: 'FSpace',
  components: {},
  props: spaceProps,

  setup(props) {
    const {
      themeVars
    } = useTheme();
    const {
      margin
    } = useMargin(props, themeVars);
    return {
      prefixCls: prefixCls$8,
      margin
    };
  },

  render() {
    const {
      vertical,
      align,
      inline,
      justify,
      itemStyle,
      wrap,
      prefixCls,
      margin
    } = this;
    const children = flatten(getSlot(this.$slots) || []).filter(node => isValidElementNode(node));
    const lastIndex = children.length - 1;
    const isJustifySpace = justify.startsWith('space-');
    return createVNode("div", {
      "role": "none",
      "class": `${prefixCls}`,
      "style": {
        display: inline ? 'inline-flex' : 'flex',
        flexDirection: vertical ? 'column' : 'row',
        justifyContent: ['start', 'end'].includes(justify) ? 'flex-' + justify : justify,
        alignItems: align,
        flexWrap: !wrap || vertical ? 'nowrap' : 'wrap',
        marginTop: vertical ? '' : `-${margin.semiHorizontal}`,
        marginBottom: vertical ? '' : `-${margin.semiVertical}`
      }
    }, [children === null || children === void 0 ? void 0 : children.map((child, index) => createVNode("div", {
      "role": "none",
      "style": [itemStyle, {
        maxWidth: '100%'
      }, vertical ? {
        marginBottom: index !== lastIndex ? margin.vertical : ''
      } : {
        marginRight: isJustifySpace ? justify === 'space-between' && index === lastIndex ? '' : margin.semiHorizontal : index !== lastIndex ? margin.horizontal : '',
        marginLeft: isJustifySpace ? justify === 'space-between' && index === 0 ? '' : margin.semiHorizontal : '',
        paddingTop: margin.semiVertical,
        paddingBottom: margin.semiVertical
      }]
    }, [child]))]);
  }

});

const FSpace = withInstall(Space);

const prefixCls$7 = getPrefixCls('skeleton');
const skeletonProps = {
  text: Boolean,
  round: Boolean,
  circle: Boolean,
  height: [String, Number],
  width: [String, Number],
  size: String,
  repeat: {
    type: Number,
    default: 1
  },
  animated: {
    type: Boolean,
    default: true
  },
  sharp: {
    type: Boolean,
    default: true
  }
};
var Skeleton = defineComponent({
  name: 'FSkeleton',
  inheritAttrs: false,
  props: skeletonProps,

  setup(props) {
    useTheme();
    const style = computed(() => {
      const {
        circle,
        width,
        height
      } = props;
      const mergedWidth = circle ? width !== null && width !== void 0 ? width : height : width;
      const mergedHeight = circle ? height !== null && height !== void 0 ? height : width : height;
      return {
        width: pxfy(mergedWidth),
        height: pxfy(mergedHeight)
      };
    });
    const classes = computed(() => {
      const {
        circle,
        sharp,
        round,
        size,
        text,
        animated
      } = props;
      return [prefixCls$7, text && `is-text`, circle && `is-circle`, sharp && `is-sharp`, round && `is-round`, size && `is-size-${size}`, animated && `is-animated`];
    });
    return {
      prefixCls: prefixCls$7,
      style,
      classes
    };
  },

  render() {
    const {
      repeat,
      style,
      $attrs,
      classes,
      $slots
    } = this;
    const slotDefault = $slots.default ? getSlot(this.$slots, 'default') : null;
    const mergeAttrs = mergeProps({
      class: classes,
      style
    }, $attrs);

    const renderChild = () => createVNode("div", {
      "class": mergeAttrs.class,
      "style": mergeAttrs.style
    }, [slotDefault]);

    return repeat <= 1 ? renderChild() : createVNode(Fragment, null, [[...Array(repeat)].map(() => [renderChild()])]);
  }

});

const FSkeleton = withInstall(Skeleton);

const COMPONENT_NAME = {
  CASCADER: 'FCascader',
  CASCADER_MENU: 'FCascaderMenu',
  CASCADER_NODE: 'FCascaderNode'
};
const CHECK_STRATEGY = {
  ALL: 'all',
  PARENT: 'parent',
  CHILD: 'child'
};
const ROOT_MENU_KEY = 'root';
const EXPAND_TRIGGER = {
  CLICK: 'click',
  HOVER: 'hover'
};

const cascaderProps = {
  data: {
    type: Array,

    default() {
      return [];
    }

  },
  emptyText: {
    type: String
  },
  expandedKeys: {
    type: Array,

    default() {
      return [];
    }

  },
  selectable: {
    type: Boolean,
    default: true
  },
  selectedKeys: {
    type: Array,

    default() {
      return [];
    }

  },
  cascade: {
    type: Boolean,
    default: true
  },
  checkable: {
    type: Boolean,
    default: false
  },
  checkStrictly: {
    type: String,
    default: CHECK_STRATEGY.CHILD
  },
  checkedKeys: {
    type: Array,

    default() {
      return [];
    }

  },
  multiple: {
    type: Boolean,
    default: false
  },
  childrenField: {
    type: String,
    default: 'children'
  },
  valueField: {
    type: String,
    default: 'value'
  },
  labelField: {
    type: String,
    default: 'label'
  },
  remote: {
    type: Boolean,
    default: false
  },
  loadData: {
    type: Function
  },
  cancelable: {
    type: Boolean,
    default: true
  },
  expandTrigger: {
    type: String,
    default: EXPAND_TRIGGER.CLICK
  },
  emitPath: {
    type: Boolean,
    default: false
  },
  initLoadKeys: {
    type: Array,

    default() {
      return [];
    }

  },
  showPath: {
    type: Boolean,
    default: false
  },
  isOpened: {
    type: Boolean,
    default: true
  }
};
extractPropsDefaultValue(cascaderProps);
const CASCADER_PROVIDE_KEY = Symbol('FCascader');

var useCascaderMenu = (props => {
  const root = inject(CASCADER_PROVIDE_KEY);
  const menuNodes = computed(() => {
    let nodes = [];

    if (props.menuKey === ROOT_MENU_KEY) {
      nodes = root.transformData.value.filter(value => {
        const node = root.nodeList[value];
        return node.indexPath.length === 1;
      }).map(value => root.nodeList[value]);
    } else {
      var _root$nodeList$props$;

      nodes = ((_root$nodeList$props$ = root.nodeList[props.menuKey]) === null || _root$nodeList$props$ === void 0 ? void 0 : _root$nodeList$props$.childrenValues.map(value => root.nodeList[value])) || [];
    }

    return nodes;
  });
  const isCascaderOpened = computed(() => root.props.isOpened);
  const menuScrollNode = computed(() => {
    return menuNodes.value.find(node => {
      if (root.props.selectable) {
        return root.hasActive(node.value, root.nodeList) || root.hasSelected(node.value);
      }

      if (root.props.checkable) {
        return root.hasChecked(node.value);
      }

      return false;
    });
  });
  return {
    menuNodes,
    isCascaderOpened,
    menuScrollNode
  };
});

var useCascaderNode = (props => {
  const root = inject(CASCADER_PROVIDE_KEY);
  const isExpanded = computed(() => root.nodeList[props.value].isExpanded);
  const isInitLoading = computed(() => root.nodeList[props.value].isInitLoading);
  const isSelected = computed(() => root.hasSelected(props.value));
  const isChecked = computed(() => root.hasChecked(props.value));
  const isLoaded = computed(() => {
    return root.hasLoaded(root.nodeList[props.value]);
  });
  const isCheckLoaded = computed(() => root.hasCheckLoaded(props.value, root.nodeList));
  const isActive = computed(() => root.hasActive(props.value, root.nodeList));

  const hasIndeterminate = node => {
    if (root.hasChecked(node.value)) {
      return false;
    }

    if (node.isLeaf) {
      return false;
    }

    return root.props.cascade && node.hasChildren && node.childrenValues.some(value => root.hasChecked(value) || hasIndeterminate(root.nodeList[value]));
  };

  const isIndeterminate = computed(() => hasIndeterminate(root.nodeList[props.value]));
  return {
    root,
    isExpanded,
    isInitLoading,
    isSelected,
    isChecked,
    isIndeterminate,
    isLoaded,
    isCheckLoaded,
    isActive
  };
});

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$6 = getPrefixCls('cascader-node');
const cascaderNodeProps = {
  value: {
    type: [String, Number],
    required: true
  },
  label: {
    type: String,
    required: true
  },
  disabled: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  checkable: {
    type: Boolean
  },
  isLeaf: {
    type: Boolean,
    default: false
  },
  level: {
    type: Number,
    default: 0
  }
};
var CascaderNode = defineComponent({
  name: COMPONENT_NAME.CASCADER_NODE,
  props: cascaderNodeProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      root,
      isExpanded,
      isInitLoading,
      isSelected,
      isChecked,
      isIndeterminate,
      isLoaded,
      isCheckLoaded,
      isActive
    } = useCascaderNode(props);
    const disabled = computed(() => props.disabled);
    const selectable = computed(() => isUndefined(props.selectable) ? root.props.selectable : props.selectable);
    const checkable = computed(() => isUndefined(props.checkable) ? root.props.checkable : props.checkable);
    const classList = computed(() => [prefixCls$6, disabled.value && 'is-disabled', isExpanded.value && 'is-expanded', isSelected.value && 'is-selected', isChecked.value && 'is-checked', isActive.value && 'is-active'].filter(Boolean));
    const {
      t
    } = useLocale();
    const loadingRequiredMessage = computed(() => t('cascader.loadingRequiredMessage', {
      label: props.label
    }));
    const isLoading = ref(false);

    const handleClickSwitcher = async event => {
      if (isInitLoading.value || isLoading.value) {
        return;
      }

      const node = root.nodeList[props.value];

      if (!isLoaded.value) {
        isLoading.value = true;

        try {
          const children = await root.props.loadData(_objectSpread$3({}, node.origin));

          if (isArray$1(children)) {
            node.origin.children = children; // 

            await nextTick();
            root.expandNode(props.value, event);
          }
        } catch (e) {
          console.error(e);
        }

        isLoading.value = false;
      } else {
        root.expandNode(props.value, event);
      }
    };

    const handleHoverSwitcher = event => {
      if (root.props.expandTrigger !== EXPAND_TRIGGER.HOVER) {
        return;
      }

      handleClickSwitcher(event);
    };

    const handleClickContent = event => {
      // 
      if (!props.isLeaf) {
        return handleClickSwitcher(event);
      }

      if (disabled.value) return; //  select 

      if (selectable.value) {
        return root.selectNode(props.value, event);
      } //  check 


      if (checkable.value && isCheckLoaded.value) {
        return root.checkNode(props.value, event);
      }
    };

    const handleHoverContent = event => {
      if (root.props.expandTrigger !== EXPAND_TRIGGER.HOVER) {
        return;
      } // 


      if (!props.isLeaf) {
        return handleClickSwitcher(event);
      }
    };

    const handleClickCheckbox = event => {
      if (disabled.value) return;

      if (checkable.value && isCheckLoaded.value) {
        return root.checkNode(props.value, event);
      }
    };

    const handleClickRadio = event => {
      if (disabled.value) return; //  select 

      if (selectable.value) {
        return root.selectNode(props.value, event);
      }
    };

    const handleStopClickPrefix = event => {
      event.stopPropagation();
    };

    const renderSwitcher = () => {
      const currentClassList = [`${prefixCls$6}-switcher`, disabled.value && 'is-disabled'].filter(Boolean);

      if (props.isLeaf) {
        return createVNode("span", {
          "class": currentClassList
        }, [!checkable.value && isSelected.value ? createVNode(CheckOutlined, null, null) : null]);
      }

      return createVNode("span", {
        "class": currentClassList,
        "onClick": handleClickSwitcher,
        "onMouseenter": handleHoverSwitcher
      }, [isInitLoading.value || isLoading.value ? createVNode(LoadingOutlined, null, null) : createVNode(RightOutlined, null, null)]);
    };

    const renderCheckbox = () => {
      if (checkable.value) {
        return createVNode("span", {
          "class": `${prefixCls$6}-checkbox`
        }, [isCheckLoaded.value ? createVNode(script$C, {
          "indeterminate": isIndeterminate.value,
          "modelValue": isChecked.value,
          "onClick": handleClickCheckbox,
          "disabled": props.disabled
        }, null) : createVNode(FTooltip, {
          "placement": "top-start",
          "content": loadingRequiredMessage.value
        }, {
          default: () => [createVNode(script$C, {
            "indeterminate": isIndeterminate.value,
            "modelValue": isChecked.value,
            "disabled": true
          }, null)]
        })]);
      }

      return null;
    };

    const renderRadio = () => {
      if (!checkable.value && selectable.value && root.props.checkStrictly === CHECK_STRATEGY.ALL) {
        return createVNode("span", {
          "class": `${prefixCls$6}-radio`
        }, [createVNode(script$q, {
          "modelValue": isSelected.value,
          "onClick": handleClickRadio,
          "disabled": props.disabled
        }, null)]);
      }

      return null;
    };

    const renderPrefix = () => {
      var _slots$prefix;

      if (!slots.prefix) return null;
      return createVNode("span", {
        "class": `${prefixCls$6}-content-prefix`,
        "onClick": handleStopClickPrefix
      }, [(_slots$prefix = slots.prefix) === null || _slots$prefix === void 0 ? void 0 : _slots$prefix.call(slots)]);
    };

    const renderSuffix = () => {
      var _slots$suffix;

      if (!slots.suffix) return null;
      return createVNode("span", {
        "class": `${prefixCls$6}-content-suffix`,
        "onClick": handleStopClickPrefix
      }, [(_slots$suffix = slots.suffix) === null || _slots$suffix === void 0 ? void 0 : _slots$suffix.call(slots)]);
    };

    return () => createVNode("div", {
      "class": classList.value,
      "data-value": props.value,
      "role": "cascader-node"
    }, [renderCheckbox(), renderRadio(), createVNode("span", {
      "class": `${prefixCls$6}-content`,
      "onClick": handleClickContent,
      "onMouseenter": handleHoverContent
    }, [renderPrefix(), createVNode("span", {
      "class": `${prefixCls$6}-content-label`
    }, [createVNode(FEllipsis, {
      "content": props.label
    }, null)]), renderSuffix()]), renderSwitcher()]);
  }

});

// 
const getCascadeChildrenByKeys = function (nodeList) {
  let keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let arr = [...keys];
  keys.forEach(value => {
    const node = nodeList[value]; // 

    if (node && isArray$1(node.children)) {
      arr = arr.concat(getCascadeChildrenByKeys(nodeList, node.children.map(child => child.value)));
    }
  });
  return arr;
}; // 

const getCascadeParentByKeys = function (nodeList) {
  let keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const res = {};
  keys.forEach(value => {
    const node = nodeList[value]; // 

    if (node) {
      if (!res[node.level]) {
        res[node.level] = [];
      }

      res[node.level].push(node.value);
    }
  });
  const levels = Object.keys(res).map(key => Number(key));
  const maxLevel = levels[levels.length - 1];

  for (let level = maxLevel; level > 0; level--) {
    const levelValues = res[level];

    if (levelValues) {
      levelValues.forEach(value => {
        const node = nodeList[value];
        const parentValue = node.indexPath[node.indexPath.length - 2];

        if (parentValue) {
          const parentNode = nodeList[parentValue];

          if (parentNode.children.every(child => levelValues.includes(child.value))) {
            if (!res[level - 1]) {
              res[level - 1] = [];
            }

            if (!res[level - 1].includes(parentValue)) {
              res[level - 1].push(parentValue);
            }
          }
        }
      });
    }
  }

  let arr = [];
  Object.values(res).forEach(levelValues => {
    arr = arr.concat(levelValues);
  });
  return arr;
}; // 

function handleChildren(arr, children, isAdd) {
  children && children.forEach(child => {
    const index = arr.indexOf(child.value);

    if (!isAdd) {
      if (index !== -1) {
        arr.splice(index, 1);
      }
    } else if (index === -1) {
      arr.push(child.value);
    }

    if (child.children) {
      handleChildren(arr, child.children, isAdd);
    }
  });
} // 

function handleParent(arr, indexPath, isAdd, nodeList) {
  let len = indexPath.length - 2;

  for (len; len >= 0; len--) {
    const parent = nodeList[indexPath[len]];
    const index = arr.indexOf(parent.value);

    if (!isAdd) {
      if (index !== -1) {
        arr.splice(index, 1);
      }
    } else if (index === -1) {
      if (parent.children.every(item => arr.includes(item.value))) {
        arr.push(parent.value);
      }
    }
  }
}
function scrollIntoParentView(element, parent) {
  parent = parent || element.parentElement;

  if (!parent) {
    return;
  } // offsetParent may not be parent.


  const elementToParent = element.offsetTop - parent.offsetTop;

  if (elementToParent - parent.scrollTop < 0) {
    parent.scrollTo({
      top: elementToParent
    });
  } else if (elementToParent + element.offsetHeight - parent.scrollTop > parent.offsetHeight) {
    parent.scrollTo({
      top: elementToParent + element.offsetHeight - parent.offsetHeight
    });
  }
}

const prefixCls$5 = getPrefixCls('cascader-menu');
const scrollbarContainerClass = `${prefixCls$5}-dropdown`;
const nodePrefixCls = getPrefixCls('cascader-node');
const cascaderMenuProps = {
  menuKey: {
    type: [String, Number],
    required: true
  },
  initialLoaded: Boolean,
  listEmptyText: String
};
var CascaderMenu = defineComponent({
  name: COMPONENT_NAME.CASCADER_MENU,
  props: cascaderMenuProps,

  setup(props) {
    const scrollbarRef = ref(null);
    const {
      menuNodes,
      isCascaderOpened,
      menuScrollNode
    } = useCascaderMenu(props);

    const renderNode = node => {
      const itemSlots = {};

      if (isFunction(node.prefix)) {
        itemSlots.prefix = node.prefix;
      }

      if (isString$1(node.prefix)) {
        itemSlots.prefix = () => node.prefix;
      }

      if (isFunction(node.suffix)) {
        itemSlots.suffix = node.suffix;
      }

      if (isString$1(node.suffix)) {
        itemSlots.suffix = () => node.suffix;
      }

      return createVNode(CascaderNode, {
        "key": node.value,
        "level": node.level,
        "value": node.value,
        "label": node.label,
        "disabled": node.disabled,
        "selectable": node.selectable,
        "checkable": node.checkable,
        "isLeaf": node.isLeaf
      }, itemSlots);
    };

    const renderNodes = nodes => nodes.map(node => renderNode(node)); // 


    const doScrollNode = async () => {
      await nextTick();

      if (!isCascaderOpened.value || !menuScrollNode.value) {
        return;
      }

      const scrollbarEl = getElementFromRef(scrollbarRef.value);
      const scrollbarContainerEl = scrollbarEl === null || scrollbarEl === void 0 ? void 0 : scrollbarEl.querySelector(`.${scrollbarContainerClass}`);
      const activeNodeEl = scrollbarContainerEl === null || scrollbarContainerEl === void 0 ? void 0 : scrollbarContainerEl.querySelector( // matches unescaped double quotes
      `.${nodePrefixCls}[data-value="${menuScrollNode.value.value}"]`);

      if (activeNodeEl) {
        scrollIntoParentView(activeNodeEl, scrollbarContainerEl);
      }
    };

    onMounted(() => {
      //  menu 
      watch([isCascaderOpened, () => props.menuKey], () => {
        doScrollNode();
      }, {
        flush: 'post',
        immediate: true
      });
    });
    return () => createVNode(FScrollbar, {
      "ref": scrollbarRef,
      "class": `${prefixCls$5}-scrollbar`,
      "containerClass": scrollbarContainerClass,
      "key": props.menuKey
    }, {
      default: () => [createVNode("div", {
        "class": `${prefixCls$5}`,
        "role": "cascader-menu"
      }, [menuNodes.value.length ? renderNodes(menuNodes.value) : props.initialLoaded ? createVNode("div", {
        "class": `${prefixCls$5}-null`
      }, [props.listEmptyText]) : createVNode("div", {
        "class": `${prefixCls$5}-loading`
      }, [createVNode(LoadingOutlined, null, null)])])]
    });
  }

});

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var useData = (_ref => {
  let {
    props,
    currentExpandedKeys
  } = _ref;
  const nodeList = reactive({});
  const transformData = ref([]);
  const initialLoaded = ref(true);
  const initLoadingKeys = ref([]);
  watch([currentExpandedKeys, transformData, initLoadingKeys], () => {
    // 
    transformData.value.forEach(key => {
      const node = nodeList[key];
      node.isExpanded = currentExpandedKeys.value.includes(key);
      node.isInitLoading = initLoadingKeys.value.includes(key);
    });
  }, {
    deep: true
  });
  const menuKeys = computed(() => {
    return [].concat(ROOT_MENU_KEY, currentExpandedKeys.value.filter(value => {
      // 
      return nodeList[value] && !nodeList[value].isLeaf;
    }));
  });

  const transformNode = function (item, indexPath, level) {
    let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    const value = item[props.valueField];
    const label = item[props.labelField];
    const children = item[props.childrenField];
    const hasChildren = !!(Array.isArray(children) && children.length);
    let isLeaf;

    if (!isNil(item.isLeaf)) {
      isLeaf = item.isLeaf;
    } else if (hasChildren) {
      isLeaf = false;
    } else if (props.remote) {
      isLeaf = false;
    } else {
      isLeaf = true;
    }

    let copy;
    const newItem = {
      origin: item,
      prefix: item.prefix,
      suffix: item.suffix,
      disabled: item.disabled,
      selectable: item.selectable,
      checkable: item.checkable,
      value,
      label,
      isLeaf,
      children,
      hasChildren,
      level,
      indexPath: [...indexPath, value],
      path: [...path, {
        value,
        label
      }],
      childrenValues: hasChildren ? children === null || children === void 0 ? void 0 : children.map(node => node[props.valueField]) : []
    }; // Object.assign 

    if (!nodeList[value]) {
      copy = Object.assign({}, newItem);
    } else {
      copy = nodeList[value];
      Object.assign(copy, newItem);
    }

    return copy;
  };

  const flatNodes = function () {
    let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let indexPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    let level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    let path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    return nodes.reduce((res, node) => {
      const copy = transformNode(node, indexPath, level, path); // 

      nodeList[copy.value] = copy;
      res.push(copy.value);

      if (copy.hasChildren) {
        res = res.concat(flatNodes(copy.children, copy.indexPath, level + 1, copy.path));
      }

      return res;
    }, []);
  };

  watch(() => props.data, async () => {
    //  props.data 
    if (props.remote && props.loadData && isEmpty(props.data)) {
      initialLoaded.value = false;

      try {
        const children = await props.loadData(null);
        isArray$1(children) && children.forEach(item => props.data.push(item));
        await nextTick();
      } catch (e) {
        console.error(e);
      }

      initialLoaded.value = true;
    } else {
      transformData.value = flatNodes(props.data);
    }
  }, {
    immediate: true,
    deep: true
  });

  const syncLoadNode = async function () {
    let loadedKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    const needLoadNodes = props.initLoadKeys.map(key => nodeList[key]).filter(node => !!node && !node.isLeaf && !node.hasChildren && !loadedKeys.includes(node.value) // 
    ); // 

    if (needLoadNodes.length) {
      needLoadNodes.forEach(async node => {
        initLoadingKeys.value.push(node.value);

        try {
          const children = await props.loadData(_objectSpread$2({}, node.origin));
          isArray$1(children) && (node.origin[props.childrenField] = children);
          await nextTick();
        } catch (e) {
          console.error(e);
        }

        initLoadingKeys.value = initLoadingKeys.value.filter(value => value !== node.value);
        loadedKeys.push(node.value);
        syncLoadNode(loadedKeys);
      });
    }
  };

  watch([initialLoaded, () => props.initLoadKeys], () => {
    if (!initialLoaded.value) {
      return;
    }

    if (!(props.remote && props.loadData)) {
      return;
    }

    syncLoadNode();
  }, {
    immediate: true
  });
  return {
    transformData,
    nodeList,
    menuKeys,
    initialLoaded
  };
});

var useState = ((props, _ref) => {
  let {
    emit
  } = _ref;
  const [currentExpandedKeys, updateExpandedKeys] = useNormalModel(props, emit, {
    prop: 'expandedKeys'
  });
  const [currentCheckedKeys, updateCheckedKeys] = useNormalModel(props, emit, {
    prop: 'checkedKeys'
  });
  const [currentSelectedKeys, updateSelectedKeys] = useNormalModel(props, emit, {
    prop: 'selectedKeys'
  });

  const hasSelected = value => currentSelectedKeys.value.includes(value);

  const hasChecked = value => currentCheckedKeys.value.includes(value);

  const hasLoaded = node => {
    // 
    if (node && !node.isLeaf && props.remote && props.loadData && !node.hasChildren) {
      return false;
    }

    return true;
  }; // 


  const hasCheckLoaded = (value, nodeList) => {
    return getCascadeChildrenByKeys(nodeList, [value]).every(key => hasLoaded(nodeList[key]));
  }; // 


  const hasActive = (value, nodeList) => {
    return !hasSelected(value) && currentSelectedKeys.value.some(key => {
      var _nodeList$key;

      return (_nodeList$key = nodeList[key]) === null || _nodeList$key === void 0 ? void 0 : _nodeList$key.indexPath.includes(value);
    });
  };

  return {
    currentExpandedKeys,
    updateExpandedKeys,
    currentCheckedKeys,
    updateCheckedKeys,
    currentSelectedKeys,
    updateSelectedKeys,
    hasSelected,
    hasChecked,
    hasLoaded,
    hasCheckLoaded,
    hasActive
  };
});

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$4 = getPrefixCls('cascader');
var Cascader = defineComponent({
  name: COMPONENT_NAME.CASCADER,
  props: _objectSpread$1({}, cascaderProps),
  emits: ['update:expandedKeys', 'update:checkedKeys', 'update:selectedKeys', 'update:nodeList', 'check', 'expand', 'load', 'select'],

  setup(props, _ref) {
    let {
      emit,
      expose
    } = _ref;
    useTheme();
    const {
      currentExpandedKeys,
      updateExpandedKeys,
      currentCheckedKeys,
      updateCheckedKeys,
      currentSelectedKeys,
      updateSelectedKeys,
      hasSelected,
      hasChecked,
      hasLoaded,
      hasCheckLoaded,
      hasActive
    } = useState(props, {
      emit
    });
    const {
      transformData,
      nodeList,
      menuKeys,
      initialLoaded
    } = useData({
      props,
      currentExpandedKeys
    });
    watch(nodeList, () => {
      emit('update:nodeList', nodeList);
    }, {
      immediate: true
    });
    const {
      t
    } = useLocale();
    const listEmptyText = computed(() => props.emptyText || t('select.emptyText'));

    const updateExpandedKeysBySelectOrCheck = (val, event) => {
      const node = nodeList[val]; // 

      const values = [...node.indexPath];
      updateExpandedKeys(values);
      emit('expand', {
        expandedKeys: values,
        event,
        node,
        expanded: values.includes(val)
      });
    };

    const selectNode = (val, event) => {
      if (!props.selectable) {
        return;
      }

      updateExpandedKeysBySelectOrCheck(val, event);
      const node = nodeList[val];
      const values = cloneDeep(currentSelectedKeys.value);
      const index = values.indexOf(val);

      if (props.multiple) {
        if (index !== -1) {
          props.cancelable && values.splice(index, 1);
        } else {
          values.push(val);
        }
      } else if (index !== -1) {
        props.cancelable && values.splice(index, 1);
      } else {
        values[0] = val;
      }

      updateSelectedKeys(values);
      emit('select', {
        selectedKeys: values,
        event,
        node,
        selected: values.includes(val)
      });
    };

    const expandNode = (val, event) => {
      const node = nodeList[val];
      const values = [...node.indexPath];
      updateExpandedKeys(values);
      emit('expand', {
        expandedKeys: values,
        event,
        node,
        expanded: values.includes(val)
      });
    };

    function getCheckedKeys(arr) {
      return props.cascade ? arr.filter(key => {
        const node = nodeList[key]; // 

        if (!node) {
          return false; // 
        }

        if (props.checkStrictly === CHECK_STRATEGY.ALL) {
          return true;
        }

        if (props.checkStrictly === CHECK_STRATEGY.PARENT) {
          return node.indexPath.filter(path => arr.includes(path)).length === 1;
        }

        if (props.checkStrictly === CHECK_STRATEGY.CHILD) {
          return node.isLeaf;
        }

        return true;
      }) : arr;
    }

    const checkNode = (val, event) => {
      updateExpandedKeysBySelectOrCheck(val, event);
      const node = nodeList[val];
      const {
        isLeaf,
        children,
        indexPath
      } = node;
      const values = cloneDeep(currentCheckedKeys.value);
      const index = values.indexOf(val);

      if (!props.cascade) {
        if (index !== -1) {
          values.splice(index, 1);
        } else {
          values.push(val);
        }
      } else if (index !== -1) {
        values.splice(index, 1);
        handleParent(values, indexPath, false, nodeList);

        if (!isLeaf) {
          handleChildren(values, children, false);
        }
      } else {
        values.push(val);
        handleParent(values, indexPath, true, nodeList);

        if (!isLeaf) {
          handleChildren(values, children, true);
        }
      }

      updateCheckedKeys(values);
      emit('check', {
        checkedKeys: getCheckedKeys(values),
        event,
        node,
        checked: values.includes(val)
      });
    };

    if (expose) {
      expose({
        selectNode,
        expandNode,
        checkNode
      });
    }

    provide(CASCADER_PROVIDE_KEY, {
      props,
      selectNode,
      expandNode,
      checkNode,
      hasSelected,
      hasChecked,
      hasLoaded,
      hasCheckLoaded,
      hasActive,
      transformData,
      nodeList
    });

    const renderMenu = key => {
      return createVNode(CascaderMenu, {
        "menuKey": key,
        "initialLoaded": initialLoaded.value,
        "listEmptyText": listEmptyText.value
      }, null);
    };

    const renderMenus = arr => arr.map(key => renderMenu(key));

    return () => createVNode("div", {
      "class": prefixCls$4,
      "role": "cascader"
    }, [renderMenus(menuKeys.value)]);
  }

});

const FCascader = withInstall(Cascader);

const getCurrentValueByKeys = function (nodeList) {
  let keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  let props = arguments.length > 2 ? arguments[2] : undefined;
  const value = props.multiple || props.emitPath ? [] : null;

  if (!keys.length) {
    return value;
  }

  if (props.multiple) {
    const nodeValues = Object.keys(nodeList); // 

    const notMatchedKeys = keys.filter(key => !nodeValues.includes(key)); // 

    return [].concat(notMatchedKeys, nodeValues.filter(key => keys.includes(key)).map(key => props.emitPath ? [...nodeList[key].indexPath] : key));
  } else {
    return props.emitPath ? [...nodeList[keys[0]].indexPath] : keys[0];
  }
};
const getKeysByCurrentValue = (currentValue, props) => {
  const keys = [];

  if (currentValue === null) {
    return keys;
  }

  if (props.multiple) {
    return currentValue.map(value => {
      if (props.emitPath && isArray$1(value)) {
        return value[value.length - 1];
      } else {
        return value;
      }
    });
  } else {
    if (props.emitPath && isArray$1(currentValue)) {
      return currentValue.slice(currentValue.length - 1);
    } else {
      return [currentValue];
    }
  }
};
const getNotMatchedPathByKey = (currentValue, props, key) => {
  let path = [];

  if (currentValue === null) {
    return path;
  }

  if (props.multiple) {
    const keyIndex = currentValue.findIndex(value => {
      if (props.emitPath && isArray$1(value)) {
        return value.includes(key);
      } else {
        return value === key;
      }
    });

    if (keyIndex > -1) {
      const keyValue = currentValue[keyIndex];

      if (props.emitPath && isArray$1(keyValue)) {
        path = keyValue.map(value => {
          return {
            value,
            label: value
          };
        });
      } else {
        path = [{
          value: keyValue,
          label: keyValue
        }];
      }
    }
  } else {
    if (props.emitPath && isArray$1(currentValue)) {
      if (currentValue.includes(key)) {
        path = currentValue.map(value => {
          return {
            value,
            label: value
          };
        });
      }
    } else {
      if (key === currentValue) {
        path = [{
          value: currentValue,
          label: currentValue
        }];
      }
    }
  }

  return path;
};
const getExpandedKeysBySelectedKeys = function (nodeList) {
  let selectedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const selectedNode = selectedKeys[0] && nodeList[selectedKeys[0]] || null;

  if (selectedNode) {
    // 
    return [...selectedNode.indexPath];
  } else {
    return [];
  }
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const prefixCls$3 = getPrefixCls('select-cascader');
var script$3 = defineComponent({
  name: 'FSelectCascader',
  components: {
    Popper: FPopper,
    SelectTrigger: script$l,
    Cascader
  },
  props: _objectSpread(_objectSpread({}, selectProps), cascaderProps),
  emits: [UPDATE_MODEL_EVENT$1, CHANGE_EVENT$1, 'removeTag', 'visibleChange', 'focus', 'blur', 'clear'],

  setup(props, _ref) {
    let {
      emit,
      attrs
    } = _ref;
    useTheme();
    const {
      validate,
      isError,
      isFormDisabled
    } = useFormAdaptor({
      valueType: computed(() => props.multiple ? 'array' : 'string')
    });
    const isOpened = ref(false);
    const [currentValue, updateCurrentValue] = props.multiple ? useArrayModel(props, emit) : useNormalModel(props, emit);
    const {
      t
    } = useLocale();
    const inputPlaceholder = computed(() => props.placeholder || t('select.placeholder'));
    const innerDisabled = computed(() => props.disabled || isFormDisabled.value);
    watch(isOpened, () => {
      emit('visibleChange', unref(isOpened));
    });

    const handleChange = () => {
      emit(CHANGE_EVENT$1, currentValue.value);
      validate(CHANGE_EVENT$1);
    };

    const nodeList = ref({});

    const onChangeNodeList = data => {
      nodeList.value = data;
    };

    const cascaderSelectable = computed(() => !props.multiple);
    const cascaderCheckable = computed(() => props.multiple);
    const selectedKeys = computed(() => {
      if (!props.multiple) {
        return getKeysByCurrentValue(currentValue.value, props);
      }

      return [];
    });
    const expandedKeys = computed(() => {
      if (!props.multiple) {
        return getExpandedKeysBySelectedKeys(nodeList.value, selectedKeys.value);
      }

      return [];
    });
    const checkedKeys = computed(() => {
      if (props.multiple) {
        const keys = getKeysByCurrentValue(currentValue.value, props);

        if (!props.cascade) {
          return keys;
        }

        if (props.checkStrictly === CHECK_STRATEGY.ALL) {
          return keys;
        }

        if (props.checkStrictly === CHECK_STRATEGY.PARENT) {
          return getCascadeChildrenByKeys(nodeList.value, keys);
        }

        if (props.checkStrictly === CHECK_STRATEGY.CHILD) {
          return getCascadeParentByKeys(nodeList.value, keys);
        }
      }

      return [];
    });
    const initLoadKeys = computed(() => {
      let keys = [];

      if (!(props.remote && props.loadData)) {
        return keys;
      }

      if (!props.emitPath) {
        return keys;
      }

      if (!isArray$1(currentValue.value)) {
        return keys;
      }

      currentValue.value.forEach(value => keys = keys.concat(value));
      keys = Array.from(new Set(keys)); // 

      return keys;
    });
    watch(() => props.checkStrictly, () => {
      if (props.multiple && props.cascade) {
        updateCurrentValue([]);
        handleChange();
      }
    });
    watch([() => props.emitPath, () => props.cascade], () => {
      const value = props.multiple || props.emitPath ? [] : null;
      updateCurrentValue(value);
      handleChange();
    });

    const handleClear = () => {
      const value = props.multiple || props.emitPath ? [] : null;

      if (props.multiple ? checkedKeys.value.length : selectedKeys.value.length) {
        updateCurrentValue(value);
        handleChange();
      }

      emit('clear');
    };

    const handleSelect = data => {
      if (innerDisabled.value) return;

      if (!props.multiple) {
        isOpened.value = false;
      }

      updateCurrentValue(getCurrentValueByKeys(nodeList.value, data.selectedKeys, props));
      handleChange();
    };

    const handleCheck = data => {
      if (innerDisabled.value) return;

      if (!props.multiple) {
        isOpened.value = false;
      }

      updateCurrentValue(getCurrentValueByKeys(nodeList.value, data.checkedKeys, props));
      handleChange();
    };

    const handleRemove = value => {
      if (!props.multiple) {
        return;
      }

      const values = getKeysByCurrentValue(currentValue.value, props);
      const findIndex = values.indexOf(value);

      if (findIndex !== -1) {
        emit('removeTag', value); // 

        if (!props.cascade) {
          values.splice(findIndex, 1);
        } else {
          const {
            isLeaf,
            children,
            indexPath
          } = nodeList.value[value];
          values.splice(findIndex, 1);
          handleParent(values, indexPath, false, nodeList.value);

          if (!isLeaf) {
            handleChildren(values, children, false);
          }
        }

        updateCurrentValue(getCurrentValueByKeys(nodeList.value, values, props));
        handleChange();
      }
    };

    const selectedOptions = computed(() => {
      const values = getKeysByCurrentValue(currentValue.value, props); // 

      return values.filter(Boolean).map(curValue => {
        const {
          value,
          label,
          path
        } = nodeList.value[curValue] || {
          value: curValue,
          label: curValue,
          path: getNotMatchedPathByKey(currentValue.value, props, curValue)
        };
        const formatLabel = props.showPath ? path.map(item => `${item.label}`).join(' / ') : label;
        return {
          value,
          label: formatLabel,
          path
        };
      });
    });

    const focus = e => {
      emit('focus', e);
      validate('focus');
    };

    const blur = e => {
      if (isOpened.value) {
        isOpened.value = false;
      }

      emit('blur', e);
      validate('blur');
    };

    return {
      prefixCls: prefixCls$3,
      isOpened,
      currentValue,
      handleRemove,
      handleClear,
      selectedOptions,
      focus,
      blur,
      cascaderSelectable,
      selectedKeys,
      expandedKeys,
      cascaderCheckable,
      handleSelect,
      handleCheck,
      checkedKeys,
      onChangeNodeList,
      inputPlaceholder,
      isError,
      initLoadKeys,
      attrs,
      innerDisabled
    };
  }

});

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectTrigger = resolveComponent("SelectTrigger");

  const _component_Cascader = resolveComponent("Cascader");

  const _component_Popper = resolveComponent("Popper");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.prefixCls)
  }, [createVNode(_component_Popper, {
    modelValue: _ctx.isOpened,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => _ctx.isOpened = $event),
    trigger: "click",
    placement: "bottom-start",
    popperClass: `${_ctx.prefixCls}-popper`,
    appendToContainer: _ctx.appendToContainer,
    getContainer: _ctx.getContainer,
    offset: 4,
    hideAfter: 0,
    disabled: _ctx.innerDisabled,
    lazy: false
  }, {
    trigger: withCtx(() => [createVNode(_component_SelectTrigger, {
      selectedOptions: _ctx.selectedOptions,
      disabled: _ctx.innerDisabled,
      clearable: _ctx.clearable,
      isOpened: _ctx.isOpened,
      multiple: _ctx.multiple,
      placeholder: _ctx.inputPlaceholder,
      collapseTags: _ctx.collapseTags,
      collapseTagsLimit: _ctx.collapseTagsLimit,
      tagBordered: _ctx.tagBordered,
      class: normalizeClass([{
        'is-error': _ctx.isError
      }, _ctx.attrs.class]),
      style: normalizeStyle(_ctx.attrs.style),
      renderTag: _ctx.$slots.tag,
      onRemove: _ctx.handleRemove,
      onClear: _ctx.handleClear,
      onFocus: _ctx.focus,
      onBlur: _ctx.blur
    }, null, 8
    /* PROPS */
    , ["selectedOptions", "disabled", "clearable", "isOpened", "multiple", "placeholder", "collapseTags", "collapseTagsLimit", "tagBordered", "class", "style", "renderTag", "onRemove", "onClear", "onFocus", "onBlur"])]),
    default: withCtx(() => [createVNode(_component_Cascader, {
      selectedKeys: _ctx.selectedKeys,
      checkedKeys: _ctx.checkedKeys,
      initLoadKeys: _ctx.initLoadKeys,
      data: _ctx.data,
      emptyText: _ctx.emptyText,
      expandedKeys: _ctx.expandedKeys,
      selectable: _ctx.cascaderSelectable,
      checkable: _ctx.cascaderCheckable,
      checkStrictly: _ctx.checkStrictly,
      cascade: _ctx.cascade,
      multiple: _ctx.multiple,
      childrenField: _ctx.childrenField,
      valueField: _ctx.valueField,
      labelField: _ctx.labelField,
      remote: _ctx.remote,
      loadData: _ctx.loadData,
      expandTrigger: _ctx.expandTrigger,
      isOpened: _ctx.isOpened,
      "onUpdate:nodeList": _ctx.onChangeNodeList,
      onSelect: _ctx.handleSelect,
      onCheck: _ctx.handleCheck,
      onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {}, ["prevent"]))
    }, null, 8
    /* PROPS */
    , ["selectedKeys", "checkedKeys", "initLoadKeys", "data", "emptyText", "expandedKeys", "selectable", "checkable", "checkStrictly", "cascade", "multiple", "childrenField", "valueField", "labelField", "remote", "loadData", "expandTrigger", "isOpened", "onUpdate:nodeList", "onSelect", "onCheck"])]),
    _: 1
    /* STABLE */

  }, 8
  /* PROPS */
  , ["modelValue", "popperClass", "appendToContainer", "getContainer", "disabled"])], 2
  /* CLASS */
  );
}

script$3.render = render$3;
script$3.__file = "components/select-cascader/selectCascader.vue";

const FSelectCascader = withInstall(script$3);

const DESCRIPTIONS_PROVIDE_KEY = Symbol('DESCRIPTIONS_PROVIDE_KEY');

const prefixCls$2 = getPrefixCls('descriptions');
const descriptionsProps = {
  column: {
    type: Number,
    default: 3
  },
  contentStyle: [Object, String],
  labelAlign: {
    type: String,
    default: 'left',

    validator(value) {
      return ['left', 'right', 'center'].includes(value);
    }

  },
  labelPlacement: {
    type: String,
    default: 'left',

    validator(value) {
      return ['left', 'top'].includes(value);
    }

  },
  labelStyle: [Object, String],
  separator: {
    type: String,
    default: ':'
  },
  title: String,
  bordered: Boolean
};
var Descriptions = defineComponent({
  name: 'FDescriptions',
  props: descriptionsProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const style = computed(() => ({
      'grid-template-columns': `repeat(${props.column}, 1fr)`
    }));

    const renderHeader = () => {
      if (slots.header) {
        return slots.header();
      }

      if (props.title) {
        return createVNode("div", {
          "class": `${prefixCls$2}-header`
        }, [props.title]);
      }

      return null;
    };

    provide(DESCRIPTIONS_PROVIDE_KEY, {
      parentProps: computed(() => {
        return {
          column: props.column,
          contentStyle: props.contentStyle,
          labelAlign: props.labelAlign,
          labelPlacement: props.labelPlacement,
          labelStyle: props.labelStyle,
          separator: props.separator,
          bordered: props.bordered
        };
      })
    });
    return () => {
      var _slots$default;

      return createVNode("div", {
        "class": prefixCls$2
      }, [renderHeader(), createVNode("div", {
        "class": [`${prefixCls$2}-body`, props.bordered && 'is-bordered'],
        "style": style.value
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])]);
    };
  }

});

const prefixCls$1 = getPrefixCls('descriptions-item');
const DescriptionsItemProps = {
  contentStyle: [Object, String],
  label: String,
  labelStyle: [Object, String],
  span: {
    type: Number,
    default: 1
  }
};
var DescriptionsItem = defineComponent({
  name: 'FDescriptionsItem',
  props: DescriptionsItemProps,

  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      parentProps
    } = inject(DESCRIPTIONS_PROVIDE_KEY);
    const style = computed(() => {
      return {
        display: 'flex',
        'flex-direction': parentProps.value.labelPlacement === 'left' ? 'row' : 'column',
        'grid-column-start': `span ${props.span <= parentProps.value.column ? props.span : parentProps.value.column}`
      };
    });
    const innerContentStyle = computed(() => {
      return [parentProps.value.contentStyle, props.contentStyle].filter(Boolean);
    });
    const innerLabelStyle = computed(() => {
      return [parentProps.value.labelStyle, props.labelStyle, {
        textAlign: parentProps.value.labelAlign
      }].filter(Boolean);
    });

    const renderLabel = () => {
      if (slots.label) {
        return slots.label();
      }

      if (props.label) {
        return props.label;
      }

      return null;
    };

    const renderSeparator = () => {
      if (parentProps.value.labelPlacement === 'left' && !parentProps.value.bordered) {
        return createVNode("span", {
          "class": `${prefixCls$1}-separator`
        }, [parentProps.value.separator]);
      }

      return null;
    };

    return () => {
      var _slots$default;

      return createVNode("div", {
        "style": style.value
      }, [createVNode("label", {
        "class": [`${prefixCls$1}-label`, parentProps.value.labelPlacement === 'top' && 'is-top', parentProps.value.bordered && 'is-bordered'],
        "style": innerLabelStyle.value
      }, [renderLabel()]), renderSeparator(), createVNode("span", {
        "class": [`${prefixCls$1}-content`, parentProps.value.bordered && 'is-bordered'],
        "style": innerContentStyle.value
      }, [(_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots)])]);
    };
  }

});

const FDescriptions = withInstall(Descriptions, {
  DescriptionsItem
});
const FDescriptionsItem = withNoopInstall(DescriptionsItem);

const definePropType = val => val;
const generateId = () => Math.floor(Math.random() * 10000);
const collapseContextKey = Symbol('collapseContextKey');
const arrowPositionKey = Symbol('arrow_position');

// 
const mutable = val => val;

const emitChangeFn = value => typeof isNumber(value) || isString$1(value) || Array.isArray(value);
const collapseProps = {
  accordion: Boolean,
  arrow: {
    type: String,
    default: 'right' // 'left', 'right', right

  },
  modelValue: {
    type: definePropType([Array, String, Number]),
    default: () => mutable([]) // 

  }
};
const collapseEmits = {
  [UPDATE_MODEL_EVENT$1]: emitChangeFn,
  [CHANGE_EVENT$1]: emitChangeFn
};

const defaultNamespace = 'fes';
const statePrefix = 'is-';

const _bem = (namespace, block, blockSuffix, element, modifier) => {
  let cls = `${namespace}-${block}`;

  if (blockSuffix) {
    cls += `-${blockSuffix}`;
  }

  if (element) {
    cls += `__${element}`;
  }

  if (modifier) {
    cls += `--${modifier}`;
  }

  return cls;
};

const useNamespace = block => {
  const namespace = computed(() => defaultNamespace);

  const b = function () {
    let blockSuffix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return _bem(namespace.value, block, blockSuffix, '', '');
  };

  const e = element => element ? _bem(namespace.value, block, '', element, '') : '';

  const m = modifier => modifier ? _bem(namespace.value, block, '', '', modifier) : '';

  const be = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, '') : '';

  const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, '', element, modifier) : '';

  const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, '', modifier) : '';

  const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : '';

  const is = function (name) {
    const state = (arguments.length <= 1 ? 0 : arguments.length - 1) >= 1 ? arguments.length <= 1 ? undefined : arguments[1] : true;
    return name && state ? `${statePrefix}${name}` : '';
  };

  return {
    namespace,
    b,
    e,
    m,
    be,
    em,
    bm,
    bem,
    is
  };
};

var script$2 = defineComponent({
  name: 'FCollapse',
  props: collapseProps,
  emits: collapseEmits,

  setup(props, _ref) {
    let {
      emit
    } = _ref;
    useTheme();
    const [activeNames, setActiveNames] = useNormalModel(props, emit);

    const handleItemClick = name => {
      if (props.accordion) {
        setActiveNames([activeNames.value[0] === name ? '' : name]);
      } else {
        const _activeNames = [...activeNames.value];

        const index = _activeNames.indexOf(name);

        if (index > -1) {
          _activeNames.splice(index, 1);
        } else {
          _activeNames.push(name);
        }

        setActiveNames(_activeNames);
      }
    };

    provide(collapseContextKey, {
      activeNames,
      handleItemClick
    });
    const ns = useNamespace('collapse');
    const rootKls = computed(() => ns.b());
    provide(arrowPositionKey, {
      arrow: props === null || props === void 0 ? void 0 : props.arrow
    });
    return {
      rootKls,
      activeNames,
      setActiveNames
    };
  }

});

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.rootKls),
    role: "tablist",
    "aria-multiselectable": "true"
  }, [renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script$2.render = render$2;
script$2.__file = "components/collapse/collapse.vue";

const collapseItemProps = {
  title: {
    type: String,
    default: ''
  },
  name: {
    type: definePropType([String, Number]),
    default: () => generateId()
  },
  disabled: Boolean
};

const useCollapseItem = props => {
  const collapse = inject(collapseContextKey);
  const focusing = ref(false);
  const isClick = ref(false);
  const id = ref(generateId());
  const isActive = computed(() => collapse === null || collapse === void 0 ? void 0 : collapse.activeNames.value.includes(props.name));

  const handleFocus = () => {
    setTimeout(() => {
      if (!isClick.value) {
        focusing.value = true;
      } else {
        isClick.value = false;
      }
    }, 50);
  };

  const handleHeaderClick = () => {
    if (props.disabled) return;
    collapse === null || collapse === void 0 ? void 0 : collapse.handleItemClick(props.name);
    focusing.value = false;
    isClick.value = true;
  };

  const handleEnterClick = () => {
    collapse === null || collapse === void 0 ? void 0 : collapse.handleItemClick(props.name);
  };

  return {
    focusing,
    id,
    isActive,
    handleFocus,
    handleHeaderClick,
    handleEnterClick
  };
};
const useCollapseItemDOM = (props, _ref) => {
  let {
    focusing,
    isActive,
    id
  } = _ref;
  const ns = useNamespace('collapse');
  const rootKls = computed(() => [ns.b('item'), ns.is('active', unref(isActive)), ns.is('disabled', props.disabled)]);
  const headKls = computed(() => [ns.be('item', 'header'), ns.is('active', unref(isActive)), {
    focusing: unref(focusing) && !props.disabled
  }]);
  const arrowKls = computed(() => [ns.be('item', 'arrow'), ns.is('active', unref(isActive))]);
  const itemWrapperKls = computed(() => ns.be('item', 'wrap'));
  const itemContentKls = computed(() => ns.be('item', 'content'));
  const scopedContentId = computed(() => ns.b(`content-${unref(id)}`));
  const scopedHeadId = computed(() => ns.b(`head-${unref(id)}`));
  return {
    arrowKls,
    headKls,
    rootKls,
    itemWrapperKls,
    itemContentKls,
    scopedContentId,
    scopedHeadId
  };
};

var script$1 = defineComponent({
  name: 'FCollapseItem',
  components: {
    FadeInExpandTransition,
    RightOutlined
  },
  props: collapseItemProps,

  setup(props) {
    useTheme();
    const {
      arrow
    } = inject(arrowPositionKey);
    const {
      focusing,
      id,
      isActive,
      handleFocus,
      handleHeaderClick,
      handleEnterClick
    } = useCollapseItem(props);
    const {
      arrowKls,
      headKls,
      rootKls,
      itemWrapperKls,
      itemContentKls,
      scopedContentId,
      scopedHeadId
    } = useCollapseItemDOM(props, {
      focusing,
      isActive,
      id
    });
    return {
      arrow,
      arrowKls,
      headKls,
      rootKls,
      itemWrapperKls,
      itemContentKls,
      scopedContentId,
      scopedHeadId,
      focusing,
      isActive,
      handleFocus,
      handleHeaderClick,
      handleEnterClick
    };
  }

});

const _hoisted_1 = ["aria-expanded", "aria-controls", "aria-describedby"];
const _hoisted_2 = ["id", "tabindex"];
const _hoisted_3 = ["id", "aria-hidden", "aria-labelledby"];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_right_outlined = resolveComponent("right-outlined");

  const _component_FadeInExpandTransition = resolveComponent("FadeInExpandTransition");

  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.rootKls)
  }, [createElementVNode("div", {
    role: "tab",
    "aria-expanded": _ctx.isActive,
    "aria-controls": _ctx.scopedContentId,
    "aria-describedby": _ctx.scopedContentId
  }, [createElementVNode("div", {
    id: _ctx.scopedHeadId,
    class: normalizeClass(_ctx.headKls),
    role: "button",
    tabindex: _ctx.disabled ? -1 : 0,
    onClick: _cache[0] || (_cache[0] = function () {
      return _ctx.handleHeaderClick && _ctx.handleHeaderClick(...arguments);
    }),
    onKeypress: _cache[1] || (_cache[1] = withKeys(withModifiers(function () {
      return _ctx.handleEnterClick && _ctx.handleEnterClick(...arguments);
    }, ["stop", "prevent"]), ["space", "enter"])),
    onFocus: _cache[2] || (_cache[2] = function () {
      return _ctx.handleFocus && _ctx.handleFocus(...arguments);
    }),
    onBlur: _cache[3] || (_cache[3] = $event => _ctx.focusing = false)
  }, [_ctx.arrow === 'left' ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["fes-collapse-item__arrow-left", _ctx.arrowKls])
  }, [createVNode(_component_right_outlined)], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), renderSlot(_ctx.$slots, "title", {}, () => [createTextVNode(toDisplayString(_ctx.title), 1
  /* TEXT */
  )]), _ctx.arrow === 'right' ? (openBlock(), createElementBlock("div", {
    key: 1,
    class: normalizeClass(_ctx.arrowKls)
  }, [createVNode(_component_right_outlined)], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true)], 42
  /* CLASS, PROPS, HYDRATE_EVENTS */
  , _hoisted_2)], 8
  /* PROPS */
  , _hoisted_1), createVNode(_component_FadeInExpandTransition, null, {
    default: withCtx(() => [withDirectives(createElementVNode("div", {
      id: _ctx.scopedContentId,
      class: normalizeClass(_ctx.itemWrapperKls),
      role: "tabpanel",
      "aria-hidden": !_ctx.isActive,
      "aria-labelledby": _ctx.scopedHeadId
    }, [createElementVNode("div", {
      class: normalizeClass(_ctx.itemContentKls)
    }, [renderSlot(_ctx.$slots, "default")], 2
    /* CLASS */
    )], 10
    /* CLASS, PROPS */
    , _hoisted_3), [[vShow, _ctx.isActive]])]),
    _: 3
    /* FORWARDED */

  })], 2
  /* CLASS */
  );
}

script$1.render = render$1;
script$1.__file = "components/collapse/collapseItem.vue";

const FCollapse = withInstall(script$2, {
  CollapseItem: script$1
});
const FCollapseItem = withNoopInstall(script$1);

const cardProps = {
  header: {
    type: String,
    default: ''
  },
  divider: {
    type: Boolean,
    default: true
  },
  bodyStyle: {
    type: Object,
    default: () => ({})
  },
  size: {
    type: String,
    default: 'middle'
  },
  shadow: {
    type: String,
    default: 'always'
  },
  bordered: {
    type: Boolean,
    default: true
  }
};

const prefixCls = getPrefixCls('card');
var script = defineComponent({
  name: 'FCard',
  props: cardProps,

  setup(props) {
    useTheme();
    const classes = computed(() => ({
      [prefixCls]: true,
      [`${prefixCls}-size--${props.size}`]: props.size,
      [`${prefixCls}-shadow--${props.shadow}`]: props.shadow,
      'is-bordered': props.bordered
    }));
    const headerClasses = computed(() => ({
      [`${prefixCls}__header`]: true,
      'no-divider': !props.divider
    }));
    return {
      prefixCls,
      classes,
      headerClasses
    };
  }

});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [_ctx.$slots.header || _ctx.header ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(_ctx.headerClasses)
  }, [renderSlot(_ctx.$slots, "header", {}, () => [createTextVNode(toDisplayString(_ctx.header), 1
  /* TEXT */
  )])], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), createElementVNode("div", {
    class: normalizeClass(`${_ctx.prefixCls}__body`),
    style: normalizeStyle(_ctx.bodyStyle)
  }, [renderSlot(_ctx.$slots, "default")], 6
  /* CLASS, STYLE */
  )], 2
  /* CLASS */
  );
}

script.render = render;
script.__file = "components/card/card.vue";

const FCard = withInstall(script);

const components = [FAlert, FButton, FCheckbox, FCheckboxGroup, FConfigProvider, FDivider, FDraggable, FDropdown, FEllipsis, FGrid, FGridItem, FInput, FInputNumber, FLayout, FAside, FFooter, FHeader, FMain, FMenu, FMenuGroup, FMenuItem, FSubMenu, FModal, FPopper, FRadio, FRadioButton, FRadioGroup, FScrollbar, FSelect, FOption, FSpin, FSteps, FStep, FSwitch, FTable, FTableColumn, FTabs, FTabPane, FTag, FTimePicker, FDatePicker, FTooltip, FTree, FUpload, FUploadDragger, FPagination, FImage, FPreviewGroup, FForm, FFormItem, FCarousel, FCarouselItem, FVirtualList, FDrawer, FSelectTree, FSpace, FSkeleton, FCascader, FSelectCascader, FDescriptions, FDescriptionsItem, FCollapse, FCollapseItem, FCard];

const install = function (app) {
  components.forEach(component => {
    app.use(component);
  });
  return app;
};
var index = {
  version: version$1,
  install
};

export { FAlert, FAside, FButton, FCard, FCarousel, FCarouselItem, FCascader, FCheckbox, FCheckboxGroup, FCollapse, FCollapseItem, FConfigProvider, FDatePicker, FDescriptions, FDescriptionsItem, FDivider, FDraggable, FDrawer, FDropdown, FEllipsis, FFooter, FForm, FFormItem, FGrid, FGridItem, FHeader, FImage, FInput, FInputNumber, FLayout, FMain, FMenu, FMenuGroup, FMenuItem, FMessage, FModal, FOption, FPagination, FPopper, FPreviewGroup, FRadio, FRadioButton, FRadioGroup, FScrollbar, FSelect, FSelectCascader, FSelectTree, FSkeleton, FSpace, FSpin, FStep, FSteps, FSubMenu, FSwitch, FTabPane, FTable, FTableColumn, FTabs, FTag, FTimePicker, FTooltip, FTree, FUpload, FUploadDragger, FVirtualList, index as default, enUS, install, version$1 as version, zhCN };
